{"version":3,"file":"simple-animation-system.js","mappings":"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","sources":["webpack://figma-to-tedium-deux/./src/simple-browser-entry.ts","webpack://figma-to-tedium-deux/./src/html/events/simple-animation-system.ts","webpack://figma-to-tedium-deux/webpack/bootstrap"],"sourcesContent":["/**\n * Simple Browser Entry Point\n * \n * Exports the simple animation system functions globally for use in HTML.\n */\n\nimport { \n  simpleAnimate, \n  simpleVariantSwitch, \n  instantVariantSwitch, \n  resetAnimationState \n} from './html/events/simple-animation-system';\n\n// Export functions globally\ndeclare global {\n  interface Window {\n    simpleAnimate: typeof simpleAnimate;\n    simpleVariantSwitch: typeof simpleVariantSwitch;\n    instantVariantSwitch: typeof instantVariantSwitch;\n    resetAnimationState: typeof resetAnimationState;\n  }\n}\n\n// Make functions available globally\nwindow.simpleAnimate = simpleAnimate;\nwindow.simpleVariantSwitch = simpleVariantSwitch;\nwindow.instantVariantSwitch = instantVariantSwitch;\nwindow.resetAnimationState = resetAnimationState;\n\nconsole.log('✅ Simple animation system loaded in browser');\nconsole.log('📋 Available functions:');\nconsole.log('  - simpleAnimate(source, target, options)');\nconsole.log('  - simpleVariantSwitch(source, target, options)');\nconsole.log('  - instantVariantSwitch(source, target)');\nconsole.log('  - resetAnimationState(source, target)');\n","/**\n * Simple Animation System\n * \n * A very basic animation system that:\n * 1. Takes a source element and target element\n * 2. Animates the source element to match the target's position\n * 3. Shows the target element when done\n * \n * No complex three-phase system, no copying, just simple CSS transitions.\n */\n\ninterface SimpleAnimationOptions {\n  duration?: number; // in seconds\n  easing?: string; // CSS easing function\n  animateColor?: boolean; // whether to animate color changes\n  onComplete?: () => void;\n}\n\n/**\n * Simple animation function that moves an element from source to target position\n */\nexport function simpleAnimate(\n  sourceElement: HTMLElement,\n  targetElement: HTMLElement,\n  options: SimpleAnimationOptions = {}\n): Promise<void> {\n  return new Promise((resolve) => {\n    const {\n      duration = 0.5,\n      easing = 'ease-in-out',\n      animateColor = false,\n      onComplete\n    } = options;\n\n    console.log('🎬 SIMPLE ANIMATION: Starting animation');\n    console.log('📋 Source:', sourceElement.getAttribute('data-figma-id'));\n    console.log('📋 Target:', targetElement.getAttribute('data-figma-id'));\n\n    // Get positions from CSS styles instead of getBoundingClientRect\n    const sourceLeft = parseFloat(sourceElement.style.left) || 0;\n    const sourceTop = parseFloat(sourceElement.style.top) || 0;\n    const targetLeft = parseFloat(targetElement.style.left) || 0;\n    const targetTop = parseFloat(targetElement.style.top) || 0;\n\n    // Calculate the difference\n    const deltaX = targetLeft - sourceLeft;\n    const deltaY = targetTop - sourceTop;\n\n    console.log('📊 Source position:', { left: sourceLeft, top: sourceTop });\n    console.log('📊 Target position:', { left: targetLeft, top: targetTop });\n    console.log('📊 Position delta:', { deltaX, deltaY });\n\n    // Get color and opacity information if color animation is enabled\n    let sourceColor = '';\n    let targetColor = '';\n    let sourceBorderColor = '';\n    let targetBorderColor = '';\n    let sourceOpacity = '';\n    let targetOpacity = '';\n    let hasColorChange = false;\n    let hasBorderColorChange = false;\n    let hasOpacityChange = false;\n    \n    console.log('🎨 Color animation enabled:', animateColor);\n    \n    if (animateColor) {\n      const sourceComputedStyle = window.getComputedStyle(sourceElement);\n      const targetComputedStyle = window.getComputedStyle(targetElement);\n      \n      sourceColor = sourceComputedStyle.backgroundColor;\n      targetColor = targetComputedStyle.backgroundColor;\n      sourceBorderColor = sourceComputedStyle.borderColor;\n      targetBorderColor = targetComputedStyle.borderColor;\n      sourceOpacity = sourceComputedStyle.opacity;\n      targetOpacity = targetComputedStyle.opacity;\n      \n      console.log('🎨 Raw source color:', sourceColor);\n      console.log('🎨 Raw target color:', targetColor);\n      console.log('🎨 Raw source border color:', sourceBorderColor);\n      console.log('🎨 Raw target border color:', targetBorderColor);\n      console.log('🎨 Raw source opacity:', sourceOpacity);\n      console.log('🎨 Raw target opacity:', targetOpacity);\n      \n      // Ensure we have valid color values\n      if (!sourceColor || sourceColor === 'rgba(0, 0, 0, 0)' || sourceColor === 'transparent') {\n        sourceColor = 'rgb(255, 107, 107)'; // Default red\n        console.log('🎨 Using default source color:', sourceColor);\n      }\n      if (!targetColor || targetColor === 'rgba(0, 0, 0, 0)' || targetColor === 'transparent') {\n        targetColor = 'rgb(243, 156, 18)'; // Default orange\n        console.log('🎨 Using default target color:', targetColor);\n      }\n      \n      hasColorChange = sourceColor !== targetColor;\n      hasBorderColorChange = sourceBorderColor !== targetBorderColor;\n      hasOpacityChange = sourceOpacity !== targetOpacity;\n      \n      console.log('🎨 Final source color:', sourceColor);\n      console.log('🎨 Final target color:', targetColor);\n      console.log('🎨 Final source border color:', sourceBorderColor);\n      console.log('🎨 Final target border color:', targetBorderColor);\n      console.log('🎨 Final source opacity:', sourceOpacity);\n      console.log('🎨 Final target opacity:', targetOpacity);\n      console.log('🎨 Color change detected:', hasColorChange);\n      console.log('🎨 Border color change detected:', hasBorderColorChange);\n      console.log('🎨 Opacity change detected:', hasOpacityChange);\n    }\n\n    // Hide the target element initially\n    targetElement.style.display = 'none';\n\n    // Use CSS animations instead of transitions for better simultaneous control\n    const animationName = `simple-animation-${Date.now()}`;\n    \n    // Create the keyframes for simultaneous animation\n    const keyframes = `\n      @keyframes ${animationName} {\n        0% {\n          transform: translate(0px, 0px);\n          ${animateColor && hasColorChange ? `background-color: ${sourceColor};` : ''}\n          ${animateColor && hasBorderColorChange ? `border-color: ${sourceBorderColor};` : ''}\n          ${animateColor && hasOpacityChange ? `opacity: ${sourceOpacity};` : ''}\n        }\n        100% {\n          transform: translate(${deltaX}px, ${deltaY}px);\n          ${animateColor && hasColorChange ? `background-color: ${targetColor};` : ''}\n          ${animateColor && hasBorderColorChange ? `border-color: ${targetBorderColor};` : ''}\n          ${animateColor && hasOpacityChange ? `opacity: ${targetOpacity};` : ''}\n        }\n      }\n    `;\n    \n    console.log('🎬 Keyframes created:', keyframes);\n    console.log('🎬 Expected final transform:', `translate(${deltaX}px, ${deltaY}px)`);\n    console.log('🎬 Expected final color:', targetColor);\n    console.log('🎬 Expected final border color:', targetBorderColor);\n    console.log('🎬 Expected final opacity:', targetOpacity);\n    \n    // Add the keyframes to the document\n    const style = document.createElement('style');\n    style.textContent = keyframes;\n    document.head.appendChild(style);\n    \n    // Apply the animation\n    sourceElement.style.animation = `${animationName} ${duration}s ${easing} forwards`;\n    \n    // Clean up the style element after animation\n    setTimeout(() => {\n      document.head.removeChild(style);\n    }, duration * 1000 + 100);\n\n    // Listen for animation completion\n    const onAnimationEnd = (event: AnimationEvent) => {\n      if (event.animationName === animationName) {\n        console.log('✅ SIMPLE ANIMATION: Animation completed');\n        \n        // Log the final computed values\n        const finalComputedStyle = window.getComputedStyle(sourceElement);\n        console.log('🎬 Final computed transform:', finalComputedStyle.transform);\n        console.log('🎬 Final computed color:', finalComputedStyle.backgroundColor);\n        \n        // Clean up\n        sourceElement.removeEventListener('animationend', onAnimationEnd);\n        sourceElement.style.animation = '';\n        \n        // Hide source and show target\n        sourceElement.style.display = 'none';\n        targetElement.style.display = 'flex';\n        \n        // Call completion callback\n        if (onComplete) {\n          onComplete();\n        }\n        \n        resolve();\n      }\n    };\n    \n    sourceElement.addEventListener('animationend', onAnimationEnd);\n    \n    // Fallback timeout\n    setTimeout(() => {\n      console.log('⏰ SIMPLE ANIMATION: Animation completed via timeout');\n      sourceElement.removeEventListener('animationend', onAnimationEnd);\n      sourceElement.style.animation = '';\n      sourceElement.style.display = 'none';\n      targetElement.style.display = 'flex';\n      \n      if (onComplete) {\n        onComplete();\n      }\n      \n      resolve();\n    }, duration * 1000 + 1000);\n\n    // Note: We're using a single timeout for completion, so no fallback needed\n  });\n}\n\n/**\n * Simple variant switch function\n */\nexport function simpleVariantSwitch(\n  sourceElement: HTMLElement,\n  targetElement: HTMLElement,\n  options: SimpleAnimationOptions = {}\n): Promise<void> {\n  console.log('🔄 SIMPLE VARIANT SWITCH: Starting variant switch');\n  \n  return simpleAnimate(sourceElement, targetElement, options);\n}\n\n/**\n * Instant variant switch (no animation)\n */\nexport function instantVariantSwitch(\n  sourceElement: HTMLElement,\n  targetElement: HTMLElement\n): void {\n  console.log('⚡ INSTANT VARIANT SWITCH: Switching without animation');\n  \n  sourceElement.style.display = 'none';\n  targetElement.style.display = 'flex';\n}\n\n/**\n * Reset animation state\n */\nexport function resetAnimationState(\n  sourceElement: HTMLElement,\n  targetElement: HTMLElement\n): void {\n  console.log('🔄 RESET: Resetting animation state');\n  \n  // Reset source element\n  sourceElement.style.display = 'flex';\n  sourceElement.style.transition = '';\n  sourceElement.style.transform = '';\n  \n  // Reset target element\n  targetElement.style.display = 'none';\n  targetElement.style.transition = '';\n  targetElement.style.transform = '';\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n"],"names":["simpleAnimate","sourceElement","targetElement","options","Promise","resolve","duration","easing","animateColor","onComplete","console","log","getAttribute","sourceLeft","parseFloat","style","left","sourceTop","top","targetLeft","targetTop","deltaX","deltaY","sourceColor","targetColor","sourceBorderColor","targetBorderColor","sourceOpacity","targetOpacity","hasColorChange","hasBorderColorChange","hasOpacityChange","sourceComputedStyle","window","getComputedStyle","targetComputedStyle","backgroundColor","borderColor","opacity","display","animationName","Date","now","keyframes","document","createElement","textContent","head","appendChild","animation","setTimeout","removeChild","onAnimationEnd","event","finalComputedStyle","transform","removeEventListener","addEventListener","transition","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","simpleVariantSwitch","instantVariantSwitch","resetAnimationState"],"sourceRoot":""}