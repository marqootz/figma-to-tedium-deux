(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["FigmaRefactoredSystem"] = factory();
	else
		root["FigmaRefactoredSystem"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 44:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createComponentSetInitializer = createComponentSetInitializer;
// Component set initialization logic
function createComponentSetInitializer() {
    return "\n      // Initialize component set variants - handle both single and multiple variants\n      // Handle both COMPONENT_SET and COMPONENT elements that contain variants\n      // With the new 1:1 structure, this will handle nested component sets correctly\n      const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"], [data-figma-type=\"COMPONENT\"]');\n      componentSets.forEach(componentSet => {\n        // Find all COMPONENT children - these are the variants\n        // Some may have explicit variant attributes, others are variants by hierarchy\n        const variants = componentSet.querySelectorAll('[data-figma-type=\"COMPONENT\"]');\n        \n        // Handle both single and multiple variants\n        if (variants.length >= 1) {\n          console.log('Initializing component set/instance with', variants.length, 'variants:', {\n            componentSetId: componentSet.getAttribute('data-figma-id'),\n            componentSetName: componentSet.getAttribute('data-figma-name'),\n            componentSetType: componentSet.getAttribute('data-figma-type'),\n            parentType: componentSet.parentElement?.getAttribute('data-figma-type'),\n            parentId: componentSet.parentElement?.getAttribute('data-figma-id'),\n            variantIds: Array.from(variants).map(v => v.getAttribute('data-figma-id'))\n          });\n          \n          // Reset opacity for all variants to ensure clean initial state\n          variants.forEach(variant => {\n            variant.style.opacity = '1'; // Ensure all variants start with opacity 1\n          });\n          \n          // For single components, just make them visible\n          if (variants.length === 1) {\n            const singleVariant = variants[0];\n            singleVariant.classList.add('variant-active');\n            singleVariant.classList.remove('variant-hidden');\n            console.log('Set single variant as active:', singleVariant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));\n          } else {\n            // For multiple variants, the FIRST variant should be active initially (where reactions are)\n            // This ensures the animation starts from the variant with reactions\n            variants.forEach((variant, index) => {\n              if (index === 0) {\n                variant.classList.add('variant-active');\n                variant.classList.remove('variant-hidden');\n                console.log('Set first variant as active (with reactions):', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));\n              } else {\n                variant.classList.add('variant-hidden');\n                variant.classList.remove('variant-active');\n                console.log('Set variant as hidden:', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));\n              }\n            });\n          }\n        }\n      });\n  ";
}


/***/ }),

/***/ 120:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createVariantSwitchingHandler = createVariantSwitchingHandler;
// Variant switching handler - instant switching only, no animation
function createVariantSwitchingHandler() {
    return "\n      // Handle variant switching - instant switching only, no animation\n      // This is a simple slideshow-like system that switches between variants instantly\n      const variantButtons = document.querySelectorAll('[data-variant], [data-variant-property-1]');\n      variantButtons.forEach(button => {\n        button.addEventListener('click', function() {\n          console.log('DEBUG: Variant switch clicked');\n          \n          const variant = this.getAttribute('data-variant') || this.getAttribute('data-variant-property-1');\n          const targetId = this.getAttribute('data-target');\n          \n          if (targetId) {\n            const target = document.querySelector(`[data-figma-id=\"${targetId}\"]`);\n            if (target) {\n              console.log('Variant switch:', { variant, targetId, targetName: target.getAttribute('data-figma-name') });\n              \n              // Find the specific component set that contains this button\n              let componentSet = target;\n              let buttonElement = this;\n              \n              // Walk up the DOM tree to find the immediate component set parent\n              while (buttonElement && buttonElement.parentElement) {\n                buttonElement = buttonElement.parentElement;\n                if (buttonElement.getAttribute('data-figma-type') === 'COMPONENT_SET') {\n                  componentSet = buttonElement;\n                  console.log('Found component set for switching:', {\n                    id: componentSet.getAttribute('data-figma-id'),\n                    name: componentSet.getAttribute('data-figma-name')\n                  });\n                  break;\n                }\n              }\n              \n              // Get all variants within this specific component set instance\n              const allVariants = Array.from(componentSet.children).filter(child => \n                child.getAttribute('data-figma-type') === 'COMPONENT' &&\n                (child.getAttribute('data-variant') || child.getAttribute('data-variant-property-1'))\n              );\n              \n              console.log('Found', allVariants.length, 'variants in component set:', componentSet.getAttribute('data-figma-id'));\n              \n              // INSTANT VARIANT SWITCHING - Hide all variants\n              allVariants.forEach(variant => {\n                variant.classList.add('variant-hidden');\n                variant.classList.remove('variant-active');\n                // Ensure all variants maintain their original positioning (relative with 0px)\n                variant.style.position = 'relative';\n                variant.style.top = '0px';\n                variant.style.left = '0px';\n                console.log('Hidden variant:', variant.getAttribute('data-figma-id'));\n              });\n              \n              // Show selected variant instantly\n              const selectedVariant = allVariants.find(v => \n                v.getAttribute('data-variant') === variant || \n                v.getAttribute('data-variant-property-1') === variant\n              );\n              \n              if (selectedVariant) {\n                selectedVariant.classList.add('variant-active');\n                selectedVariant.classList.remove('variant-hidden');\n                // Ensure selected variant maintains its original positioning\n                selectedVariant.style.position = 'relative';\n                selectedVariant.style.top = '0px';\n                selectedVariant.style.left = '0px';\n                console.log('Switched to variant:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));\n                \n                // Start timeout reactions for the newly active variant\n                startTimeoutReactionsForNewlyActiveVariant(selectedVariant);\n                startTimeoutReactionsForNestedComponents(selectedVariant);\n              } else {\n                console.log('Selected variant not found:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));\n              }\n            }\n          }\n        });\n      });\n  ";
}


/***/ }),

/***/ 172:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.officialStyleAnimate = exports.generateSimpleTransitionHandler = exports.createComponentSetInitializer = exports.createThreePhaseTransitionHandler = exports.createTimeoutHandler = exports.createReactionHandler = exports.createVariantSwitchingHandler = exports.generateVariantAttributes = exports.generateReactionAttributes = void 0;
exports.generateEventHandlingJavaScript = generateEventHandlingJavaScript;
exports.generateExternalScriptReference = generateExternalScriptReference;
// Re-export all event functions
var attributes_1 = __webpack_require__(275);
Object.defineProperty(exports, "generateReactionAttributes", ({ enumerable: true, get: function () { return attributes_1.generateReactionAttributes; } }));
Object.defineProperty(exports, "generateVariantAttributes", ({ enumerable: true, get: function () { return attributes_1.generateVariantAttributes; } }));
var variant_handler_1 = __webpack_require__(120);
Object.defineProperty(exports, "createVariantSwitchingHandler", ({ enumerable: true, get: function () { return variant_handler_1.createVariantSwitchingHandler; } }));
var reaction_handler_1 = __webpack_require__(332);
Object.defineProperty(exports, "createReactionHandler", ({ enumerable: true, get: function () { return reaction_handler_1.createReactionHandler; } }));
Object.defineProperty(exports, "createTimeoutHandler", ({ enumerable: true, get: function () { return reaction_handler_1.createTimeoutHandler; } }));
var three_phase_transition_handler_1 = __webpack_require__(261);
Object.defineProperty(exports, "createThreePhaseTransitionHandler", ({ enumerable: true, get: function () { return three_phase_transition_handler_1.createThreePhaseTransitionHandler; } }));
var initializer_1 = __webpack_require__(44);
Object.defineProperty(exports, "createComponentSetInitializer", ({ enumerable: true, get: function () { return initializer_1.createComponentSetInitializer; } }));
var simple_animation_system_1 = __webpack_require__(825);
Object.defineProperty(exports, "generateSimpleTransitionHandler", ({ enumerable: true, get: function () { return simple_animation_system_1.generateSimpleTransitionHandler; } }));
Object.defineProperty(exports, "officialStyleAnimate", ({ enumerable: true, get: function () { return simple_animation_system_1.officialStyleAnimate; } }));
var reaction_handler_2 = __webpack_require__(332);
// Main event handling JavaScript generator
function generateEventHandlingJavaScript() {
    return "\n    // Reference the external refactored-system.js file\n    // This file contains all the animation and event handling logic\n    console.log('DEBUG: Event handling JavaScript loaded');\n    \n    // Global function for testing event handlers\n    window.handleFigmaEvent = function(eventType, elementId) {\n      console.log('DEBUG: Manual event trigger:', eventType, elementId);\n      const element = document.querySelector(`[data-figma-id=\"${elementId}\"]`);\n      if (element) {\n        if (eventType === 'click') {\n          element.click();\n        } else if (eventType === 'variant-switch') {\n          const variantButton = element.querySelector('[data-variant], [data-variant-property-1]');\n          if (variantButton) {\n            variantButton.click();\n          }\n        }\n      }\n    };\n    \n    // Global timer tracking\n    const activeTimers = new Map();\n    \n    // CRITICAL FIX: Add click event handlers for reaction elements\n    ".concat((0, reaction_handler_2.createReactionHandler)(), "\n    \n    // Function to start timeout reactions for nested components within a parent element\n    function startTimeoutReactionsForNestedComponents(parentElement) {\n      if (!parentElement) return;\n      \n      // Find all nested components with timeout reactions within the parent\n      const nestedComponents = parentElement.querySelectorAll('[data-has-reactions=\"true\"]');\n      \n      nestedComponents.forEach(element => {\n        const elementId = element.getAttribute('data-figma-id');\n        const elementName = element.getAttribute('data-figma-name');\n        const computedStyle = window.getComputedStyle(element);\n        \n        // Only start timers for elements that are actually visible\n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n          \n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId);\n              const actionType = element.getAttribute('data-reaction-action-type');\n              const destinationId = element.getAttribute('data-reaction-destination');\n              const transitionType = element.getAttribute('data-reaction-transition-type');\n              const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n              \n              if (window.handleReaction) {\n                window.handleReaction(element, destinationId, transitionType, transitionDuration);\n              } else {\n                console.error('DEBUG: handleReaction function not found in external script');\n              }\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n          } else if (activeTimers.has(elementId)) {\n            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');\n          }\n        } else {\n          console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');\n        }\n      });\n    }\n    \n    // Function to start timeout reactions for a specific newly active variant\n    function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {\n      if (!newlyActiveElement) return;\n      \n      const elementId = newlyActiveElement.getAttribute('data-figma-id');\n      const elementName = newlyActiveElement.getAttribute('data-figma-name');\n      const parentComponent = newlyActiveElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n      const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n      \n      console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);\n      \n      // Only start timers for variants that are actually visible (not hidden by CSS)\n      const computedStyle = window.getComputedStyle(newlyActiveElement);\n      \n      if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n        const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');\n        const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');\n        const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');\n        const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');\n        const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');\n        \n        // Handle timeout reactions only for active variants that don't have an active timer\n        if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n          console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n          const timeoutId = setTimeout(() => {\n            activeTimers.delete(elementId); // Clear the timer when it completes\n            if (window.handleReaction) {\n              window.handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);\n            } else {\n              console.error('DEBUG: handleReaction function not found in external script');\n            }\n          }, (trigger.timeout || 0) * 1000);\n          activeTimers.set(elementId, timeoutId);\n        } else if (activeTimers.has(elementId)) {\n          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');\n        }\n        \n        // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant\n        startTimeoutReactionsForNestedComponents(newlyActiveElement);\n      } else {\n        console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n      }\n    }\n    \n    // Function to start timeout reactions for the initial visible variant\n    function startTimeoutReactionsForInitialVariant() {\n      // Find the first visible variant that should start the flow\n      const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"]');\n      console.log('DEBUG: Found', componentSets.length, 'component sets');\n      \n      // Also check for any elements with reactions\n      const allReactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n      console.log('DEBUG: Found', allReactionElements.length, 'total elements with reactions');\n      \n      // Log details about reaction elements\n      allReactionElements.forEach((element, index) => {\n        const elementId = element.getAttribute('data-figma-id');\n        const elementName = element.getAttribute('data-figma-name');\n        const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n        const computedStyle = window.getComputedStyle(element);\n        \n        console.log('DEBUG: Reaction element', index + 1, ':', {\n          id: elementId,\n          name: elementName,\n          trigger: trigger,\n          display: computedStyle.display,\n          visibility: computedStyle.visibility,\n          isActive: element.classList.contains('variant-active'),\n          isHidden: element.classList.contains('variant-hidden')\n        });\n      });\n      \n      componentSets.forEach(componentSet => {\n        const componentSetName = componentSet.getAttribute('data-figma-name');\n        const activeVariants = componentSet.querySelectorAll('.variant-active[data-has-reactions=\"true\"]');\n        console.log('DEBUG: Component set', componentSetName, 'has', activeVariants.length, 'active variants with reactions');\n        \n        // Only start timers for the first active variant in each component set\n        if (activeVariants.length > 0) {\n          const firstActiveVariant = activeVariants[0];\n          const elementId = firstActiveVariant.getAttribute('data-figma-id');\n          const elementName = firstActiveVariant.getAttribute('data-figma-name');\n          const computedStyle = window.getComputedStyle(firstActiveVariant);\n          \n          console.log('DEBUG: Processing initial variant:', elementId, 'name:', elementName, 'in component set:', componentSetName);\n          \n          // Only start timer if the variant is actually visible\n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(firstActiveVariant.getAttribute('data-reaction-trigger') || '{}');\n            \n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting initial timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);\n              \n              const timeoutId = setTimeout(() => {\n                console.log('DEBUG: Timeout triggered for element:', elementId, 'name:', elementName);\n                activeTimers.delete(elementId);\n                const actionType = firstActiveVariant.getAttribute('data-reaction-action-type');\n                const destinationId = firstActiveVariant.getAttribute('data-reaction-destination');\n                const transitionType = firstActiveVariant.getAttribute('data-reaction-transition-type');\n                const transitionDuration = firstActiveVariant.getAttribute('data-reaction-transition-duration');\n                \n                console.log('DEBUG: Calling handleReaction with:', {\n                  destinationId: destinationId,\n                  transitionType: transitionType,\n                  transitionDuration: transitionDuration\n                });\n                \n                // Call the handleReaction function from the external refactored-system.js\n                if (window.handleReaction) {\n                  window.handleReaction(firstActiveVariant, destinationId, transitionType, transitionDuration);\n                } else {\n                  console.error('DEBUG: handleReaction function not found in external script');\n                }\n              }, (trigger.timeout || 0) * 1000);\n              \n              activeTimers.set(elementId, timeoutId);\n              console.log('DEBUG: Created timeout timer for element:', elementId, 'timeout ID:', timeoutId, 'duration:', (trigger.timeout || 0) * 1000, 'ms');\n            } else {\n              console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n            }\n            \n            // CRITICAL FIX: Also start timeout reactions for any nested components within this initial variant\n            startTimeoutReactionsForNestedComponents(firstActiveVariant);\n          } else {\n            console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n          }\n        }\n      });\n      \n      // Also check for any non-variant elements with reactions\n      const nonVariantReactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]:not([data-figma-type=\"COMPONENT\"])');\n      nonVariantReactionElements.forEach(element => {\n        const elementId = element.getAttribute('data-figma-id');\n        const elementName = element.getAttribute('data-figma-name');\n        const computedStyle = window.getComputedStyle(element);\n        \n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n          \n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for initial non-variant element:', elementId, 'name:', elementName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId);\n              const actionType = element.getAttribute('data-reaction-action-type');\n              const destinationId = element.getAttribute('data-reaction-destination');\n              const transitionType = element.getAttribute('data-reaction-transition-type');\n              const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n              \n              if (window.handleReaction) {\n                window.handleReaction(element, destinationId, transitionType, transitionDuration);\n              } else {\n                console.error('DEBUG: handleReaction function not found in external script');\n              }\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n            \n            // CRITICAL FIX: Also start timeout reactions for any nested components within this element\n            startTimeoutReactionsForNestedComponents(element);\n          } else {\n            console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n          }\n        } else {\n          console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- not visible');\n        }\n      });\n    }\n    \n    document.addEventListener('DOMContentLoaded', function() {\n      console.log('DEBUG: DOMContentLoaded event fired');\n      console.log('DEBUG: Using external refactored-system.js file');\n      console.log('DEBUG: Starting component set initialization...');\n      \n      // Initialize component sets\n      const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"]');\n      console.log('DEBUG: Found', componentSets.length, 'component sets');\n      console.log('DEBUG: Component sets found:', Array.from(componentSets).map(cs => cs.getAttribute('data-figma-name')));\n      \n      componentSets.forEach(componentSet => {\n        const componentSetId = componentSet.getAttribute('data-figma-id');\n        const componentSetName = componentSet.getAttribute('data-figma-name');\n        const componentSetType = componentSet.getAttribute('data-figma-type');\n        const parentType = componentSet.parentElement ? componentSet.parentElement.getAttribute('data-figma-type') : 'NONE';\n        const parentId = componentSet.parentElement ? componentSet.parentElement.getAttribute('data-figma-id') : 'NONE';\n        \n        console.log('Initializing component set/instance with', componentSet.children.length, 'variants:', {\n          componentSetId: componentSetId,\n          componentSetName: componentSetName,\n          componentSetType: componentSetType,\n          parentType: parentType,\n          parentId: parentId\n        });\n        \n        // Get all variants (COMPONENT elements)\n        const variants = Array.from(componentSet.children).filter(child => \n          child.getAttribute('data-figma-type') === 'COMPONENT'\n        );\n        \n        if (variants.length > 0) {\n          // Set first variant as active\n          const firstVariant = variants[0];\n          const firstVariantId = firstVariant.getAttribute('data-figma-id');\n          console.log('Set first variant as active (with reactions):', firstVariantId, 'in component set:', componentSetId);\n          firstVariant.classList.add('variant-active');\n          firstVariant.classList.remove('variant-hidden');\n          \n          // Hide all other variants\n          variants.slice(1).forEach(variant => {\n            const variantId = variant.getAttribute('data-figma-id');\n            console.log('Set variant as hidden:', variantId, 'in component set:', componentSetId);\n            variant.classList.add('variant-hidden');\n            variant.classList.remove('variant-active');\n          });\n        }\n      });\n      \n      // Start timeout reactions after a short delay\n      setTimeout(() => {\n        console.log('DEBUG: Starting initial timeout reactions');\n        startTimeoutReactionsForInitialVariant();\n      }, 100);\n    });\n    \n    // Export timeout reaction functions for use by the three-phase transition handler\n    window.startTimeoutReactionsForNewlyActiveVariant = startTimeoutReactionsForNewlyActiveVariant;\n    window.startTimeoutReactionsForNestedComponents = startTimeoutReactionsForNestedComponents;\n  ");
}
// Generate script tag that references the external file
function generateExternalScriptReference() {
    return "<script src=\"refactored-system.js?v=".concat(Date.now(), "\"></script>");
}


/***/ }),

/***/ 261:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createThreePhaseTransitionHandler = createThreePhaseTransitionHandler;
/**
 * Creates a three-phase transition handler that follows the setup, animate, cleanup pattern
 */
function createThreePhaseTransitionHandler() {
    return "\n    // Global transition lock to prevent multiple simultaneous transitions\n    let isTransitionInProgress = false;\n    let currentTransitionPromise = null;\n    let currentAnimationSession = null;\n    \n    // Animation types\n    const AnimationType = {\n      SIMPLE: 'SIMPLE',\n      SIZE: 'SIZE', \n      TRANSFORM: 'TRANSFORM'\n    };\n    \n    // Translation conditions\n    const TranslationCondition = {\n      ABSOLUTE: 'ABSOLUTE',\n      RELATIVE_PADDING: 'RELATIVE_PADDING',\n      RELATIVE_ALIGNMENT: 'RELATIVE_ALIGNMENT'\n    };\n    \n    /**\n     * PHASE 1: SETUP - Sets initial values on nodes/variants/instances/sets/etc.\n     * Primes HTML for animation from variant 1 to 2\n     */\n    function setupAnimationSession(sourceElement, targetElement, allVariants, transitionType, transitionDuration) {\n      console.log('\uD83C\uDFAC SETUP PHASE: Initializing animation session');\n      \n      // Create animation session\n      const session = {\n        sourceElement,\n        targetElement,\n        sourceCopy: null,\n        allVariants,\n        transitionType,\n        transitionDuration,\n        isActive: true\n      };\n\n      // CRITICAL FIX: Reset all variants to a clean state first\n      allVariants.forEach(variant => {\n        // Reset any residual styling from previous animations\n        variant.style.position = 'relative';\n        variant.style.left = '';\n        variant.style.top = '';\n        variant.style.transform = '';\n        variant.style.transition = '';\n        \n        // Reset all nested elements within each variant\n        const nestedElements = variant.querySelectorAll('[data-figma-id]');\n        nestedElements.forEach(nestedElement => {\n          nestedElement.style.position = 'relative';\n          nestedElement.style.left = '';\n          nestedElement.style.top = '';\n          nestedElement.style.transform = '';\n          nestedElement.style.transition = '';\n        });\n      });\n\n      // Set initial state for all variants - only use display\n      allVariants.forEach(variant => {\n        if (variant === sourceElement) {\n          // Source variant should be visible initially\n          variant.classList.add('variant-active');\n          variant.classList.remove('variant-hidden');\n          variant.style.display = 'flex';\n        } else {\n          // All other variants should be hidden\n          variant.classList.add('variant-hidden');\n          variant.classList.remove('variant-active');\n          variant.style.display = 'none';\n        }\n      });\n\n      // Prepare target variant but keep it hidden\n      targetElement.classList.add('variant-active');\n      targetElement.classList.remove('variant-hidden');\n      targetElement.style.display = 'none';\n\n      // PHASE 1 IMPROVEMENT: Create copy in setup but keep it hidden\n      session.sourceCopy = createElementCopy(session.sourceElement);\n      console.log('\uD83D\uDCCB SETUP PHASE: Created source element copy (hidden)');\n      console.log('\uD83D\uDD0D DEBUG: Copy after creation - children:', session.sourceCopy ? session.sourceCopy.children.length : 'null');\n      console.log('\uD83D\uDD0D DEBUG: Copy after creation - innerHTML length:', session.sourceCopy ? session.sourceCopy.innerHTML.length : 'null');\n      \n      // Insert the copy into the DOM but keep it hidden\n      const sourceParent = session.sourceElement.parentElement;\n      if (sourceParent && session.sourceCopy) {\n        console.log('\uD83D\uDD0D DEBUG: About to insert copy. Source parent:', sourceParent.tagName, sourceParent.getAttribute('data-figma-id'));\n        console.log('\uD83D\uDD0D DEBUG: Copy element before insertion:', session.sourceCopy.tagName, session.sourceCopy.getAttribute('data-figma-id'));\n        \n        sourceParent.insertBefore(session.sourceCopy, session.sourceElement);\n        \n        console.log('\uD83D\uDD0D DEBUG: Copy inserted. Checking DOM...');\n        console.log('\uD83D\uDD0D DEBUG: Copy in DOM after insertion:', document.contains(session.sourceCopy));\n        console.log('\uD83D\uDD0D DEBUG: Copy parent after insertion:', session.sourceCopy.parentElement ? session.sourceCopy.parentElement.tagName : 'null');\n        console.log('\uD83D\uDD0D DEBUG: Copy next sibling:', session.sourceCopy.nextElementSibling ? session.sourceCopy.nextElementSibling.getAttribute('data-figma-id') : 'null');\n        console.log('\uD83D\uDD0D DEBUG: Copy previous sibling:', session.sourceCopy.previousElementSibling ? session.sourceCopy.previousElementSibling.getAttribute('data-figma-id') : 'null');\n        \n        hideCopy(session.sourceCopy, 'setup phase - keeping hidden until animation starts');\n        console.log('\uD83D\uDCCB SETUP PHASE: Inserted copy into DOM (hidden)');\n        console.log('\uD83D\uDD0D DEBUG: Copy after insertion - parent:', session.sourceCopy.parentElement ? 'exists' : 'null');\n        console.log('\uD83D\uDD0D DEBUG: Copy after insertion - display:', session.sourceCopy.style.display);\n      } else {\n        console.log('\u274C ERROR: Cannot insert copy - sourceParent:', !!sourceParent, 'session.sourceCopy:', !!session.sourceCopy);\n      }\n\n      console.log('\u2705 SETUP PHASE: Animation session initialized');\n      return session;\n    }\n    \n    /**\n     * PHASE 2: ANIMATE - Performs copy of source, hides source, animates values if necessary\n     */\n    async function animateVariantTransition(session) {\n      console.log('\uD83C\uDFAD ANIMATE PHASE: Starting variant transition animation');\n      \n      if (!session.isActive) {\n        console.log('\u274C ANIMATE PHASE: Session is not active, skipping animation');\n        return;\n      }\n\n      // PHASE 2 IMPROVEMENT: Show the copy and hide the source\n      if (session.sourceCopy) {\n        // Show the copy that was created in setup phase using enhanced display control\n        showCopy(session.sourceCopy, 'animate phase - starting animation');\n        console.log('\uD83D\uDCCB ANIMATE PHASE: Showed copy (created in setup phase)');\n      }\n\n      // Hide the original source element - only use display\n      session.sourceElement.style.display = 'none';\n      console.log('\uD83D\uDCCB ANIMATE PHASE: Hidden source element');\n      console.log('\uD83D\uDD0D DEBUG: Source element display:', session.sourceElement.style.display);\n      \n      // ENHANCED DISPLAY CONTROL: Detailed copy status logging\n      const copyStatus = getCopyDisplayStatus(session.sourceCopy);\n      console.log('\uD83D\uDD0D DEBUG: Copy display status:', copyStatus);\n      console.log('\uD83D\uDD0D DEBUG: Copy element children count:', session.sourceCopy ? session.sourceCopy.children.length : 'null');\n      console.log('\uD83D\uDD0D DEBUG: Copy element innerHTML length:', session.sourceCopy ? session.sourceCopy.innerHTML.length : 'null');\n\n      // Hide all other variants - only use display\n      session.allVariants.forEach(variant => {\n        if (variant !== session.sourceElement) {\n          variant.style.display = 'none';\n        }\n      });\n\n      // Animate the copy to match the destination\n      if (session.sourceCopy) {\n        await animateCopyToDestination(\n          session.sourceCopy,\n          session.targetElement,\n          session.sourceElement,\n          session.transitionType,\n          session.transitionDuration\n        );\n      }\n\n      console.log('\u2705 ANIMATE PHASE: Animation completed');\n      console.log('\uD83D\uDD04 PHASE TRANSITION: Animate \u2192 Cleanup');\n    }\n    \n    /**\n     * PHASE 3: CLEANUP - Deletes copy, shows target variant, resets animation system\n     */\n    function cleanupAnimationSession(session) {\n      console.log('\uD83E\uDDF9 CLEANUP PHASE: Starting cleanup');\n      console.log('\uD83E\uDDF9 CLEANUP PHASE: Removing copy and showing target variant');\n\n      // Remove the copy (proper three-phase cleanup)\n      if (session.sourceCopy) {\n        console.log('\uD83D\uDD0D DEBUG: About to remove copy. Copy in DOM:', document.contains(session.sourceCopy));\n        console.log('\uD83D\uDD0D DEBUG: Copy parent before removal:', session.sourceCopy.parentElement ? session.sourceCopy.parentElement.tagName : 'null');\n        console.log('\uD83D\uDD0D DEBUG: Copy final transform:', window.getComputedStyle(session.sourceCopy).transform);\n        console.log('\uD83D\uDD0D DEBUG: Copy final position:', {\n          left: window.getComputedStyle(session.sourceCopy).left,\n          top: window.getComputedStyle(session.sourceCopy).top,\n          position: window.getComputedStyle(session.sourceCopy).position\n        });\n        console.log('\uD83D\uDD0D DEBUG: Copy visibility before removal:', isCopyVisible(session.sourceCopy) ? 'visible' : 'hidden');\n        \n        // Log the final state of Frame 1232 in the copy before removal\n        const frame1232InCopy = session.sourceCopy.querySelector('[data-figma-name=\"Frame 1232\"]');\n        if (frame1232InCopy) {\n          console.log('\uD83D\uDD0D DEBUG: Frame 1232 in copy final transform:', window.getComputedStyle(frame1232InCopy).transform);\n          console.log('\uD83D\uDD0D DEBUG: Frame 1232 in copy final style.transform:', frame1232InCopy.style.transform);\n        }\n        \n        // ENHANCED DISPLAY CONTROL: Hide copy before removal for cleaner cleanup\n        hideCopy(session.sourceCopy, 'cleanup phase - hiding before removal');\n        \n        session.sourceCopy.remove();\n        session.sourceCopy = null;\n        console.log('\uD83D\uDDD1\uFE0F CLEANUP PHASE: Removed source copy');\n      } else {\n        console.log('\u274C ERROR: No copy to remove in cleanup phase');\n      }\n\n      // Hide the original source element permanently - only use display\n      session.sourceElement.style.display = 'none';\n      session.sourceElement.classList.add('variant-hidden');\n      session.sourceElement.classList.remove('variant-active');\n\n      // CRITICAL FIX: Reset all variants to a clean state before showing the destination\n      // BUT DO NOT clear transforms from the copy - leave it in final animated state\n      session.allVariants.forEach(variant => {\n        // Reset any residual styling from animations\n        variant.style.position = 'relative';\n        variant.style.left = '';\n        variant.style.top = '';\n        variant.style.transform = '';\n        variant.style.transition = '';\n        \n        // Reset all nested elements within each variant\n        // BUT EXCLUDE the copy element - don't clear its transforms\n        const nestedElements = variant.querySelectorAll('[data-figma-id]');\n        nestedElements.forEach(nestedElement => {\n          // Skip if this is part of the copy element\n          if (nestedElement.closest('[data-is-animation-copy=\"true\"]')) {\n            console.log('\uD83D\uDD0D DEBUG: Skipping transform clear for copy element:', nestedElement.getAttribute('data-figma-name'));\n            return;\n          }\n          \n          nestedElement.style.position = 'relative';\n          nestedElement.style.left = '';\n          nestedElement.style.top = '';\n          nestedElement.style.transform = '';\n          nestedElement.style.transition = '';\n        });\n      });\n      \n\n\n      // Show the destination variant with proper positioning - only use display\n      session.targetElement.style.display = 'flex';\n      session.targetElement.classList.add('variant-active');\n      session.targetElement.classList.remove('variant-hidden');\n\n      // Reset any absolute positioning that might have been applied during animation\n      session.targetElement.style.position = 'relative';\n      session.targetElement.style.left = '';\n      session.targetElement.style.top = '';\n      session.targetElement.style.transform = '';\n\n      // Ensure all nested components within the destination variant are visible - only use display\n      const nestedElements = session.targetElement.querySelectorAll('[data-figma-id]');\n      nestedElements.forEach(nestedElement => {\n        if (nestedElement.classList.contains('variant-hidden')) {\n          nestedElement.classList.remove('variant-hidden');\n        }\n        \n        if (!nestedElement.classList.contains('variant-hidden')) {\n          if (window.getComputedStyle(nestedElement).display === 'none') {\n            nestedElement.style.display = 'flex';\n          }\n        }\n      });\n\n      // Hide all other variants - only use display\n      session.allVariants.forEach(variant => {\n        if (variant !== session.targetElement) {\n          variant.classList.add('variant-hidden');\n          variant.classList.remove('variant-active');\n          variant.style.display = 'none';\n        }\n      });\n\n      // Mark session as inactive\n      session.isActive = false;\n\n      console.log('\u2705 CLEANUP PHASE: Animation session cleaned up');\n    }\n    \n    /**\n     * Helper function to create element copy\n     */\n    function createElementCopy(sourceElement) {\n      console.log('\uD83D\uDCCB Creating element copy for:', sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id'));\n      \n      const copy = sourceElement.cloneNode(true);\n      copy.setAttribute('data-figma-id', sourceElement.getAttribute('data-figma-id') + '-copy');\n      copy.setAttribute('data-is-animation-copy', 'true');\n      \n      // CRITICAL FIX: Inherit exact positioning from source element to prevent visual glitches\n      const sourceComputedStyle = window.getComputedStyle(sourceElement);\n      copy.style.position = sourceComputedStyle.position;\n      copy.style.left = sourceComputedStyle.left;\n      copy.style.top = sourceComputedStyle.top;\n      copy.style.right = sourceComputedStyle.right;\n      copy.style.bottom = sourceComputedStyle.bottom;\n      copy.style.margin = '0';\n      copy.style.padding = '0';\n      copy.style.pointerEvents = 'none';\n      copy.style.willChange = 'transform, left, top';\n      copy.style.zIndex = sourceComputedStyle.zIndex;\n      \n      // ENHANCED DISPLAY CONTROL: Initialize copy as hidden\n      copy.style.display = 'none';\n      \n      // CRITICAL FIX: Only use display for visibility, never opacity or visibility\n      // Remove any opacity or visibility styles that might have been inherited\n      copy.style.opacity = '';\n      copy.style.visibility = '';\n\n      console.log('\uD83D\uDCCB Copy creation completed');\n      return copy;\n    }\n    \n    /**\n     * ENHANCED DISPLAY CONTROL: Show copy element\n     */\n    function showCopy(copy, reason = '') {\n      if (!copy) {\n        console.log('\u274C ERROR: Cannot show copy - copy element is null');\n        return;\n      }\n      \n      // Determine the appropriate display value based on the original source element\n      const sourceElement = document.querySelector('[data-figma-id=\"' + copy.getAttribute('data-figma-id').replace('-copy', '') + '\"]');\n      let displayValue = 'flex'; // Default fallback\n      \n      if (sourceElement) {\n        const sourceComputedStyle = window.getComputedStyle(sourceElement);\n        displayValue = sourceComputedStyle.display;\n      }\n      \n      copy.style.display = displayValue;\n      console.log('\uD83D\uDC41\uFE0F DISPLAY CONTROL: Showed copy element' + (reason ? ' (' + reason + ')' : ''));\n      console.log('\uD83D\uDD0D DEBUG: Copy display set to:', displayValue);\n    }\n    \n    /**\n     * ENHANCED DISPLAY CONTROL: Hide copy element\n     */\n    function hideCopy(copy, reason = '') {\n      if (!copy) {\n        console.log('\u274C ERROR: Cannot hide copy - copy element is null');\n        return;\n      }\n      \n      copy.style.display = 'none';\n      console.log('\uD83D\uDE48 DISPLAY CONTROL: Hidden copy element' + (reason ? ' (' + reason + ')' : ''));\n    }\n    \n    /**\n     * ENHANCED DISPLAY CONTROL: Check if copy is visible\n     */\n    function isCopyVisible(copy) {\n      if (!copy) return false;\n      \n      const computedStyle = window.getComputedStyle(copy);\n      return computedStyle.display !== 'none';\n    }\n    \n    /**\n     * ENHANCED DISPLAY CONTROL: Get copy display status for debugging\n     */\n    function getCopyDisplayStatus(copy) {\n      if (!copy) {\n        return {\n          exists: false,\n          visible: false,\n          display: 'null',\n          computedDisplay: 'null'\n        };\n      }\n      \n      const computedStyle = window.getComputedStyle(copy);\n      return {\n        exists: true,\n        visible: isCopyVisible(copy),\n        display: copy.style.display,\n        computedDisplay: computedStyle.display,\n        inDOM: document.contains(copy)\n      };\n    }\n    \n    /**\n     * Helper function to animate copy to destination\n     */\n    async function animateCopyToDestination(copy, destination, originalSourceElement, transitionType, transitionDuration) {\n      return new Promise((resolve) => {\n        // Update copy content to match destination content\n        updateCopyContentToMatchDestination(copy, destination);\n        \n        // Find elements with property changes\n        const elementsToAnimate = findElementsWithPropertyChanges(destination, copy, originalSourceElement);\n        const easingFunction = getEasingFunction(transitionType);\n        const duration = parseFloat(transitionDuration || '0.3');\n        \n        if (elementsToAnimate.length > 0) {\n          console.log('\uD83C\uDFAD Animating copy with', elementsToAnimate.length, 'elements');\n          \n          // Setup animation for each element\n          elementsToAnimate.forEach(({ element, changes }) => {\n            // Handle nested instance variant switch as additional step (not replacement)\n            if (changes.isNestedInstanceVariantSwitch) {\n              handleNestedInstanceVariantSwitch(element, changes);\n            }\n            \n            // Always apply movement animations (even for nested instances)\n            const animationChanges = convertChangesToAnimationChanges(changes, element, originalSourceElement, destination);\n            animationChanges.forEach(change => {\n              applyAnimationChange(element, change, duration, easingFunction);\n            });\n          });\n          \n          // Monitor animation completion\n          const completedElements = new Set();\n          const totalAnimations = elementsToAnimate.length;\n          \n          const onTransitionEnd = (event) => {\n            const targetElement = event.target;\n            const propertyName = event.propertyName;\n            \n            console.log('\uD83C\uDFAD Transition end event fired:', {\n              target: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'),\n              propertyName: propertyName,\n              currentTransform: window.getComputedStyle(targetElement).transform\n            });\n            \n            // Find which animated element this transition belongs to\n            const animatedElement = elementsToAnimate.find(({ element }) => \n              targetElement === element || element.contains(targetElement)\n            );\n            \n            if (animatedElement) {\n              completedElements.add(animatedElement.element);\n              console.log('\uD83C\uDFAD Element animation completed:', animatedElement.element.getAttribute('data-figma-name') || animatedElement.element.getAttribute('data-figma-id'), 'Completed:', completedElements.size, '/', totalAnimations);\n              \n              if (completedElements.size >= totalAnimations) {\n                console.log('\uD83C\uDFAD All animations completed');\n                // Remove all event listeners\n                elementsToAnimate.forEach(({ element }) => {\n                  element.removeEventListener('transitionend', onTransitionEnd);\n                });\n                resolve();\n              }\n            }\n          };\n          \n          // Attach transitionend listener to each animated element\n          elementsToAnimate.forEach(({ element }) => {\n            console.log('\uD83C\uDFAD Attaching transitionend listener to:', element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id'));\n            element.addEventListener('transitionend', onTransitionEnd);\n          });\n          \n          // Fallback timeout\n          setTimeout(() => {\n            console.log('\uD83C\uDFAD Animation completed via timeout');\n            // Remove all event listeners\n            elementsToAnimate.forEach(({ element }) => {\n              element.removeEventListener('transitionend', onTransitionEnd);\n            });\n            resolve();\n          }, duration * 1000 + 3000);\n        } else {\n          resolve();\n        }\n      });\n    }\n    \n    /**\n     * Helper function to update copy content to match destination\n     */\n    function updateCopyContentToMatchDestination(copy, destination) {\n      console.log('\uD83D\uDCCB Updating copy content to match destination');\n      \n      const copyElements = copy.querySelectorAll('[data-figma-id]');\n      const destinationElements = destination.querySelectorAll('[data-figma-id]');\n      \n      // Create a map of destination elements by name\n      const destinationElementMap = new Map();\n      destinationElements.forEach(element => {\n        const name = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n        if (name) {\n          destinationElementMap.set(name, element);\n        }\n      });\n      \n      // Update each copy element's content to match destination\n      copyElements.forEach(copyElement => {\n        const copyElementName = copyElement.getAttribute('data-figma-name') || copyElement.getAttribute('data-figma-id');\n        const destinationElement = destinationElementMap.get(copyElementName);\n        \n        if (destinationElement) {\n          // Update text content\n          if (destinationElement.textContent !== copyElement.textContent) {\n            copyElement.textContent = destinationElement.textContent;\n          }\n          \n          // Update innerHTML for more complex content, but preserve positioning\n          if (destinationElement.innerHTML !== copyElement.innerHTML) {\n            // Preserve positioning before updating content\n            const allNestedElements = copyElement.querySelectorAll('[data-figma-id]');\n            const originalPositions = new Map();\n            \n            allNestedElements.forEach(nestedElement => {\n              const nestedElementName = nestedElement.getAttribute('data-figma-name') || nestedElement.getAttribute('data-figma-id');\n              const computedStyle = window.getComputedStyle(nestedElement);\n              originalPositions.set(nestedElementName, {\n                position: computedStyle.position,\n                left: computedStyle.left,\n                top: computedStyle.top,\n                transform: computedStyle.transform\n              });\n            });\n            \n            // Also preserve the copy element itself\n            const copyComputedStyle = window.getComputedStyle(copyElement);\n            originalPositions.set(copyElementName, {\n              position: copyComputedStyle.position,\n              left: copyComputedStyle.left,\n              top: copyComputedStyle.top,\n              transform: copyComputedStyle.transform\n            });\n            \n            // Update the innerHTML\n            copyElement.innerHTML = destinationElement.innerHTML;\n            \n            // Restore positioning after content update\n            originalPositions.forEach((positionData, elementName) => {\n              const elementToRestore = elementName === copyElementName ? \n                copyElement : \n                copyElement.querySelector('[data-figma-name=\"' + elementName + '\"]') ||\n                copyElement.querySelector('[data-figma-id=\"' + elementName + '\"]');\n              \n              if (elementToRestore) {\n                elementToRestore.style.position = positionData.position;\n                elementToRestore.style.left = positionData.left;\n                elementToRestore.style.top = positionData.top;\n                elementToRestore.style.transform = positionData.transform;\n              }\n            });\n          }\n          \n          // Update specific attributes that might contain content\n          const contentAttributes = ['data-content', 'data-text', 'title', 'alt'];\n          contentAttributes.forEach(attr => {\n            const destValue = destinationElement.getAttribute(attr);\n            const copyValue = copyElement.getAttribute(attr);\n            if (destValue !== copyValue && destValue !== null) {\n              copyElement.setAttribute(attr, destValue);\n            }\n          });\n        }\n      });\n      \n      // Ensure all elements in the copy have opacity 1\n      const allCopyElements = copy.querySelectorAll('*');\n      allCopyElements.forEach(element => {\n        element.style.opacity = '1';\n      });\n    }\n    \n    /**\n     * Helper function to find elements with property changes between variants\n     */\n    function findElementsWithPropertyChanges(targetVariant, currentVariant, originalSourceVariant) {\n      console.log('\uD83D\uDD0D Finding elements with property changes');\n      \n      // Check if this is a nested instance with internal variants\n      let isNestedInstance = false;\n      let parentInstance = null;\n      let parentComponentSet = null;\n      \n      if (originalSourceVariant) {\n        parentComponentSet = originalSourceVariant.closest('[data-figma-type=\"COMPONENT_SET\"]');\n        if (parentComponentSet) {\n          parentInstance = parentComponentSet.closest('[data-figma-type=\"INSTANCE\"]');\n          if (parentInstance) {\n            isNestedInstance = true;\n            console.log('\uD83D\uDD0D Detected nested instance structure');\n          }\n        }\n      }\n      \n      // Note: Nested instance detection is logged but doesn't bypass movement animations\n      if (isNestedInstance) {\n        console.log('\uD83D\uDD0D Detected nested instance structure - will handle both movement and internal variant switching');\n      }\n      \n      const targetElements = targetVariant.querySelectorAll('[data-figma-id]');\n      const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');\n      const sourceElementMap = new Map();\n      const elementsToAnimate = [];\n\n      console.log('\uD83D\uDD0D DEBUG: Found', targetElements.length, 'target elements and', sourceElements.length, 'source elements');\n\n      // Build source element map by name\n      sourceElements.forEach(sourceElement => {\n        const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');\n        if (sourceName) {\n          sourceElementMap.set(sourceName, sourceElement);\n          console.log('\uD83D\uDD0D DEBUG: Mapped source element:', sourceName);\n        }\n      });\n\n      // Check for parent alignment changes first\n      const parentAlignmentChanges = [];\n      targetElements.forEach(element => {\n        const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n        const sourceElement = sourceElementMap.get(targetName);\n        \n        if (sourceElement) {\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = element.parentElement;\n          \n          if (sourceParent && targetParent) {\n            const sourceParentStyle = window.getComputedStyle(sourceParent);\n            const targetParentStyle = window.getComputedStyle(targetParent);\n            \n            if (sourceParentStyle.justifyContent !== targetParentStyle.justifyContent ||\n                sourceParentStyle.alignItems !== targetParentStyle.alignItems) {\n              \n              const parentChanges = {\n                hasChanges: true,\n                justifyContent: { \n                  changed: sourceParentStyle.justifyContent !== targetParentStyle.justifyContent,\n                  sourceValue: sourceParentStyle.justifyContent,\n                  targetValue: targetParentStyle.justifyContent\n                },\n                alignItems: { \n                  changed: sourceParentStyle.alignItems !== targetParentStyle.alignItems,\n                  sourceValue: sourceParentStyle.alignItems,\n                  targetValue: targetParentStyle.alignItems\n                }\n              };\n              \n              // Find all children of the parent that should be animated\n              const parentElement = sourceElement.parentElement;\n              const childrenToAnimate = parentElement ? Array.from(parentElement.children) : [];\n              \n              childrenToAnimate.forEach(child => {\n                parentAlignmentChanges.push({\n                  element: child, // Animate the child, not the parent\n                  sourceElement: child,\n                  changes: parentChanges\n                });\n              });\n            }\n          }\n        }\n      });\n      \n      // Check for child position changes regardless of parent alignment changes\n      console.log('\uD83D\uDD0D DEBUG: About to check', targetElements.length, 'child elements for position changes');\n      targetElements.forEach(element => {\n          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n          const sourceElement = sourceElementMap.get(targetName);\n          \n          console.log('\uD83D\uDD0D DEBUG: Processing element in forEach:', targetName);\n          console.log('\uD83D\uDD0D DEBUG: Target element data-figma-y:', element.getAttribute('data-figma-y'));\n          console.log('\uD83D\uDD0D DEBUG: Checking element:', targetName, 'sourceElement found:', !!sourceElement);\n          \n          if (sourceElement) {\n            // Use original source variant for property detection, not the copy\n            const originalSourceElement = originalSourceVariant.querySelector('[data-figma-name=\"' + targetName + '\"]') || \n                                        originalSourceVariant.querySelector('[data-figma-id=\"' + sourceElement.getAttribute('data-figma-id') + '\"]');\n            \n            console.log('\uD83D\uDD0D DEBUG: originalSourceElement lookup result for ' + targetName + ':', originalSourceElement ? originalSourceElement.getAttribute('data-figma-id') : 'null');\n            console.log('\uD83D\uDD0D DEBUG: originalSourceElement found:', !!originalSourceElement);\n            console.log('\uD83D\uDD0D DEBUG: Original source element data-figma-y:', originalSourceElement ? originalSourceElement.getAttribute('data-figma-y') : 'null');\n            \n            if (originalSourceElement) {\n              console.log('\uD83D\uDD0D DEBUG: Calling detectPropertyChanges for:', targetName);\n              const changes = detectPropertyChanges(element, originalSourceElement, originalSourceElement);\n              \n              console.log('\uD83D\uDD0D DEBUG: Changes detected:', changes.hasChanges, changes);\n              \n              if (changes.hasChanges) {\n                console.log('\uD83D\uDD0D DEBUG: Adding element to animation list:', targetName);\n                elementsToAnimate.push({\n                  element: sourceElement, // Use copy for animation\n                  sourceElement: sourceElement, // Use copy for animation\n                  changes: changes\n                });\n              } else {\n                console.log('\uD83D\uDD0D DEBUG: No changes detected for:', targetName);\n              }\n            }\n          }\n        });\n      \n      // Also add parent alignment changes if any were found\n      if (parentAlignmentChanges.length > 0) {\n        console.log('\uD83D\uDD0D DEBUG: Found', parentAlignmentChanges.length, 'parent alignment changes');\n        console.log('\uD83D\uDD0D DEBUG: Parent alignment changes:', parentAlignmentChanges);\n        parentAlignmentChanges.forEach((change, index) => {\n          console.log('\uD83D\uDD0D DEBUG: Parent alignment change', index, ':', {\n            element: change.element.getAttribute('data-figma-name') || change.element.getAttribute('data-figma-id'),\n            justifyContent: change.changes.justifyContent,\n            alignItems: change.changes.alignItems\n          });\n        });\n        elementsToAnimate.push(...parentAlignmentChanges);\n      }\n      \n      console.log('\uD83D\uDD0D Found', elementsToAnimate.length, 'elements to animate');\n      return elementsToAnimate;\n    }\n    \n    /**\n     * Helper function to detect property changes between elements\n     */\n    function detectPropertyChanges(targetElement, sourceElement, originalSourceElement) {\n      console.log('\uD83D\uDD0D DEBUG: detectPropertyChanges called for:', {\n        targetElement: targetElement.getAttribute('data-figma-name'),\n        sourceElement: sourceElement.getAttribute('data-figma-name'),\n        originalSourceElement: originalSourceElement.getAttribute('data-figma-name')\n      });\n\n      const changes = {\n        hasChanges: false,\n        positionX: { changed: false, sourceValue: null, targetValue: null },\n        positionY: { changed: false, sourceValue: null, targetValue: null },\n        backgroundColor: { changed: false, sourceValue: null, targetValue: null },\n        color: { changed: false, sourceValue: null, targetValue: null },\n        justifyContent: { changed: false, sourceValue: null, targetValue: null },\n        alignItems: { changed: false, sourceValue: null, targetValue: null }\n      };\n\n      try {\n        const sourceStyle = window.getComputedStyle(sourceElement);\n        const targetStyle = window.getComputedStyle(targetElement);\n        \n        // Check for parent alignment changes first\n        const sourceParent = sourceElement.parentElement;\n        const targetParent = targetElement.parentElement;\n        \n        if (sourceParent && targetParent) {\n          const sourceParentStyle = window.getComputedStyle(sourceParent);\n          const targetParentStyle = window.getComputedStyle(targetParent);\n          \n          if (sourceParentStyle.justifyContent !== targetParentStyle.justifyContent ||\n              sourceParentStyle.alignItems !== targetParentStyle.alignItems) {\n            \n            changes.hasChanges = true;\n            changes.justifyContent = { \n              changed: sourceParentStyle.justifyContent !== targetParentStyle.justifyContent,\n              sourceValue: sourceParentStyle.justifyContent,\n              targetValue: targetParentStyle.justifyContent\n            };\n            changes.alignItems = { \n              changed: sourceParentStyle.alignItems !== targetParentStyle.alignItems,\n              sourceValue: sourceParentStyle.alignItems,\n              targetValue: targetParentStyle.alignItems\n            };\n            \n            // CRITICAL FIX: Don't return early - continue to check for individual element position changes\n            // This allows both parent alignment changes AND individual element position changes to be detected\n          }\n        }\n      } catch (error) {\n        console.log('Error in parent alignment check:', error);\n      }\n\n      try {\n        const sourceStyle = window.getComputedStyle(sourceElement);\n        const targetStyle = window.getComputedStyle(targetElement);\n        \n        // Check for parent alignment changes first\n        const sourceParent = sourceElement.parentElement;\n        const targetParent = targetElement.parentElement;\n        \n        // Use Figma coordinates directly for comparison\n        const sourceFigmaY = parseFloat(originalSourceElement.getAttribute('data-figma-y')) || 0;\n        const targetFigmaY = parseFloat(targetElement.getAttribute('data-figma-y')) || 0;\n        const sourceFigmaX = parseFloat(originalSourceElement.getAttribute('data-figma-x')) || 0;\n        const targetFigmaX = parseFloat(targetElement.getAttribute('data-figma-x')) || 0;\n        \n        const sourceRelativeLeft = sourceFigmaX;\n        const sourceRelativeTop = sourceFigmaY;\n        const targetRelativeLeft = targetFigmaX;\n        const targetRelativeTop = targetFigmaY;\n\n        console.log('\uD83D\uDD0D DEBUG: Position comparison for', targetElement.getAttribute('data-figma-name'), ':', {\n          sourceFigmaX,\n          sourceFigmaY,\n          targetFigmaX,\n          targetFigmaY,\n          xDifference: Math.abs(sourceFigmaX - targetFigmaX),\n          yDifference: Math.abs(sourceFigmaY - targetFigmaY),\n          shouldAnimateX: Math.abs(sourceRelativeLeft - targetRelativeLeft) > 1,\n          shouldAnimateY: Math.abs(sourceRelativeTop - targetRelativeTop) > 1\n        });\n        \n        // Check if the node has ignore auto layout enabled\n        const ignoreAutoLayout = sourceElement.getAttribute('data-layout-positioning') === 'ABSOLUTE';\n        \n        // Check if the node's parent has auto layout\n        const parentHasAutoLayout = sourceParent && targetParent && \n          sourceParent.getAttribute('data-layout-mode') && \n          sourceParent.getAttribute('data-layout-mode') !== 'NONE';\n        \n        // Determine if this node should be animated\n        let shouldAnimatePosition = false;\n        \n        if (Math.abs(sourceRelativeLeft - targetRelativeLeft) > 1 || Math.abs(sourceRelativeTop - targetRelativeTop) > 1) {\n          if (ignoreAutoLayout || !parentHasAutoLayout) {\n            shouldAnimatePosition = true;\n          } else {\n            shouldAnimatePosition = true;\n          }\n        }\n        \n        // Apply position changes if animation is needed\n        if (shouldAnimatePosition) {\n          if (Math.abs(sourceRelativeLeft - targetRelativeLeft) > 1) {\n            changes.positionX.changed = true;\n            changes.positionX.sourceValue = 0;\n            changes.positionX.targetValue = targetRelativeLeft - sourceRelativeLeft;\n            changes.hasChanges = true;\n          }\n          \n          if (Math.abs(sourceRelativeTop - targetRelativeTop) > 1) {\n            changes.positionY.changed = true;\n            changes.positionY.sourceValue = 0;\n            changes.positionY.targetValue = targetRelativeTop - sourceRelativeTop;\n            changes.hasChanges = true;\n          }\n        }\n\n        // Check style changes (non-position)\n        const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';\n        const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';\n        \n        if (sourceBg !== targetBg) {\n          changes.backgroundColor.changed = true;\n          changes.backgroundColor.sourceValue = sourceBg;\n          changes.backgroundColor.targetValue = targetBg;\n          changes.hasChanges = true;\n        }\n        \n        if (sourceStyle.color !== targetStyle.color) {\n          changes.color.changed = true;\n          changes.color.sourceValue = sourceStyle.color;\n          changes.color.targetValue = targetStyle.color;\n          changes.hasChanges = true;\n        }\n        \n        // Check alignment changes\n        if (sourceStyle.justifyContent !== targetStyle.justifyContent) {\n          changes.justifyContent.changed = true;\n          changes.justifyContent.sourceValue = sourceStyle.justifyContent;\n          changes.justifyContent.targetValue = targetStyle.justifyContent;\n          \n          if (shouldAnimatePosition) {\n            changes.hasChanges = true;\n          }\n        }\n        \n        if (sourceStyle.alignItems !== targetStyle.alignItems) {\n          changes.alignItems.changed = true;\n          changes.alignItems.sourceValue = sourceStyle.alignItems;\n          changes.alignItems.targetValue = targetStyle.alignItems;\n          \n          if (shouldAnimatePosition) {\n            changes.hasChanges = true;\n          }\n        }\n        \n      } catch (error) {\n        console.log('Error detecting property changes:', error);\n      }\n\n      return changes;\n    }\n    \n    /**\n     * Helper function to handle nested instance variant switch\n     */\n    function handleNestedInstanceVariantSwitch(element, changes) {\n      console.log('\uD83D\uDD04 Handling nested instance variant switch');\n      \n      const sourceComponentSet = element.querySelector('[data-figma-type=\"COMPONENT_SET\"]');\n      if (sourceComponentSet) {\n        // Hide current active variant\n        const currentActiveVariant = sourceComponentSet.querySelector('.variant-active');\n        if (currentActiveVariant) {\n          currentActiveVariant.classList.remove('variant-active');\n          currentActiveVariant.classList.add('variant-hidden');\n        }\n        \n        // Show target variant\n        const targetVariant = changes.targetVariant;\n        if (targetVariant) {\n          targetVariant.classList.add('variant-active');\n          targetVariant.classList.remove('variant-hidden');\n        }\n      }\n    }\n    \n    /**\n     * Helper function to convert changes to animation changes\n     */\n    function convertChangesToAnimationChanges(changes, element, originalSourceElement, destination) {\n      const animationChanges = [];\n      \n      console.log('\uD83C\uDFAD Converting changes to animation changes:', changes);\n      \n      // Handle position changes - use combined transform for simultaneous X and Y movement\n      const hasPositionX = changes.positionX && changes.positionX.changed;\n      const hasPositionY = changes.positionY && changes.positionY.changed;\n      \n      if (hasPositionX || hasPositionY) {\n        const translateX = hasPositionX ? changes.positionX.targetValue : 0;\n        const translateY = hasPositionY ? changes.positionY.targetValue : 0;\n        \n        animationChanges.push({\n          type: AnimationType.TRANSFORM,\n          property: 'translate',\n          sourceValue: { x: 0, y: 0 },\n          targetValue: { x: translateX, y: translateY },\n          changed: true,\n          translationCondition: TranslationCondition.ABSOLUTE,\n          isCombinedTransform: true\n        });\n      }\n      \n      // Handle color changes\n      if (changes.backgroundColor && changes.backgroundColor.changed) {\n        animationChanges.push({\n          type: AnimationType.SIMPLE,\n          property: 'backgroundColor',\n          sourceValue: changes.backgroundColor.sourceValue,\n          targetValue: changes.backgroundColor.targetValue,\n          changed: true\n        });\n      }\n      \n      if (changes.color && changes.color.changed) {\n        animationChanges.push({\n          type: AnimationType.SIMPLE,\n          property: 'color',\n          sourceValue: changes.color.sourceValue,\n          targetValue: changes.color.targetValue,\n          changed: true\n        });\n      }\n      \n      // Handle parent alignment changes - convert to transform-based animations\n      if (changes.justifyContent && changes.justifyContent.changed) {\n        // Convert justifyContent changes to transform-based animations\n        const justifyContentValue = changes.justifyContent.targetValue;\n        let translateX = 0;\n        \n        if (justifyContentValue === 'center') {\n          translateX = 0; // Already centered\n        } else if (justifyContentValue === 'flex-start') {\n          translateX = -50; // Move to start\n        } else if (justifyContentValue === 'flex-end') {\n          translateX = 50; // Move to end\n        }\n        \n        if (translateX !== 0) {\n          animationChanges.push({\n            type: AnimationType.TRANSFORM,\n            property: 'translateX',\n            sourceValue: 0,\n            targetValue: translateX,\n            changed: true,\n            translationCondition: TranslationCondition.ABSOLUTE\n          });\n        }\n      }\n      \n      if (changes.alignItems && changes.alignItems.changed) {\n        // Convert alignItems changes to transform-based animations using actual position differences\n        const alignItemsValue = changes.alignItems.targetValue;\n        const sourceAlignItems = changes.alignItems.sourceValue;\n        \n        console.log('\uD83D\uDD0D DEBUG: alignItems conversion:', {\n          sourceValue: sourceAlignItems,\n          targetValue: alignItemsValue\n        });\n        \n        // Get the actual position differences from Figma coordinates\n        const sourceFigmaY = parseFloat(originalSourceElement.getAttribute('data-figma-y')) || 0;\n        const targetFigmaY = parseFloat(element.getAttribute('data-figma-y')) || 0;\n        const yDifference = targetFigmaY - sourceFigmaY;\n        \n        console.log('\uD83D\uDD0D DEBUG: Position-based translateY calculation:', {\n          sourceFigmaY,\n          targetFigmaY,\n          yDifference\n        });\n        \n        // Use the actual position difference instead of hardcoded values\n        const translateY = yDifference;\n        \n        console.log('\uD83D\uDD0D DEBUG: Calculated translateY:', translateY);\n        \n        if (translateY !== 0) {\n          animationChanges.push({\n            type: AnimationType.TRANSFORM,\n            property: 'translateY',\n            sourceValue: 0,\n            targetValue: translateY,\n            changed: true,\n            translationCondition: TranslationCondition.ABSOLUTE\n          });\n        }\n      }\n      \n      console.log('\uD83C\uDFAD Created animation changes:', animationChanges);\n      return animationChanges;\n    }\n    \n    /**\n     * Helper function to apply animation changes\n     */\n    function applyAnimationChange(element, change, duration, easing) {\n      const { type, property, targetValue, translationCondition } = change;\n      \n      console.log('\uD83C\uDFAD Applying animation change:', { type, property, targetValue, translationCondition });\n      console.log('\uD83D\uDD0D DEBUG: Element initial transform:', window.getComputedStyle(element).transform);\n                    console.log('\uD83D\uDD0D DEBUG: Element initial position:', {\n                left: window.getComputedStyle(element).left,\n                top: window.getComputedStyle(element).top,\n                position: window.getComputedStyle(element).position\n              });\n              console.log('\uD83D\uDD0D DEBUG: Element initial display:', window.getComputedStyle(element).display);\n              console.log('\uD83D\uDD0D DEBUG: Element initial width/height:', {\n                width: window.getComputedStyle(element).width,\n                height: window.getComputedStyle(element).height\n              });\n      \n      // Get transition property\n      let transitionProperty = property;\n      if (type === AnimationType.TRANSFORM) {\n        if (translationCondition === TranslationCondition.ABSOLUTE) {\n          // CRITICAL FIX: Use 'transform' for all transform animations, not 'top' or 'left'\n          transitionProperty = 'transform';\n        } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n          transitionProperty = property.replace('parent_', '');\n        } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n          transitionProperty = property.replace('parent_', '');\n        }\n      }\n      \n      // Set up transition\n      element.style.transition = `${transitionProperty} ${duration}s ${easing}`;\n      \n      // Apply the change based on type and condition\n      switch (type) {\n        case AnimationType.SIMPLE:\n          element.style[property] = targetValue;\n          break;\n          \n        case AnimationType.SIZE:\n          element.style[property] = `${targetValue}px`;\n          break;\n          \n        case AnimationType.TRANSFORM:\n          if (translationCondition === TranslationCondition.ABSOLUTE) {\n            if (change.isCombinedTransform && property === 'translate') {\n              // Handle combined X and Y transform for simultaneous movement\n              const { x: translateX, y: translateY } = targetValue;\n              \n              // Use CSS transform for hardware-accelerated simultaneous animation\n              element.style.transition = `transform ${duration}s ${easing}`;\n              element.style.transform = `translate(${translateX}px, ${translateY}px)`;\n            } else if (property === 'translateX') {\n              // Get current transform state\n              const currentTransform = window.getComputedStyle(element).transform;\n              console.log('\uD83D\uDD0D DEBUG: Current transform before animation:', currentTransform);\n              \n              // Set initial state explicitly\n              element.style.transition = 'none'; // No transition for initial state\n              element.style.transform = 'translateX(0px)'; // Start at source position\n              \n              // Force a reflow to ensure initial state is applied\n              element.offsetHeight;\n              \n              // Verify initial state was applied\n              const initialTransform = window.getComputedStyle(element).transform;\n              console.log('\uD83D\uDD0D DEBUG: Initial transform after setting:', initialTransform);\n              \n              // Now animate to target state\n              element.style.transition = `transform ${duration}s ${easing}`;\n              element.style.transform = `translateX(${targetValue}px)`;\n              \n              // Force a reflow to ensure the animation starts\n              element.offsetHeight;\n              \n              // Verify target state was applied\n              const finalTransform = window.getComputedStyle(element).transform;\n              console.log('\uD83D\uDD0D DEBUG: Final transform after setting:', finalTransform);\n              console.log('\uD83D\uDD0D DEBUG: Expected transform should be: matrix(1, 0, 0, 1, ' + targetValue + ', 0)');\n              console.log('\uD83D\uDD0D DEBUG: Element.style.transform value:', element.style.transform);\n            } else if (property === 'translateY') {\n              // Use transform translateY with proper initial state\n              console.log('\uD83D\uDD0D DEBUG: Using transform translateY for animation');\n              \n              // Get current transform state\n              const currentTransform = window.getComputedStyle(element).transform;\n              console.log('\uD83D\uDD0D DEBUG: Current transform before animation:', currentTransform);\n              \n              // Set initial state explicitly with no transition\n              element.style.transition = 'none';\n              element.style.transform = 'translateY(0px)';\n              \n              // Force a reflow to ensure initial state is applied\n              element.offsetHeight;\n              \n              // Verify initial state was applied\n              const initialTransform = window.getComputedStyle(element).transform;\n              console.log('\uD83D\uDD0D DEBUG: Initial transform after setting:', initialTransform);\n              \n              // Now animate to target state immediately\n              element.style.transition = `transform ${duration}s ${easing}`;\n              element.style.transform = `translateY(${targetValue}px)`;\n              \n              // Force a reflow to ensure the animation starts\n              element.offsetHeight;\n              \n              // Verify target state was applied\n              const finalTransform = window.getComputedStyle(element).transform;\n              console.log('\uD83D\uDD0D DEBUG: Final transform after setting:', finalTransform);\n              console.log('\uD83D\uDD0D DEBUG: Expected transform should be: matrix(1, 0, 0, 1, 0, ' + targetValue + ')');\n              console.log('\uD83D\uDD0D DEBUG: Element.style.transform value:', element.style.transform);\n              console.log('\uD83D\uDD0D DEBUG: Element.style.transition value:', element.style.transition);\n            }\n          } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n            if (element.parentElement) {\n              const paddingProperty = property.replace('parent_', '');\n              element.parentElement.style[paddingProperty] = `${targetValue}px`;\n            }\n          } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n            if (property === 'alignTranslateX') {\n              element.style.left = `${targetValue}%`;\n            } else if (property === 'alignTranslateY') {\n              element.style.top = `${targetValue}%`;\n            } else if (property.startsWith('parent_')) {\n              if (element.parentElement) {\n                const alignmentProperty = property.replace('parent_', '');\n                element.parentElement.style[alignmentProperty] = targetValue;\n              }\n            } else {\n              element.style[property] = targetValue;\n            }\n          }\n          break;\n      }\n      \n      // Determine the actual transition property used\n      let actualTransitionProperty = transitionProperty;\n      if (type === AnimationType.TRANSFORM && translationCondition === TranslationCondition.ABSOLUTE) {\n        actualTransitionProperty = 'transform';\n      }\n      \n      console.log('\uD83C\uDFAD Applied change:', { property, transitionProperty: actualTransitionProperty, targetValue });\n      console.log('\uD83D\uDD0D DEBUG: Element computed style after change:');\n      console.log('  - transform:', window.getComputedStyle(element).transform);\n      console.log('  - transition:', window.getComputedStyle(element).transition);\n      console.log('  - display:', window.getComputedStyle(element).display);\n      console.log('  - position:', window.getComputedStyle(element).position);\n      console.log('  - left:', window.getComputedStyle(element).left);\n      console.log('  - top:', window.getComputedStyle(element).top);\n    }\n    \n    /**\n     * Helper function to get easing function\n     */\n    function getEasingFunction(animationType) {\n      switch (animationType) {\n        case 'EASE_IN_AND_OUT_BACK':\n          return 'cubic-bezier(0.68, -0.6, 0.32, 1.6)';\n        case 'EASE_IN_AND_OUT':\n          return 'ease-in-out';\n        case 'EASE_IN':\n          return 'ease-in';\n        case 'EASE_OUT':\n          return 'ease-out';\n        case 'LINEAR':\n          return 'linear';\n        case 'BOUNCY':\n          return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';\n        case 'GENTLE':\n          return 'ease-in-out';\n        case 'SMART_ANIMATE':\n          return 'ease-in-out';\n        default:\n          return 'ease-out';\n      }\n    }\n    \n    /**\n     * Main reaction handler function - entry point for all reactions\n     */\n    function handleReaction(sourceElement, destinationId, transitionType, transitionDuration) {\n      console.log('\uD83C\uDFAF REACTION TRIGGERED:', {\n        sourceId: sourceElement.getAttribute('data-figma-id'),\n        sourceName: sourceElement.getAttribute('data-figma-name'),\n        destinationId: destinationId,\n        transitionType: transitionType,\n        transitionDuration: transitionDuration\n      });\n      \n      // Check if transition is already in progress\n      if (isTransitionInProgress) {\n        console.log('\u274C Transition already in progress, skipping reaction');\n        return;\n      }\n      \n      // Find the destination element\n      const destination = document.querySelector('[data-figma-id=\"' + destinationId + '\"]');\n      if (!destination) {\n        console.error('\u274C Destination element not found:', destinationId);\n        return;\n      }\n      \n      // Find all variants in the same component set\n      const componentSet = sourceElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n      if (!componentSet) {\n        console.error('\u274C Component set not found for source element');\n        return;\n      }\n      \n      const allVariants = Array.from(componentSet.children).filter(child => \n        child.getAttribute('data-figma-type') === 'COMPONENT'\n      );\n      \n      console.log('\uD83C\uDFAF Found', allVariants.length, 'variants in component set');\n      \n      // Determine if we should animate or perform instant switch\n      if (transitionType && transitionType !== 'INSTANT' && transitionDuration && parseFloat(transitionDuration) > 0) {\n        // Use animated variant switch\n        console.log('\uD83C\uDFAD Using animated variant switch');\n        handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration);\n      } else {\n        // Use instant variant switch\n        console.log('\u26A1 Using instant variant switch');\n        performInstantVariantSwitch(allVariants, destination);\n      }\n    }\n    \n    /**\n     * Main function to handle animated variant switching using the three-phase system\n     */\n    async function handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration) {\n      console.log('\uD83D\uDD04 THREE-PHASE VARIANT SWITCH START:', {\n        sourceId: sourceElement.getAttribute('data-figma-id'),\n        sourceName: sourceElement.getAttribute('data-figma-name'),\n        destinationId: destination.getAttribute('data-figma-id'),\n        destinationName: destination.getAttribute('data-figma-name'),\n        transitionType: transitionType,\n        transitionDuration: transitionDuration,\n        totalVariants: allVariants.length\n      });\n      \n      // Check if transition is already in progress\n      if (isTransitionInProgress) {\n        console.log('\u274C Transition already in progress, skipping');\n        return;\n      }\n      \n      isTransitionInProgress = true;\n      \n      try {\n        // PHASE 1: SETUP\n        const session = setupAnimationSession(sourceElement, destination, allVariants, transitionType, transitionDuration);\n        currentAnimationSession = session;\n        \n        // PHASE 2: ANIMATE\n        await animateVariantTransition(session);\n        \n        // PHASE 3: CLEANUP\n        cleanupAnimationSession(session);\n        \n        // Start timeout reactions for the new active variant\n        if (window.startTimeoutReactionsForNewlyActiveVariant) {\n          window.startTimeoutReactionsForNewlyActiveVariant(destination);\n        }\n        if (window.startTimeoutReactionsForNestedComponents) {\n          window.startTimeoutReactionsForNestedComponents(destination);\n        }\n        \n        console.log('\u2705 THREE-PHASE VARIANT SWITCH COMPLETED');\n        \n      } catch (error) {\n        console.error('\u274C Error during three-phase variant switch:', error);\n        \n        // Cleanup on error\n        if (currentAnimationSession) {\n          cleanupAnimationSession(currentAnimationSession);\n        }\n      } finally {\n        isTransitionInProgress = false;\n        currentAnimationSession = null;\n      }\n    }\n    \n    /**\n     * Function to perform instant variant switch (no animation)\n     */\n    function performInstantVariantSwitch(allVariants, destination) {\n      console.log('\u26A1 PERFORMING INSTANT VARIANT SWITCH');\n      \n      // Hide all variants - only use display\n      allVariants.forEach(variant => {\n        variant.classList.add('variant-hidden');\n        variant.classList.remove('variant-active');\n        variant.style.display = 'none';\n        if (!variant.style.position || variant.style.position === 'static') {\n          variant.style.position = 'relative';\n        }\n      });\n      \n      // Show destination variant - only use display\n      destination.classList.add('variant-active');\n      destination.classList.remove('variant-hidden');\n      destination.style.display = 'flex';\n      if (!destination.style.position || destination.style.position === 'static') {\n        destination.style.position = 'relative';\n      }\n      \n      console.log('\u2705 INSTANT VARIANT SWITCH COMPLETED');\n      \n      // Start timeout reactions\n      if (window.startTimeoutReactionsForNewlyActiveVariant) {\n        window.startTimeoutReactionsForNewlyActiveVariant(destination);\n      }\n      if (window.startTimeoutReactionsForNestedComponents) {\n        window.startTimeoutReactionsForNestedComponents(destination);\n      }\n    }\n    \n    // Export the main functions for external use\n    window.handleReaction = handleReaction;\n    window.handleAnimatedVariantSwitch = handleAnimatedVariantSwitch;\n    window.performInstantVariantSwitch = performInstantVariantSwitch;\n    \n    console.log('\u2705 Three-phase transition handler loaded');\n  ";
}


/***/ }),

/***/ 275:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateReactionAttributes = generateReactionAttributes;
exports.generateVariantAttributes = generateVariantAttributes;
var utils_1 = __webpack_require__(489);
// Event attribute generation
function generateReactionAttributes(node) {
    var attributes = {};
    if ((0, utils_1.safeHasProperty)(node, 'reactions') && node.reactions && node.reactions.length > 0) {
        var reactions = node.reactions;
        var firstReaction = reactions[0];
        if (firstReaction) {
            attributes['data-has-reactions'] = 'true';
            attributes['data-reaction-count'] = String(reactions.length);
            if (firstReaction.trigger) {
                attributes['data-reaction-trigger'] = (0, utils_1.escapeHtmlAttribute)(JSON.stringify(firstReaction.trigger));
            }
            // Check both action and actions fields
            var actionToUse = null;
            if (firstReaction.action) {
                actionToUse = firstReaction.action;
            }
            else if (firstReaction.actions && firstReaction.actions.length > 0) {
                actionToUse = firstReaction.actions[0];
            }
            if (actionToUse && actionToUse.type) {
                attributes['data-reaction-action-type'] = actionToUse.type;
                if (actionToUse.destinationId) {
                    attributes['data-reaction-destination'] = actionToUse.destinationId;
                }
                // Extract transition data from the action
                if (actionToUse.transition && actionToUse.transition.type) {
                    // Use the easing type from the transition if available, otherwise use the transition type
                    var transitionType = actionToUse.transition.type;
                    if (actionToUse.transition.easing && actionToUse.transition.easing.type) {
                        var easingType = actionToUse.transition.easing.type;
                        // Preserve the original easing type instead of mapping to BOUNCY
                        transitionType = easingType;
                    }
                    attributes['data-reaction-transition-type'] = transitionType;
                    if (actionToUse.transition.duration) {
                        attributes['data-reaction-transition-duration'] = String(actionToUse.transition.duration);
                    }
                }
                else if (actionToUse.transition === null) {
                    // Handle instant transitions (no animation)
                    attributes['data-reaction-transition-type'] = 'INSTANT';
                    attributes['data-reaction-transition-duration'] = '0';
                }
            }
        }
    }
    return attributes;
}
function generateVariantAttributes(node, parentNode) {
    var attributes = {};
    if ((0, utils_1.safeHasProperty)(node, 'variantProperties') && node.variantProperties) {
        var variantProps = node.variantProperties;
        Object.entries(variantProps).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            var cleanKey = key.toLowerCase().replace(/\s+/g, '-');
            attributes["data-variant-".concat(cleanKey)] = (0, utils_1.escapeHtmlAttribute)((0, utils_1.safeToString)(value));
        });
        // Add data-target attribute to point to the immediate parent component set
        // This allows variant buttons to know which component set to target for switching
        // For nested components, this will point to their immediate parent, not the top-level
        if (parentNode && (parentNode.type === 'COMPONENT_SET' || parentNode.type === 'COMPONENT')) {
            attributes['data-target'] = parentNode.id;
        }
    }
    return attributes;
}


/***/ }),

/***/ 332:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReactionHandler = createReactionHandler;
exports.createTimeoutHandler = createTimeoutHandler;
// Reaction handling and timeout management
function createReactionHandler() {
    return "\n      // Handle reactions - click, press, and drag\n      const reactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n      reactionElements.forEach(element => {\n        const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n        const actionType = element.getAttribute('data-reaction-action-type');\n        const destinationId = element.getAttribute('data-reaction-destination');\n        const transitionType = element.getAttribute('data-reaction-transition-type');\n        const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n        \n        // Handle click, press, and drag reactions\n        element.addEventListener('click', function() {\n          console.log('DEBUG: Click event triggered on element:', {\n            id: this.getAttribute('data-figma-id'),\n            name: this.getAttribute('data-figma-name'),\n            type: this.getAttribute('data-figma-type'),\n            trigger: trigger,\n            actionType: actionType,\n            destinationId: destinationId,\n            transitionType: transitionType,\n            transitionDuration: transitionDuration\n          });\n          \n          if (trigger.type === 'ON_CLICK' || trigger.type === 'ON_PRESS') {\n            console.log('DEBUG: Processing click reaction for element:', this.getAttribute('data-figma-id'));\n            handleReaction(this, destinationId, transitionType, transitionDuration);\n          }\n        });\n        \n        // Handle drag reactions\n        element.addEventListener('mousedown', function() {\n          if (trigger.type === 'ON_DRAG') {\n            handleReaction(this, destinationId, transitionType, transitionDuration);\n          }\n        });\n      });\n  ";
}
function createTimeoutHandler() {
    return "\n      // Track which variants have active timers (for preventing duplicate timers during the same activation)\n      const activeTimers = new Map(); // elementId -> timeoutId\n      \n      // Function to start timeout reactions for active variants\n      function startTimeoutReactionsForActiveVariants() {\n        // Look for both variant-active elements with reactions AND any elements with reactions that don't have variant properties\n        const activeVariants = document.querySelectorAll('.variant-active[data-has-reactions=\"true\"]');\n        const reactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n        \n        console.log('DEBUG: Found', activeVariants.length, 'active variants with reactions');\n        console.log('DEBUG: Found', reactionElements.length, 'total elements with reactions');\n        \n        // Process active variants first\n        activeVariants.forEach(element => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          const parentComponent = element.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n          \n          console.log('DEBUG: Processing variant:', elementId, 'name:', elementName, 'parent:', parentName);\n          \n          // Only start timers for variants that are actually visible (not hidden by CSS)\n          const computedStyle = window.getComputedStyle(element);\n          \n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n            const actionType = element.getAttribute('data-reaction-action-type');\n            const destinationId = element.getAttribute('data-reaction-destination');\n            const transitionType = element.getAttribute('data-reaction-transition-type');\n            const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n            \n            // Handle timeout reactions only for active variants that don't have an active timer\n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId); // Clear the timer when it completes\n                handleReaction(element, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n          }\n        });\n        \n        // Also process any reaction elements that don't have variant properties (like 6461:693)\n        reactionElements.forEach(element => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          \n          // Skip if this element was already processed as a variant\n          if (element.classList.contains('variant-active')) {\n            return;\n          }\n          \n          // Skip if this element has variant properties (it will be handled by variant logic)\n          if (element.hasAttribute('data-variant-property-1')) {\n            return;\n          }\n          \n          const parentComponent = element.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n          \n          console.log('DEBUG: Processing non-variant reaction element:', elementId, 'name:', elementName, 'parent:', parentName);\n          \n          // Only start timers for elements that are actually visible (not hidden by CSS)\n          const computedStyle = window.getComputedStyle(element);\n          \n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n            const actionType = element.getAttribute('data-reaction-action-type');\n            const destinationId = element.getAttribute('data-reaction-destination');\n            const transitionType = element.getAttribute('data-reaction-transition-type');\n            const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n            \n            // Handle timeout reactions only for elements that don't have an active timer\n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId); // Clear the timer when it completes\n                handleReaction(element, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n          }\n        });\n      }\n      \n      // Function to start timeout reactions for nested components when their parent becomes visible\n      function startTimeoutReactionsForNestedComponents(parentElement) {\n        if (!parentElement) return;\n        \n        // Find all nested components with timeout reactions within the parent\n        const nestedComponents = parentElement.querySelectorAll('[data-has-reactions=\"true\"][data-reaction-trigger*=\"AFTER_TIMEOUT\"]');\n        \n        nestedComponents.forEach(component => {\n          const elementId = component.getAttribute('data-figma-id');\n          const elementName = component.getAttribute('data-figma-name');\n          const parentComponent = component.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n          \n          console.log('DEBUG: Processing nested component:', elementId, 'name:', elementName, 'parent:', parentName);\n          \n          // Only start timers for nested components that are actually visible\n          const computedStyle = window.getComputedStyle(component);\n          \n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(component.getAttribute('data-reaction-trigger') || '{}');\n            \n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId);\n                const actionType = component.getAttribute('data-reaction-action-type');\n                const destinationId = component.getAttribute('data-reaction-destination');\n                const transitionType = component.getAttribute('data-reaction-transition-type');\n                const transitionDuration = component.getAttribute('data-reaction-transition-duration');\n                handleReaction(component, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');\n          }\n        });\n      }\n      \n      // Function to start timeout reactions for a specific newly active variant\n      function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {\n        if (!newlyActiveElement) return;\n        \n        const elementId = newlyActiveElement.getAttribute('data-figma-id');\n        const elementName = newlyActiveElement.getAttribute('data-figma-name');\n        const parentComponent = newlyActiveElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n        const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n        \n        console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);\n        \n        // Only start timers for variants that are actually visible (not hidden by CSS)\n        const computedStyle = window.getComputedStyle(newlyActiveElement);\n        \n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');\n          const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');\n          const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');\n          const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');\n          const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');\n          \n          // Handle timeout reactions only for active variants that don't have an active timer\n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId); // Clear the timer when it completes\n              handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n          } else if (activeTimers.has(elementId)) {\n            console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');\n          }\n          \n          // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant\n          startTimeoutReactionsForNestedComponents(newlyActiveElement);\n        } else {\n          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n        }\n      }\n      \n      // CRITICAL FIX: Only start timeout reactions for the initial visible variant\n      // Instead of starting timers for all variant-active elements immediately,\n      // we wait for the first variant transition or user interaction\n      function startTimeoutReactionsForInitialVariant() {\n        // Find the first visible variant that should start the flow\n        // This is typically the first variant in a component set that's marked as active\n        const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"]');\n        console.log('DEBUG: Found', componentSets.length, 'component sets');\n        \n        // Also check for any elements with reactions\n        const allReactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n        console.log('DEBUG: Found', allReactionElements.length, 'total elements with reactions');\n        \n        // Log details about reaction elements\n        allReactionElements.forEach((element, index) => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n          const computedStyle = window.getComputedStyle(element);\n          \n          console.log('DEBUG: Reaction element', index + 1, ':', {\n            id: elementId,\n            name: elementName,\n            trigger: trigger,\n            display: computedStyle.display,\n            visibility: computedStyle.visibility,\n            isActive: element.classList.contains('variant-active'),\n            isHidden: element.classList.contains('variant-hidden')\n          });\n        });\n        \n        componentSets.forEach(componentSet => {\n          const componentSetName = componentSet.getAttribute('data-figma-name');\n          const activeVariants = componentSet.querySelectorAll('.variant-active[data-has-reactions=\"true\"]');\n          console.log('DEBUG: Component set', componentSetName, 'has', activeVariants.length, 'active variants with reactions');\n          \n          // Only start timers for the first active variant in each component set\n          if (activeVariants.length > 0) {\n            const firstActiveVariant = activeVariants[0];\n            const elementId = firstActiveVariant.getAttribute('data-figma-id');\n            const elementName = firstActiveVariant.getAttribute('data-figma-name');\n            const computedStyle = window.getComputedStyle(firstActiveVariant);\n            \n            console.log('DEBUG: Processing initial variant:', elementId, 'name:', elementName, 'in component set:', componentSetName);\n            \n            // Only start timer if the variant is actually visible\n            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n              const trigger = JSON.parse(firstActiveVariant.getAttribute('data-reaction-trigger') || '{}');\n              \n              // Skip nested components that should only start when their parent becomes visible\n              // Allow independent components to start their timers on page load\n              // Check if this component set is nested within another component set\n              const parentComponentSet = componentSet.closest('[data-figma-type=\"COMPONENT_SET\"]');\n              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;\n              \n              if (isNestedComponent) {\n                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');\n                return;\n              }\n              \n              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n                console.log('DEBUG: Starting initial timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);\n                const timeoutId = setTimeout(() => {\n                  console.log('DEBUG: Timeout triggered for element:', elementId, 'name:', elementName);\n                  activeTimers.delete(elementId);\n                  const actionType = firstActiveVariant.getAttribute('data-reaction-action-type');\n                  const destinationId = firstActiveVariant.getAttribute('data-reaction-destination');\n                  const transitionType = firstActiveVariant.getAttribute('data-reaction-transition-type');\n                  const transitionDuration = firstActiveVariant.getAttribute('data-reaction-transition-duration');\n                  console.log('DEBUG: Calling handleReaction with:', {\n                    destinationId: destinationId,\n                    transitionType: transitionType,\n                    transitionDuration: transitionDuration\n                  });\n                  handleReaction(firstActiveVariant, destinationId, transitionType, transitionDuration);\n                }, (trigger.timeout || 0) * 1000);\n                activeTimers.set(elementId, timeoutId);\n                console.log('DEBUG: Created timeout timer for element:', elementId, 'timeout ID:', timeoutId, 'duration:', (trigger.timeout || 0) * 1000, 'ms');\n                \n                // CRITICAL FIX: Also start timeout reactions for any nested components within this initial variant\n                startTimeoutReactionsForNestedComponents(firstActiveVariant);\n              } else {\n                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n              }\n            } else {\n              console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n            }\n          }\n          \n          // CRITICAL FIX: Also check for non-variant reaction elements in this component set\n          const reactionElements = componentSet.querySelectorAll('[data-has-reactions=\"true\"]');\n          reactionElements.forEach(element => {\n            const elementId = element.getAttribute('data-figma-id');\n            const elementName = element.getAttribute('data-figma-name');\n            \n            // Skip if this element was already processed as a variant\n            if (element.classList.contains('variant-active')) {\n              return;\n            }\n            \n            // Skip if this element has variant properties (it will be handled by variant logic)\n            if (element.hasAttribute('data-variant-property-1')) {\n              return;\n            }\n            \n            const computedStyle = window.getComputedStyle(element);\n            \n            console.log('DEBUG: Processing initial non-variant reaction element:', elementId, 'name:', elementName, 'in component set:', componentSetName);\n            \n            // Only start timer if the element is actually visible\n            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n              const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n              \n              // Skip nested components that should only start when their parent becomes visible\n              const parentComponentSet = componentSet.closest('[data-figma-type=\"COMPONENT_SET\"]');\n              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;\n              \n              if (isNestedComponent) {\n                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');\n                return;\n              }\n              \n              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n                console.log('DEBUG: Starting initial timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);\n                const timeoutId = setTimeout(() => {\n                  activeTimers.delete(elementId);\n                  const actionType = element.getAttribute('data-reaction-action-type');\n                  const destinationId = element.getAttribute('data-reaction-destination');\n                  const transitionType = element.getAttribute('data-reaction-transition-type');\n                  const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n                  handleReaction(element, destinationId, transitionType, transitionDuration);\n                }, (trigger.timeout || 0) * 1000);\n                activeTimers.set(elementId, timeoutId);\n                \n                // Also start timeout reactions for any nested components within this element\n                startTimeoutReactionsForNestedComponents(element);\n              } else {\n                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n              }\n            } else {\n              console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n            }\n          });\n        });\n      }\n      \n      // Start timeout reactions for the initial visible variant after a short delay\n      // to ensure CSS classes and visibility are properly applied\n      console.log('DEBUG: Setting up initial timeout reactions');\n      setTimeout(() => {\n        console.log('DEBUG: Starting initial timeout reactions');\n        startTimeoutReactionsForInitialVariant();\n      }, 100);\n  ";
}


/***/ }),

/***/ 489:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.safeHasProperty = safeHasProperty;
exports.safeToString = safeToString;
exports.safeAttributeValue = safeAttributeValue;
exports.escapeHtmlAttribute = escapeHtmlAttribute;
// Utility functions for HTML generation
function safeHasProperty(obj, prop) {
    return obj && typeof obj === 'object' && prop in obj;
}
function safeToString(value) {
    if (value === null || value === undefined)
        return '';
    if (typeof value === 'symbol')
        return value.toString();
    return String(value);
}
// Helper function to safely convert any value to string for HTML attributes, handling symbols
function safeAttributeValue(value) {
    if (value === null || value === undefined)
        return '';
    if (typeof value === 'symbol')
        return value.toString();
    return String(value);
}
function escapeHtmlAttribute(value) {
    return value
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}


/***/ }),

/***/ 821:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createModularSmartAnimateHandler = createModularSmartAnimateHandler;
/**
 * Creates a modular smart animate handler that uses the new animation system
 */
function createModularSmartAnimateHandler() {
    return "\n      // Global transition lock to prevent multiple simultaneous transitions\n      let isTransitionInProgress = false;\n      let currentTransitionPromise = null;\n      \n      // Animation types\n      const AnimationType = {\n        SIMPLE: 'SIMPLE',\n        SIZE: 'SIZE', \n        TRANSFORM: 'TRANSFORM'\n      };\n      \n      // Translation conditions\n      const TranslationCondition = {\n        ABSOLUTE: 'ABSOLUTE',\n        RELATIVE_PADDING: 'RELATIVE_PADDING',\n        RELATIVE_ALIGNMENT: 'RELATIVE_ALIGNMENT'\n      };\n      \n      // Helper function to determine animation type for a property\n      function getAnimationType(property) {\n        const simpleProperties = [\n          'opacity', 'color', 'backgroundColor', 'cornerRadius', 'borderRadius',\n          'fontSize', 'fontWeight', 'textAlign', 'letterSpacing', 'lineHeight'\n        ];\n        \n        const sizeProperties = [\n          'width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'\n        ];\n        \n        const transformProperties = [\n          'translateX', 'translateY', 'translateZ', 'rotation', 'scale', 'transform'\n        ];\n        \n        if (simpleProperties.includes(property)) {\n          return AnimationType.SIMPLE;\n        } else if (sizeProperties.includes(property)) {\n          return AnimationType.SIZE;\n        } else if (transformProperties.includes(property)) {\n          return AnimationType.TRANSFORM;\n        }\n        \n        return AnimationType.SIMPLE;\n      }\n      \n      // Helper function to determine translation condition\n      function getTranslationCondition(element, node, parentNode) {\n        const ignoreAutoLayout = node.layoutPositioning === 'ABSOLUTE';\n        \n        const parentHasAutoLayout = parentNode && \n                                   parentNode.type === 'FRAME' && \n                                   parentNode.layoutMode && \n                                   parentNode.layoutMode !== 'NONE';\n        \n        if (ignoreAutoLayout || !parentHasAutoLayout) {\n          return TranslationCondition.ABSOLUTE;\n        }\n        \n        if (parentHasAutoLayout) {\n          // For now, default to padding-based relative positioning\n          // This could be enhanced to detect which type of relative positioning is needed\n          return TranslationCondition.RELATIVE_PADDING;\n        }\n        \n        return TranslationCondition.ABSOLUTE;\n      }\n      \n      // Helper function to detect animation changes\n      function detectAnimationChanges(sourceElement, targetElement, sourceNode, targetNode, parentNode) {\n        const changes = [];\n        \n        const sourceStyle = window.getComputedStyle(sourceElement);\n        const targetStyle = window.getComputedStyle(targetElement);\n        \n        // Check simple properties\n        const simpleProperties = ['opacity', 'backgroundColor', 'color'];\n        simpleProperties.forEach(property => {\n          const sourceValue = sourceStyle[property];\n          const targetValue = targetStyle[property];\n          \n          if (sourceValue !== targetValue) {\n            changes.push({\n              type: AnimationType.SIMPLE,\n              property,\n              sourceValue,\n              targetValue,\n              changed: true\n            });\n          }\n        });\n        \n        // Check size properties\n        const sizeProperties = ['width', 'height'];\n        sizeProperties.forEach(property => {\n          const sourceValue = parseFloat(sourceStyle[property]) || 0;\n          const targetValue = parseFloat(targetStyle[property]) || 0;\n          \n          if (Math.abs(sourceValue - targetValue) > 1) {\n            changes.push({\n              type: AnimationType.SIZE,\n              property,\n              sourceValue,\n              targetValue,\n              changed: true\n            });\n          }\n        });\n        \n        // Check transform properties based on translation condition\n        const translationCondition = getTranslationCondition(sourceElement, sourceNode, parentNode);\n        \n        console.log('DEBUG: Translation condition detected:', translationCondition);\n        \n        if (translationCondition === TranslationCondition.ABSOLUTE) {\n          // Check left/top changes for absolute positioning\n          const sourceLeft = parseFloat(sourceStyle.left) || 0;\n          const targetLeft = parseFloat(targetStyle.left) || 0;\n          const sourceTop = parseFloat(sourceStyle.top) || 0;\n          const targetTop = parseFloat(targetStyle.top) || 0;\n          \n          if (Math.abs(sourceLeft - targetLeft) > 1) {\n            changes.push({\n              type: AnimationType.TRANSFORM,\n              property: 'translateX',\n              sourceValue: sourceLeft,\n              targetValue: targetLeft,\n              changed: true,\n              translationCondition\n            });\n          }\n          \n          if (Math.abs(sourceTop - targetTop) > 1) {\n            changes.push({\n              type: AnimationType.TRANSFORM,\n              property: 'translateY',\n              sourceValue: sourceTop,\n              targetValue: targetTop,\n              changed: true,\n              translationCondition\n            });\n          }\n        } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n          // Check parent padding changes\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          \n          if (sourceParent && targetParent) {\n            const sourceParentStyle = window.getComputedStyle(sourceParent);\n            const targetParentStyle = window.getComputedStyle(targetParent);\n            \n            const paddingProperties = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'];\n            paddingProperties.forEach(property => {\n              const sourceValue = parseFloat(sourceParentStyle[property]) || 0;\n              const targetValue = parseFloat(targetParentStyle[property]) || 0;\n              \n              if (Math.abs(sourceValue - targetValue) > 1) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: `parent_${property}`,\n                  sourceValue,\n                  targetValue,\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n          }\n        } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n          // Check parent alignment changes - ENHANCED FOR JUSTIFYCONTENT\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          \n          if (sourceParent && targetParent) {\n            const sourceParentStyle = window.getComputedStyle(sourceParent);\n            const targetParentStyle = window.getComputedStyle(targetParent);\n            \n            // Check alignment properties with detailed logging\n            const alignmentProperties = ['justifyContent', 'alignItems', 'textAlign', 'verticalAlign'];\n            \n            console.log('DEBUG: Checking alignment properties for RELATIVE_ALIGNMENT');\n            \n            alignmentProperties.forEach(property => {\n              const sourceValue = sourceParentStyle[property];\n              const targetValue = targetParentStyle[property];\n              \n              console.log(`DEBUG: Parent ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });\n              \n              if (sourceValue !== targetValue) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: `parent_${property}`,\n                  sourceValue: sourceValue || '',\n                  targetValue: targetValue || '',\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n            \n            // Check element's own alignment properties\n            alignmentProperties.forEach(property => {\n              const sourceValue = sourceStyle[property];\n              const targetValue = targetStyle[property];\n              \n              console.log(`DEBUG: Element ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });\n              \n              if (sourceValue !== targetValue) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: property,\n                  sourceValue: sourceValue || '',\n                  targetValue: targetValue || '',\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n            \n            // Check for flexbox-specific properties\n            const flexProperties = ['flexDirection', 'flexWrap', 'alignContent', 'justifyItems'];\n            flexProperties.forEach(property => {\n              const sourceValue = sourceParentStyle[property];\n              const targetValue = targetParentStyle[property];\n              \n              console.log(`DEBUG: Flex ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });\n              \n              if (sourceValue !== targetValue) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: `parent_${property}`,\n                  sourceValue: sourceValue || '',\n                  targetValue: targetValue || '',\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n            \n            // Check for position changes that might be due to alignment\n            // Even if alignment values are the same, the computed position might differ\n            const sourceRect = sourceElement.getBoundingClientRect();\n            const targetRect = targetElement.getBoundingClientRect();\n            const sourceParentRect = sourceParent.getBoundingClientRect();\n            const targetParentRect = targetParent.getBoundingClientRect();\n            \n            // Calculate relative positions within their containers\n            const sourceRelativeX = sourceRect.left - sourceParentRect.left;\n            const targetRelativeX = targetRect.left - targetParentRect.left;\n            const sourceRelativeY = sourceRect.top - sourceParentRect.top;\n            const targetRelativeY = targetRect.top - targetParentRect.top;\n            \n            console.log('DEBUG: Relative position analysis:', {\n              sourceRelativeX,\n              targetRelativeX,\n              sourceRelativeY,\n              targetRelativeY,\n              xDifference: Math.abs(sourceRelativeX - targetRelativeX),\n              yDifference: Math.abs(sourceRelativeY - targetRelativeY)\n            });\n            \n            // If there's a significant position difference, it might be due to alignment\n            if (Math.abs(sourceRelativeX - targetRelativeX) > 1) {\n              changes.push({\n                type: AnimationType.TRANSFORM,\n                property: 'alignTranslateX',\n                sourceValue: sourceRelativeX,\n                targetValue: targetRelativeX,\n                changed: true,\n                translationCondition\n              });\n            }\n            \n            if (Math.abs(sourceRelativeY - targetRelativeY) > 1) {\n              changes.push({\n                type: AnimationType.TRANSFORM,\n                property: 'alignTranslateY',\n                sourceValue: sourceRelativeY,\n                targetValue: targetRelativeY,\n                changed: true,\n                translationCondition\n              });\n            }\n          }\n        }\n        \n        console.log('DEBUG: Total changes detected:', changes.length, changes);\n        return changes;\n      }\n      \n      // Helper function to apply animation changes\n      function applyAnimationChange(element, change, duration, easing) {\n        const { type, property, targetValue, translationCondition, destination } = change;\n        \n        console.log('DEBUG: Applying animation change:', { type, property, targetValue, translationCondition });\n        \n        // Get transition property\n        let transitionProperty = property;\n        if (type === AnimationType.TRANSFORM) {\n          if (translationCondition === TranslationCondition.ABSOLUTE) {\n            transitionProperty = property === 'translateX' ? 'left' : 'top';\n          } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n            transitionProperty = property.replace('parent_', '');\n          } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n            if (property === 'alignTranslateX' || property === 'alignTranslateY') {\n              transitionProperty = property === 'alignTranslateX' ? 'left' : 'top';\n            } else if (property.startsWith('parent_')) {\n              // For alignment changes, animate the element's position instead of the parent's alignment\n              if (property === 'parent_justifyContent') {\n                // Use the target element's actual position from the destination variant\n                const sourceElementName = element.getAttribute('data-figma-name');\n                const targetElement = destination.querySelector(`[data-figma-name=\"${sourceElementName}\"]`);\n                \n                if (targetElement) {\n                  const targetRect = targetElement.getBoundingClientRect();\n                  const parent = element.parentElement;\n                  const parentRect = parent.getBoundingClientRect();\n                  \n                  // Calculate the target position relative to the parent\n                  const targetLeft = targetRect.left - parentRect.left;\n                  \n                  console.log('DEBUG: Calculating justifyContent animation using target position:', {\n                    currentLeft: element.getBoundingClientRect().left - parentRect.left,\n                    targetLeft: targetLeft,\n                    targetElementId: targetElement.getAttribute('data-figma-id'),\n                    targetElementName: sourceElementName,\n                    justifyContent: targetValue\n                  });\n                  \n                  // Set transition for left position\n                  element.style.transition = `left ${duration}s ${easing}`;\n                  element.style.left = `${targetLeft}px`;\n                  \n                  console.log('DEBUG: Applied justifyContent animation via target position:', {\n                    property: 'left',\n                    transitionProperty: 'left',\n                    targetValue: `${targetLeft}px`\n                  });\n                  \n                  return; // Skip the default handling\n                } else {\n                  console.log('DEBUG: Target element not found in destination by name:', sourceElementName);\n                }\n              } else if (property === 'parent_alignItems') {\n                // Use the target element's actual position from the destination variant\n                const sourceElementName = element.getAttribute('data-figma-name');\n                const targetElement = destination.querySelector(`[data-figma-name=\"${sourceElementName}\"]`);\n                \n                if (targetElement) {\n                  const targetRect = targetElement.getBoundingClientRect();\n                  const parent = element.parentElement;\n                  const parentRect = parent.getBoundingClientRect();\n                  \n                  // Calculate the target position relative to the parent\n                  const targetTop = targetRect.top - parentRect.top;\n                  \n                  console.log('DEBUG: Calculating alignItems animation using target position:', {\n                    currentTop: element.getBoundingClientRect().top - parentRect.top,\n                    targetTop: targetTop,\n                    targetElementId: targetElement.getAttribute('data-figma-id'),\n                    targetElementName: sourceElementName,\n                    alignItems: targetValue\n                  });\n                  \n                  // Set transition for top position\n                  element.style.transition = `top ${duration}s ${easing}`;\n                  element.style.top = `${targetTop}px`;\n                  \n                  console.log('DEBUG: Applied alignItems animation via target position:', {\n                    property: 'top',\n                    transitionProperty: 'top',\n                    targetValue: `${targetTop}px`\n                  });\n                  \n                  return; // Skip the default handling\n                } else {\n                  console.log('DEBUG: Target element not found in destination by name:', sourceElementName);\n                }\n              }\n              transitionProperty = property.replace('parent_', '');\n            } else {\n              transitionProperty = property;\n            }\n          }\n        }\n        \n        // Set up transition\n        element.style.transition = `${transitionProperty} ${duration}s ${easing}`;\n        \n        // Apply the change based on type and condition\n        switch (type) {\n          case AnimationType.SIMPLE:\n            element.style[property] = targetValue;\n            break;\n            \n          case AnimationType.SIZE:\n            element.style[property] = `${targetValue}px`;\n            break;\n            \n          case AnimationType.TRANSFORM:\n            if (translationCondition === TranslationCondition.ABSOLUTE) {\n              if (change.isCombinedTransform && property === 'translate') {\n                // Handle combined X and Y transform for simultaneous movement\n                const { x: translateX, y: translateY } = targetValue;\n                \n                // Use CSS transform for hardware-accelerated simultaneous animation\n                element.style.transition = `transform ${duration}s ${easing}`;\n                element.style.transform = `translate(${translateX}px, ${translateY}px)`;\n                \n                console.log('DEBUG: Applying combined transform animation:', {\n                  translateX: translateX,\n                  translateY: translateY,\n                  elementName: element.getAttribute('data-figma-name')\n                });\n              } else if (property === 'translateX') {\n                // For additive position changes, add the difference to current position\n                const currentLeft = parseFloat(element.style.left) || 0;\n                const newLeft = currentLeft + targetValue;\n                element.style.left = `${newLeft}px`;\n                \n                console.log('DEBUG: Applying additive translateX animation:', {\n                  currentLeft: currentLeft,\n                  targetValue: targetValue,\n                  newLeft: newLeft,\n                  elementName: element.getAttribute('data-figma-name')\n                });\n              } else if (property === 'translateY') {\n                // For additive position changes, add the difference to current position\n                const currentTop = parseFloat(element.style.top) || 0;\n                const newTop = currentTop + targetValue;\n                element.style.top = `${newTop}px`;\n                \n                console.log('DEBUG: Applying additive translateY animation:', {\n                  currentTop: currentTop,\n                  targetValue: targetValue,\n                  newTop: newTop,\n                  elementName: element.getAttribute('data-figma-name')\n                });\n              }\n            } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n              if (element.parentElement) {\n                const paddingProperty = property.replace('parent_', '');\n                element.parentElement.style[paddingProperty] = `${targetValue}px`;\n              }\n            } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n              if (property === 'alignTranslateX') {\n                element.style.left = `${targetValue}px`;\n              } else if (property === 'alignTranslateY') {\n                element.style.top = `${targetValue}px`;\n              } else if (property.startsWith('parent_')) {\n                if (element.parentElement) {\n                  const alignmentProperty = property.replace('parent_', '');\n                  element.parentElement.style[alignmentProperty] = targetValue;\n                }\n              } else {\n                // Direct property change on the element\n                element.style[property] = targetValue;\n              }\n            }\n            break;\n        }\n        \n        console.log('DEBUG: Applied change:', { property, transitionProperty, targetValue });\n      }\n      \n      // Helper function to get easing function\n      function getEasingFunction(animationType) {\n        switch (animationType) {\n          case 'EASE_IN_AND_OUT_BACK':\n            return 'ease-in-out';\n          case 'EASE_IN_AND_OUT':\n            return 'ease-in-out';\n          case 'EASE_IN':\n            return 'ease-in';\n          case 'EASE_OUT':\n            return 'ease-out';\n          case 'LINEAR':\n            return 'linear';\n          case 'BOUNCY':\n            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';\n          case 'GENTLE':\n            return 'ease-in-out';\n          case 'SMART_ANIMATE':\n            return 'ease-in-out';\n          default:\n            return 'ease-out';\n        }\n      }\n      \n      // Helper function to create element copy\n      function createElementCopy(sourceElement) {\n        console.log('DEBUG: createElementCopy function called');\n        console.log('DEBUG: Creating element copy for:', sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id'));\n        \n        const copy = sourceElement.cloneNode(true);\n        copy.setAttribute('data-figma-id', sourceElement.getAttribute('data-figma-id') + '-copy');\n        copy.setAttribute('data-is-animation-copy', 'true');\n        \n        // Make an exact copy - don't manipulate positions\n        console.log('DEBUG: Making exact copy of source variant');\n        \n        // Get source elements for copy creation (no detailed logging)\n        const sourceElements = sourceElement.querySelectorAll('[data-figma-id]');\n        \n        // The copy is already an exact clone, no position manipulation needed\n        \n        // Position the copy absolutely over the source element\n        const sourceRect = sourceElement.getBoundingClientRect();\n        const parentRect = sourceElement.parentElement.getBoundingClientRect();\n        \n        copy.style.position = 'absolute';\n        copy.style.top = (sourceRect.top - parentRect.top) + 'px';\n        copy.style.left = (sourceRect.left - parentRect.left) + 'px';\n        copy.style.transform = 'none';\n        copy.style.margin = '0';\n        copy.style.padding = '0';\n        \n        // Set high z-index\n        const allElements = document.querySelectorAll('*');\n        let maxZIndex = 0;\n        allElements.forEach(el => {\n          const zIndex = parseInt(window.getComputedStyle(el).zIndex) || 0;\n          if (zIndex > maxZIndex) maxZIndex = zIndex;\n        });\n        \n        const copyZIndex = maxZIndex + 1000;\n        copy.style.zIndex = copyZIndex.toString();\n        copy.style.pointerEvents = 'none';\n        copy.style.transform = 'translateZ(0)';\n        copy.style.willChange = 'transform, left, top';\n        \n        // Preserve original overflow from source element\n        const sourceComputedStyle = window.getComputedStyle(sourceElement);\n        copy.style.overflow = sourceComputedStyle.overflow;\n        \n        // Ensure the copy and all its children are fully visible\n        copy.style.opacity = '1';\n        copy.style.visibility = 'visible';\n        copy.style.display = 'flex';\n\n        // Ensure all nested elements in the copy are also visible, but preserve their original overflow\n        const copyChildren = copy.querySelectorAll('*');\n        copyChildren.forEach(child => {\n          child.style.opacity = '1';\n          child.style.visibility = 'visible';\n          // Don't override overflow - preserve the original value from the clone\n          if (child.style.display === 'none') {\n            child.style.display = 'flex';\n          }\n        });\n\n        // Ensure all nodes in the copy are visible (no detailed logging)\n        \n        console.log('DEBUG: Copy creation completed');\n        return copy;\n      }\n      \n      // Helper function to update copy content to match destination\n      function updateCopyContentToMatchDestination(copy, destination) {\n        console.log('DEBUG: Updating copy content to match destination');\n        \n        // Get all elements in both copy and destination\n        const copyElements = copy.querySelectorAll('[data-figma-id]');\n        const destinationElements = destination.querySelectorAll('[data-figma-id]');\n        \n        // Create a map of destination elements by name\n        const destinationElementMap = new Map();\n        destinationElements.forEach(element => {\n          const name = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n          if (name) {\n            destinationElementMap.set(name, element);\n          }\n        });\n        \n        // Update each copy element's content to match destination\n        copyElements.forEach(copyElement => {\n          const copyElementName = copyElement.getAttribute('data-figma-name') || copyElement.getAttribute('data-figma-id');\n          const destinationElement = destinationElementMap.get(copyElementName);\n          \n          if (destinationElement) {\n            // Update text content\n            if (destinationElement.textContent !== copyElement.textContent) {\n              copyElement.textContent = destinationElement.textContent;\n            }\n            \n            // Update innerHTML for more complex content, but preserve positioning\n            if (destinationElement.innerHTML !== copyElement.innerHTML) {\n              \n              // CRITICAL FIX: Preserve the positioning of ALL nested elements before updating content\n              const allNestedElements = copyElement.querySelectorAll('[data-figma-id]');\n              const originalPositions = new Map();\n              \n              allNestedElements.forEach(nestedElement => {\n                const nestedElementName = nestedElement.getAttribute('data-figma-name') || nestedElement.getAttribute('data-figma-id');\n                const computedStyle = window.getComputedStyle(nestedElement);\n                originalPositions.set(nestedElementName, {\n                  position: computedStyle.position,\n                  left: computedStyle.left,\n                  top: computedStyle.top,\n                  transform: computedStyle.transform\n                });\n              });\n              \n              // Also preserve the copy element itself\n              const copyComputedStyle = window.getComputedStyle(copyElement);\n              originalPositions.set(copyElementName, {\n                position: copyComputedStyle.position,\n                left: copyComputedStyle.left,\n                top: copyComputedStyle.top,\n                transform: copyComputedStyle.transform\n              });\n              \n              // Update the innerHTML\n              copyElement.innerHTML = destinationElement.innerHTML;\n              \n              // CRITICAL FIX: Restore the positioning of ALL elements after content update\n              originalPositions.forEach((positionData, elementName) => {\n                const elementToRestore = elementName === copyElementName ? \n                  copyElement : \n                  copyElement.querySelector('[data-figma-name=\"' + elementName + '\"]') ||\n                  copyElement.querySelector('[data-figma-id=\"' + elementName + '\"]');\n                \n                if (elementToRestore) {\n                  elementToRestore.style.position = positionData.position;\n                  elementToRestore.style.left = positionData.left;\n                  elementToRestore.style.top = positionData.top;\n                  elementToRestore.style.transform = positionData.transform;\n                }\n              });\n            }\n            \n            // Update specific attributes that might contain content\n            const contentAttributes = ['data-content', 'data-text', 'title', 'alt'];\n            contentAttributes.forEach(attr => {\n              const destValue = destinationElement.getAttribute(attr);\n              const copyValue = copyElement.getAttribute(attr);\n              if (destValue !== copyValue && destValue !== null) {\n                copyElement.setAttribute(attr, destValue);\n              }\n            });\n          }\n        });\n        \n        // Ensure all elements in the copy are visible after content update, but preserve overflow\n        const allCopyElements = copy.querySelectorAll('*');\n        allCopyElements.forEach(element => {\n          element.style.opacity = '1';\n          element.style.visibility = 'visible';\n          // Don't override overflow - preserve the original value from the clone\n          if (element.style.display === 'none') {\n            element.style.display = 'flex';\n          }\n        });\n      }\n      \n      // Helper function to animate copy to destination\n      function animateCopyToDestination(copy, destination, originalSourceElement, transitionType, transitionDuration) {\n        return new Promise((resolve) => {\n          // Update copy content to match destination content\n          updateCopyContentToMatchDestination(copy, destination);\n          \n          // Find elements with property changes\n          const elementsToAnimate = findElementsWithPropertyChanges(destination, copy, originalSourceElement);\n          \n          const easingFunction = getEasingFunction(transitionType);\n          const duration = parseFloat(transitionDuration || '0.3');\n          \n          if (elementsToAnimate.length > 0) {\n            console.log('DEBUG: Animating copy with', elementsToAnimate.length, 'elements using modular system');\n            \n            // Setup animation for each element using the changes already detected\n            elementsToAnimate.forEach(({ element, sourceElement, changes }) => {\n              console.log('DEBUG: Processing element with changes:', changes);\n              \n              // Convert the detected changes to animation changes\n              const animationChanges = [];\n              \n              // Handle position changes - use combined transform for simultaneous X and Y movement\n              const hasPositionX = changes.positionX && changes.positionX.changed;\n              const hasPositionY = changes.positionY && changes.positionY.changed;\n              \n              if (hasPositionX || hasPositionY) {\n                // Create a single combined transform animation\n                const translateX = hasPositionX ? changes.positionX.targetValue : 0;\n                const translateY = hasPositionY ? changes.positionY.targetValue : 0;\n                \n                animationChanges.push({\n                  type: AnimationType.TRANSFORM,\n                  property: 'translate',\n                  sourceValue: { x: 0, y: 0 },\n                  targetValue: { x: translateX, y: translateY },\n                  changed: true,\n                  translationCondition: TranslationCondition.ABSOLUTE,\n                  isCombinedTransform: true\n                });\n                \n                console.log('DEBUG: Created combined transform animation:', {\n                  translateX: translateX,\n                  translateY: translateY,\n                  elementName: element.getAttribute('data-figma-name')\n                });\n              }\n              \n              // Handle color changes\n              if (changes.backgroundColor && changes.backgroundColor.changed) {\n                animationChanges.push({\n                  type: AnimationType.SIMPLE,\n                  property: 'backgroundColor',\n                  sourceValue: changes.backgroundColor.sourceValue,\n                  targetValue: changes.backgroundColor.targetValue,\n                  changed: true\n                });\n              }\n              \n              if (changes.color && changes.color.changed) {\n                animationChanges.push({\n                  type: AnimationType.SIMPLE,\n                  property: 'color',\n                  sourceValue: changes.color.sourceValue,\n                  targetValue: changes.color.targetValue,\n                  changed: true\n                });\n              }\n              \n              // Handle alignment changes\n              if (changes.justifyContent && changes.justifyContent.changed) {\n                // Calculate the position difference that the alignment change creates\n                const parent = element.parentElement;\n                if (parent) {\n                  const parentRect = parent.getBoundingClientRect();\n                  const elementRect = element.getBoundingClientRect();\n                  const elementWidth = elementRect.width;\n                  \n                  // Calculate current position relative to parent\n                  const currentLeft = elementRect.left - parentRect.left;\n                  \n                  // Calculate target position based on alignment change\n                  let targetLeft = currentLeft;\n                  if (changes.justifyContent.targetValue === 'flex-end') {\n                    targetLeft = parentRect.width - elementWidth;\n                  } else if (changes.justifyContent.targetValue === 'center') {\n                    targetLeft = (parentRect.width - elementWidth) / 2;\n                  } else if (changes.justifyContent.targetValue === 'flex-start') {\n                    targetLeft = 0;\n                  }\n                  \n                  // Only animate if there's actually a position difference\n                  if (Math.abs(currentLeft - targetLeft) > 1) {\n                    console.log('DEBUG: Calculating justifyContent position animation:', {\n                      currentLeft: currentLeft,\n                      targetLeft: targetLeft,\n                      justifyContent: changes.justifyContent.targetValue,\n                      parentWidth: parentRect.width,\n                      elementWidth: elementWidth\n                    });\n                    \n                    // Animate the position, NOT the alignment\n                    element.style.transition = `left ${duration}s ${easingFunction}`;\n                    element.style.left = `${targetLeft}px`;\n                    \n                    console.log('DEBUG: Applied justifyContent position animation:', {\n                      property: 'left',\n                      transitionProperty: 'left',\n                      targetValue: `${targetLeft}px`\n                    });\n                  } else {\n                    console.log('DEBUG: JustifyContent change detected but no position difference - skipping animation');\n                  }\n                  \n                  // Don't add to animationChanges array since we're handling it directly\n                  return;\n                }\n              }\n              \n              if (changes.alignItems && changes.alignItems.changed) {\n                // Calculate the position difference that the alignment change creates\n                const parent = element.parentElement;\n                if (parent) {\n                  const parentRect = parent.getBoundingClientRect();\n                  const elementRect = element.getBoundingClientRect();\n                  const elementHeight = elementRect.height;\n                  \n                  // Calculate current position relative to parent\n                  const currentTop = elementRect.top - parentRect.top;\n                  \n                  // Calculate target position based on alignment change\n                  let targetTop = currentTop;\n                  if (changes.alignItems.targetValue === 'flex-end') {\n                    targetTop = parentRect.height - elementHeight;\n                  } else if (changes.alignItems.targetValue === 'center') {\n                    targetTop = (parentRect.height - elementHeight) / 2;\n                  } else if (changes.alignItems.targetValue === 'flex-start') {\n                    targetTop = 0;\n                  }\n                  \n                  // Only animate if there's actually a position difference\n                  if (Math.abs(currentTop - targetTop) > 1) {\n                    console.log('DEBUG: Calculating alignItems position animation:', {\n                      currentTop: currentTop,\n                      targetTop: targetTop,\n                      alignItems: changes.alignItems.targetValue,\n                      parentHeight: parentRect.height,\n                      elementHeight: elementHeight\n                    });\n                    \n                    // Animate the position, NOT the alignment\n                    element.style.transition = `top ${duration}s ${easingFunction}`;\n                    element.style.top = `${targetTop}px`;\n                    \n                    console.log('DEBUG: Applied alignItems position animation:', {\n                      property: 'top',\n                      transitionProperty: 'top',\n                      targetValue: `${targetTop}px`\n                    });\n                  } else {\n                    console.log('DEBUG: AlignItems change detected but no position difference - skipping animation');\n                  }\n                  \n                  // Don't add to animationChanges array since we're handling it directly\n                  return;\n                }\n              }\n              \n              // Note: justifyContent and alignItems changes are handled directly above\n              // and only applied if there's an actual position difference\n              \n              console.log('DEBUG: Converted to animation changes:', animationChanges);\n              \n                          // Apply each change\n            animationChanges.forEach(change => {\n              applyAnimationChange(element, change, duration, easingFunction);\n            });\n          });\n          \n          // Force reflow\n          copy.offsetHeight;\n          \n\n          \n\n            \n\n            \n            // Monitor animation progress using transition end events\n            let completedAnimations = 0;\n            const totalAnimations = elementsToAnimate.length;\n            \n            console.log('DEBUG: Setting up animation monitoring for', totalAnimations, 'elements');\n            \n            // Track which elements have actually been animated and their transition properties\n            const animatedElementsSet = new Set();\n            const transitionProperties = new Map(); // Track which properties are being transitioned\n            \n            // Also track which elements have been processed to avoid double-counting\n            const processedElements = new Set();\n            \n            // Track if animation has completed to stop sub-frame tracking\n            let animationCompleted = false;\n            \n            // Set up transition properties for monitoring\n            elementsToAnimate.forEach(({ element, changes }, index) => {\n              const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n              const elementProperties = [];\n              \n              // Check for combined transform or individual position changes\n              const hasPositionX = changes.positionX && changes.positionX.changed;\n              const hasPositionY = changes.positionY && changes.positionY.changed;\n              \n              if (hasPositionX || hasPositionY) {\n                // Use transform for combined movement, or individual properties for single-axis movement\n                if (hasPositionX && hasPositionY) {\n                  elementProperties.push('transform'); // Combined transform\n                } else {\n                  if (hasPositionX) elementProperties.push('left');\n                  if (hasPositionY) elementProperties.push('top');\n                }\n              }\n              if (changes.backgroundColor && changes.backgroundColor.changed) {\n                elementProperties.push('background-color');\n              }\n              if (changes.color && changes.color.changed) {\n                elementProperties.push('color');\n              }\n              if (changes.justifyContent && changes.justifyContent.changed) {\n                elementProperties.push('left');\n              }\n              if (changes.alignItems && changes.alignItems.changed) {\n                elementProperties.push('top');\n              }\n              \n              // Remove duplicates and set the properties\n              const uniqueProperties = [...new Set(elementProperties)];\n              transitionProperties.set(element, uniqueProperties);\n            });\n            \n            const onTransitionEnd = (event) => {\n              const targetElement = event.target;\n              const propertyName = event.propertyName;\n              \n              console.log('\uD83C\uDFAF TRANSITION END EVENT:', {\n                targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'),\n                propertyName: propertyName,\n                timestamp: Date.now()\n              });\n              \n              // Find which element this transition belongs to\n              const animatedElement = elementsToAnimate.find(({ element }) => \n                targetElement === element || element.contains(targetElement)\n              );\n              \n              if (animatedElement) {\n                const elementKey = animatedElement.element;\n                const expectedProperties = transitionProperties.get(elementKey) || [];\n                \n                // Check if this is a property we're expecting to transition\n                if (expectedProperties.includes(propertyName)) {\n                  // Remove this property from the expected list\n                  const updatedProperties = expectedProperties.filter(p => p !== propertyName);\n                  transitionProperties.set(elementKey, updatedProperties);\n                  \n                  // If all properties for this element have completed, mark the element as done\n                                  if (updatedProperties.length === 0 && !animatedElementsSet.has(elementKey)) {\n                  animatedElementsSet.add(elementKey);\n                  completedAnimations++;\n                  \n                  if (completedAnimations >= totalAnimations) {\n                    console.log('\uD83C\uDFAF All animations completed via transition end');\n                    animationCompleted = true;\n                    copy.removeEventListener('transitionend', onTransitionEnd);\n                    copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                    childElements.forEach(child => {\n                      child.removeEventListener('transitionend', onTransitionEnd);\n                    });\n                    clearTimeout(fallbackTimeout);\n                    clearInterval(intervalId);\n                    clearInterval(progressCheckInterval);\n                    resolve();\n                  }\n                }\n                }\n              } else {\n                // Check if this is a child element that might be part of an animated element\n                const parentAnimatedElement = elementsToAnimate.find(({ element }) => \n                  element.contains(targetElement)\n                );\n                \n                if (parentAnimatedElement && !processedElements.has(targetElement)) {\n                  processedElements.add(targetElement);\n                  \n                  // For child elements, we'll use a simpler approach - just count unique elements\n                  const elementKey = parentAnimatedElement.element;\n                  if (!animatedElementsSet.has(elementKey)) {\n                    animatedElementsSet.add(elementKey);\n                    completedAnimations++;\n                    \n                    if (completedAnimations >= totalAnimations) {\n                      console.log('\uD83C\uDFAF All animations completed via child transition');\n                      animationCompleted = true;\n                      copy.removeEventListener('transitionend', onTransitionEnd);\n                      copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                      childElements.forEach(child => {\n                        child.removeEventListener('transitionend', onTransitionEnd);\n                      });\n                      clearTimeout(fallbackTimeout);\n                      clearInterval(intervalId);\n                      clearInterval(progressCheckInterval);\n                      resolve();\n                    }\n                  }\n                }\n              }\n            };\n            \n            // Add a more aggressive monitoring approach - check if animations are actually complete\n            const checkAnimationProgressDetailed = () => {\n              let actuallyCompleted = 0;\n              elementsToAnimate.forEach(({ element, changes }) => {\n                const computedStyle = window.getComputedStyle(element);\n                const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n                \n                // Only log position when there's a significant change or completion\n                const currentLeft = parseFloat(computedStyle.left) || 0;\n                const currentTop = parseFloat(computedStyle.top) || 0;\n                const currentTransform = computedStyle.transform;\n                \n                // Check if the element has reached its target position\n                let isComplete = false;\n                \n                if (changes.positionY && changes.positionY.changed) {\n                  const targetTop = changes.positionY.targetValue;\n                  const difference = Math.abs(currentTop - targetTop);\n                  \n                  if (difference < 5) { // Allow for small rounding differences\n                    isComplete = true;\n                  }\n                }\n                \n                if (changes.positionX && changes.positionX.changed) {\n                  const targetLeft = changes.positionX.targetValue;\n                  const difference = Math.abs(currentLeft - targetLeft);\n                  \n                  if (difference < 5) { // Allow for small rounding differences\n                    isComplete = true;\n                  }\n                }\n                \n                if (isComplete && !animatedElementsSet.has(element)) {\n                  console.log('\uD83C\uDFAF POSITION CHECK COMPLETED:', {\n                    elementName: elementName,\n                    currentLeft: currentLeft,\n                    currentTop: currentTop,\n                    targetLeft: changes.positionX?.targetValue || 0,\n                    targetTop: changes.positionY?.targetValue || 0,\n                    timestamp: Date.now()\n                  });\n                  animatedElementsSet.add(element);\n                  actuallyCompleted++;\n                }\n              });\n              \n              if (actuallyCompleted > 0) {\n                completedAnimations += actuallyCompleted;\n                \n                if (completedAnimations >= totalAnimations) {\n                  console.log('\uD83C\uDFAF All animations completed via position check');\n                  animationCompleted = true;\n                  copy.removeEventListener('transitionend', onTransitionEnd);\n                  copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                  childElements.forEach(child => {\n                    child.removeEventListener('transitionend', onTransitionEnd);\n                  });\n                  clearInterval(intervalId);\n                  clearInterval(progressCheckInterval);\n                  resolve();\n                }\n              }\n            };\n            \n            // Log animation start details\n            console.log('\uD83C\uDFAC ANIMATION START:', {\n              totalElements: elementsToAnimate.length,\n              transitionType: transitionType,\n              transitionDuration: transitionDuration,\n              easingFunction: getEasingFunction(transitionType),\n              elements: elementsToAnimate.map(({ element, changes }) => ({\n                elementName: element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id'),\n                initialLeft: parseFloat(window.getComputedStyle(element).left) || 0,\n                initialTop: parseFloat(window.getComputedStyle(element).top) || 0,\n                targetLeft: changes.positionX?.targetValue || 0,\n                targetTop: changes.positionY?.targetValue || 0,\n                hasPositionX: changes.positionX?.changed || false,\n                hasPositionY: changes.positionY?.changed || false\n              }))\n            });\n            \n            // Add simplified animation progress tracking (no sub-frame logging)\n            let animationStartTime = Date.now();\n            \n            const checkAnimationProgressSimple = () => {\n              // Stop tracking if animation has completed\n              if (animationCompleted) {\n                return;\n              }\n              \n              const currentTime = Date.now();\n              const elapsed = currentTime - animationStartTime;\n              \n              // Only log significant progress milestones (every 100ms)\n              if (elapsed % 100 < 16) { // Log roughly every 100ms\n                console.log('\uD83C\uDFAF ANIMATION PROGRESS:', {\n                  elapsed: elapsed + 'ms',\n                  elements: elementsToAnimate.length,\n                  transitionType: transitionType,\n                  transitionDuration: transitionDuration\n                });\n              }\n            };\n            \n            // Check progress every 100ms instead of 16ms\n            const progressInterval = setInterval(checkAnimationProgressSimple, 100);\n            \n            // Stop progress tracking after animation duration + buffer\n            setTimeout(() => {\n              clearInterval(progressInterval);\n              console.log('\uD83C\uDFAF PROGRESS TRACKING COMPLETED');\n              \n                      // CRITICAL FIX: Stop all animation monitoring when the animation should be complete\n        // This prevents the monitoring from continuing to track the destination variant\n        if (!animationCompleted) {\n          console.log('\uD83C\uDFAF FORCING ANIMATION COMPLETION - stopping all monitoring');\n          animationCompleted = true;\n          copy.removeEventListener('transitionend', onTransitionEnd);\n          copy.removeEventListener('transitionend', onCopyTransitionEnd);\n          childElements.forEach(child => {\n            child.removeEventListener('transitionend', onTransitionEnd);\n          });\n          clearTimeout(fallbackTimeout);\n          clearInterval(intervalId);\n          clearInterval(progressInterval);\n          \n          // CRITICAL FIX: Ensure the copy has the final position before resolving\n          elementsToAnimate.forEach(({ element, changes }) => {\n            const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n            const computedStyle = window.getComputedStyle(element);\n            console.log('\uD83C\uDFAF FINAL POSITION BEFORE RESOLVE:', {\n              elementName: elementName,\n              finalLeft: computedStyle.left,\n              finalTop: computedStyle.top,\n              targetLeft: changes.positionX?.targetValue || 0,\n              targetTop: changes.positionY?.targetValue || 0\n            });\n          });\n          \n          resolve();\n        }\n            }, parseFloat(transitionDuration || '0.3') * 1000 + 500);\n            \n            // Set up periodic position checking with simplified logging\n            const progressCheckInterval = setInterval(checkAnimationProgressDetailed, 100); // Check every 100ms\n            \n            // Store the interval ID so we can clear it later\n            const intervalId = progressCheckInterval;\n            \n            // Also listen for transitions on the copy element itself\n            const onCopyTransitionEnd = (event) => {\n              const propertyName = event.propertyName;\n              \n              // Since the copy itself isn't animated, we need to find which child element this transition belongs to\n              // The transition end event on the copy usually means one of its animated children has completed\n              const animatedElement = elementsToAnimate.find(({ element }) => \n                copy.contains(element)\n              );\n              \n              if (animatedElement) {\n                const elementKey = animatedElement.element;\n                const expectedProperties = transitionProperties.get(elementKey) || [];\n                \n                // Check if this is a property we're expecting to transition\n                if (expectedProperties.includes(propertyName)) {\n                  // Remove this property from the expected list\n                  const updatedProperties = expectedProperties.filter(p => p !== propertyName);\n                  transitionProperties.set(elementKey, updatedProperties);\n                  \n                  // If all properties for this element have completed, mark the element as done\n                  if (updatedProperties.length === 0 && !animatedElements.has(elementKey)) {\n                    animatedElements.add(elementKey);\n                    completedAnimations++;\n                    \n                    if (completedAnimations >= totalAnimations) {\n                      console.log('\uD83C\uDFAF All animations completed via property completion');\n                      animationCompleted = true;\n                      copy.removeEventListener('transitionend', onTransitionEnd);\n                      copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                      childElements.forEach(child => {\n                        child.removeEventListener('transitionend', onTransitionEnd);\n                      });\n                      clearTimeout(fallbackTimeout);\n                      clearInterval(intervalId);\n                      clearInterval(progressCheckInterval);\n                      resolve();\n                    }\n                  }\n                }\n              }\n            };\n            \n            // Add transition end listener to the copy element and all its children\n            copy.addEventListener('transitionend', onTransitionEnd);\n            copy.addEventListener('transitionend', onCopyTransitionEnd);\n            \n            // Also listen for transitions on child elements that might be animated\n            const childElements = copy.querySelectorAll('*');\n            childElements.forEach(child => {\n              child.addEventListener('transitionend', onTransitionEnd);\n            });\n            \n            // Fallback timeout in case transition events don't fire\n            const fallbackTimeout = setTimeout(() => {\n              // Check if animations are actually complete by examining the computed styles\n              let actuallyCompleted = 0;\n              elementsToAnimate.forEach(({ element, changes }) => {\n                const computedStyle = window.getComputedStyle(element);\n                \n                // If transition is 'none' or empty, animation is likely complete\n                if (!computedStyle.transition || computedStyle.transition === 'none' || computedStyle.transition === 'all 0s ease 0s') {\n                  actuallyCompleted++;\n                }\n              });\n              \n              console.log('\uD83C\uDFAF All animations completed via fallback timeout');\n              animationCompleted = true;\n              copy.removeEventListener('transitionend', onTransitionEnd);\n              copy.removeEventListener('transitionend', onCopyTransitionEnd);\n              childElements.forEach(child => {\n                child.removeEventListener('transitionend', onTransitionEnd);\n              });\n              clearInterval(intervalId);\n              clearInterval(progressInterval);\n              resolve();\n            }, parseFloat(transitionDuration || '0.3') * 1000 + 2000); // Add 2s buffer for more reliability\n          } else {\n            resolve();\n          }\n        });\n      }\n      \n      // Helper function to get node data from element (placeholder)\n      function getNodeDataFromElement(element) {\n        // This would need to be implemented to extract Figma node data from DOM elements\n        // For now, return a basic structure\n        return {\n          type: element.getAttribute('data-figma-type') || 'UNKNOWN',\n          layoutPositioning: element.getAttribute('data-layout-positioning') || 'AUTO',\n          layoutMode: element.getAttribute('data-layout-mode') || 'NONE'\n        };\n      }\n      \n      // Helper function to find elements with property changes\n      function findElementsWithPropertyChanges(targetVariant, currentVariant, originalSourceVariant) {\n        if (!currentVariant) {\n          return [];\n        }\n        \n        const targetElements = targetVariant.querySelectorAll('[data-figma-id]');\n        const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');\n        const sourceElementMap = new Map();\n        const elementsToAnimate = [];\n\n        // Build source element map by name\n        sourceElements.forEach(function(sourceElement) {\n          const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');\n          if (sourceName) {\n            sourceElementMap.set(sourceName, sourceElement);\n          }\n        });\n\n        // Analyze each target element for property changes\n        targetElements.forEach(function(element, index) {\n          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n          const sourceElement = sourceElementMap.get(targetName);\n          \n          if (sourceElement) {\n            const changes = detectPropertyChanges(element, sourceElement, originalSourceVariant);\n            \n            if (changes.hasChanges) {\n              elementsToAnimate.push({\n                element: sourceElement,  // Use SOURCE element (from copy) instead of target\n                sourceElement: sourceElement,\n                changes: changes\n              });\n            }\n          }\n        });\n        \n        return elementsToAnimate;\n      }\n\n      // Helper function to detect property changes between elements\n      function detectPropertyChanges(targetElement, sourceElement, originalSourceVariant) {\n        const changes = {\n          hasChanges: false,\n          positionX: { changed: false, sourceValue: null, targetValue: null },\n          positionY: { changed: false, sourceValue: null, targetValue: null },\n          backgroundColor: { changed: false, sourceValue: null, targetValue: null },\n          color: { changed: false, sourceValue: null, targetValue: null },\n          justifyContent: { changed: false, sourceValue: null, targetValue: null },\n          alignItems: { changed: false, sourceValue: null, targetValue: null }\n        };\n\n        try {\n          const sourceStyle = window.getComputedStyle(sourceElement);\n          const targetStyle = window.getComputedStyle(targetElement);\n          \n          // STEP 1: Check if the node has position changes using bounding rectangles (accounts for flexbox alignment)\n          const targetRect = targetElement.getBoundingClientRect();\n          \n          // Get parent rectangles for relative positioning\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          const targetParentRect = targetParent ? targetParent.getBoundingClientRect() : { left: 0, top: 0 };\n          \n          // For the source element (copy), use computed styles since it's positioned absolutely\n          // For the target element, use bounding rect for accurate positioning\n          // Calculate the position differences between source and target\n          // Use the original source element's position, not the copy's position\n          const originalSourceElement = originalSourceVariant.querySelector('[data-figma-name=\"' + sourceElement.getAttribute('data-figma-name') + '\"]');\n          const originalSourceStyle = originalSourceElement ? window.getComputedStyle(originalSourceElement) : sourceStyle;\n          const originalSourceRect = originalSourceElement ? originalSourceElement.getBoundingClientRect() : sourceElement.getBoundingClientRect();\n          const originalSourceParent = originalSourceElement ? originalSourceElement.parentElement : sourceElement.parentElement;\n          const originalSourceParentRect = originalSourceParent ? originalSourceParent.getBoundingClientRect() : sourceParentRect;\n          \n          // Calculate positions based on element centers, not top-left corners\n          const sourceCenterX = originalSourceRect.left + originalSourceRect.width / 2 - originalSourceParentRect.left;\n          const sourceCenterY = originalSourceRect.top + originalSourceRect.height / 2 - originalSourceParentRect.top;\n          const targetCenterX = targetRect.left + targetRect.width / 2 - targetParentRect.left;\n          const targetCenterY = targetRect.top + targetRect.height / 2 - targetParentRect.top;\n          \n          // Convert center positions back to top-left positions for the element\n          const sourceLeft = sourceCenterX - originalSourceRect.width / 2;\n          const sourceTop = sourceCenterY - originalSourceRect.height / 2;\n          const targetLeft = targetCenterX - targetRect.width / 2;\n          const targetTop = targetCenterY - targetRect.height / 2;\n          \n          // STEP 2: Check if the node has ignore auto layout enabled\n          const ignoreAutoLayout = sourceElement.getAttribute('data-layout-positioning') === 'ABSOLUTE';\n          \n          // STEP 3: Check if the node's parent has auto layout\n          const parentHasAutoLayout = sourceParent && targetParent && \n            sourceParent.getAttribute('data-layout-mode') && \n            sourceParent.getAttribute('data-layout-mode') !== 'NONE';\n          \n\n          \n          // Determine if this node should be animated based on the 3-point logic\n          let shouldAnimatePosition = false;\n          let animationType = 'ABSOLUTE';\n          \n          if (Math.abs(sourceLeft - targetLeft) > 1 || Math.abs(sourceTop - targetTop) > 1) {\n            // Node has position changes\n            if (ignoreAutoLayout) {\n              // Node ignores auto layout - animate absolutely\n              shouldAnimatePosition = true;\n              animationType = 'ABSOLUTE';\n              console.log('DEBUG: Node has position changes and ignores auto layout - animating absolutely');\n            } else if (!parentHasAutoLayout) {\n              // Node's parent doesn't have auto layout - animate absolutely\n              shouldAnimatePosition = true;\n              animationType = 'ABSOLUTE';\n              console.log('DEBUG: Node has position changes and parent has no auto layout - animating absolutely');\n            } else {\n              // Node has position changes and parent has auto layout - ANIMATE the node\n              // The node moves due to parent's alignment changes, so we animate it smoothly\n              shouldAnimatePosition = true;\n              animationType = 'ABSOLUTE';\n              console.log('DEBUG: Node has position changes and parent has auto layout - ANIMATING (node moves due to parent alignment)');\n            }\n          } else {\n            // No position changes - no animation needed\n            shouldAnimatePosition = false;\n            console.log('DEBUG: No position changes detected - no animation needed');\n          }\n          \n          // Apply position changes if animation is needed\n          if (shouldAnimatePosition) {\n            if (Math.abs(sourceLeft - targetLeft) > 1) {\n              changes.positionX.changed = true;\n              changes.positionX.sourceValue = 0; // Start from 0 (additive animation)\n              changes.positionX.targetValue = targetLeft - sourceLeft; // Add the difference to current position\n              changes.hasChanges = true;\n              \n              // Debug the position calculation\n              console.log('DEBUG: Additive position calculation for X:', {\n                sourceLeft: sourceLeft,\n                targetLeft: targetLeft,\n                difference: targetLeft - sourceLeft,\n                elementName: sourceElement.getAttribute('data-figma-name')\n              });\n            }\n            \n            if (Math.abs(sourceTop - targetTop) > 1) {\n              changes.positionY.changed = true;\n              changes.positionY.sourceValue = 0; // Start from 0 (additive animation)\n              changes.positionY.targetValue = targetTop - sourceTop; // Add the difference to current position\n              changes.hasChanges = true;\n              \n              // Debug the position calculation\n              console.log('DEBUG: Additive position calculation for Y:', {\n                sourceTop: sourceTop,\n                targetTop: targetTop,\n                difference: targetTop - sourceTop,\n                elementName: sourceElement.getAttribute('data-figma-name')\n              });\n            }\n          }\n\n          // Check style changes (non-position)\n          const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';\n          const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';\n          \n          if (sourceBg !== targetBg) {\n            changes.backgroundColor.changed = true;\n            changes.backgroundColor.sourceValue = sourceBg;\n            changes.backgroundColor.targetValue = targetBg;\n            changes.hasChanges = true;\n          }\n          \n          if (sourceStyle.color !== targetStyle.color) {\n            changes.color.changed = true;\n            changes.color.sourceValue = sourceStyle.color;\n            changes.color.targetValue = targetStyle.color;\n            changes.hasChanges = true;\n          }\n          \n          // Only mark alignment changes as requiring animation if there's an actual position difference\n          if (sourceStyle.justifyContent !== targetStyle.justifyContent) {\n            changes.justifyContent.changed = true;\n            changes.justifyContent.sourceValue = sourceStyle.justifyContent;\n            changes.justifyContent.targetValue = targetStyle.justifyContent;\n            \n            // Only set hasChanges if there's an actual position difference to animate\n            if (shouldAnimatePosition) {\n              changes.hasChanges = true;\n            }\n          }\n          \n          if (sourceStyle.alignItems !== targetStyle.alignItems) {\n            changes.alignItems.changed = true;\n            changes.alignItems.sourceValue = sourceStyle.alignItems;\n            changes.alignItems.targetValue = targetStyle.alignItems;\n            \n            // Only set hasChanges if there's an actual position difference to animate\n            if (shouldAnimatePosition) {\n              changes.hasChanges = true;\n            }\n          }\n        } catch (error) {\n          console.error('Error detecting property changes:', error);\n        }\n\n        return changes;\n      }\n      \n      // Helper function to handle animated variant switching\n      async function handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration) {\n        console.log('\uD83D\uDD04 VARIANT SWITCH SEQUENCE START:', {\n          sourceId: sourceElement.getAttribute('data-figma-id'),\n          sourceName: sourceElement.getAttribute('data-figma-name'),\n          destinationId: destination.getAttribute('data-figma-id'),\n          destinationName: destination.getAttribute('data-figma-name'),\n          transitionType: transitionType,\n          transitionDuration: transitionDuration,\n          totalVariants: allVariants.length\n        });\n        \n        // Create a copy of the source variant\n        const sourceCopy = createElementCopy(sourceElement);\n        console.log('DEBUG: Element copy created successfully');\n        \n        // Insert the copy into the DOM\n        const sourceParent = sourceElement.parentElement;\n        sourceParent.appendChild(sourceCopy);\n        console.log('DEBUG: Copy inserted into DOM');\n        \n        // Log the copy's position and visibility after insertion\n        const copyRect = sourceCopy.getBoundingClientRect();\n        const copyStyle = window.getComputedStyle(sourceCopy);\n        console.log('DEBUG: Copy after insertion:');\n        console.log('  position: ' + copyStyle.position);\n        console.log('  top: ' + copyStyle.top);\n        console.log('  left: ' + copyStyle.left);\n        console.log('  z-index: ' + copyStyle.zIndex);\n        console.log('  opacity: ' + copyStyle.opacity);\n        console.log('  visibility: ' + copyStyle.visibility);\n        console.log('  display: ' + copyStyle.display);\n        console.log('  bounding rect: ' + copyRect);\n        \n        // Hide the original source element and all other variants\n        sourceElement.style.opacity = '0';\n        sourceElement.style.visibility = 'hidden';\n        \n        allVariants.forEach(variant => {\n          if (variant !== sourceElement) {\n            variant.style.opacity = '0';\n            variant.style.visibility = 'hidden';\n          }\n        });\n        \n        // Prepare the destination variant but keep it hidden for now\n        destination.classList.add('variant-active');\n        destination.classList.remove('variant-hidden');\n        destination.style.visibility = 'hidden';\n        destination.style.opacity = '0';\n        \n        // DON'T pre-position the destination variant - let the copy do all the animation work\n        // The destination variant should remain in its natural position\n        \n        // Force reflow\n        destination.offsetHeight;\n        \n        // Animate the copy to match the destination\n        await animateCopyToDestination(sourceCopy, destination, sourceElement, transitionType, transitionDuration);\n        \n        // Animation complete - simply remove the copy and show the destination variant\n        console.log('\u2705 ANIMATION COMPLETED - removing copy and showing destination variant');\n        sourceCopy.remove();\n        \n        // Hide the original source element permanently\n        sourceElement.style.opacity = '0';\n        sourceElement.style.visibility = 'hidden';\n        sourceElement.classList.add('variant-hidden');\n        sourceElement.classList.remove('variant-active');\n        \n        // Simply show the destination variant - don't touch its positioning\n        console.log('\uD83C\uDFAF SHOWING DESTINATION VARIANT:', {\n          destinationId: destination.getAttribute('data-figma-id'),\n          destinationName: destination.getAttribute('data-figma-name'),\n          visibility: 'visible',\n          opacity: '1',\n          display: 'flex'\n        });\n        destination.style.visibility = 'visible';\n        destination.style.opacity = '1';\n        destination.style.display = 'flex';\n        destination.classList.add('variant-active');\n        destination.classList.remove('variant-hidden');\n        \n        // Hide all other variants\n        allVariants.forEach(variant => {\n          if (variant !== destination) {\n            variant.classList.add('variant-hidden');\n            variant.classList.remove('variant-active');\n            // Don't reset positions for hidden variants - let them keep their natural positions\n            if (!variant.style.position || variant.style.position === 'static') {\n              variant.style.position = 'relative';\n            }\n            variant.style.opacity = '0';\n            variant.style.visibility = 'hidden';\n          }\n        });\n        \n        // Force a reflow to ensure the position changes are applied before starting reactions\n        destination.offsetHeight;\n        \n        // Start timeout reactions\n        console.log('\u23F0 STARTING TIMEOUT REACTIONS for destination variant');\n        startTimeoutReactionsForNewlyActiveVariant(destination);\n        startTimeoutReactionsForNestedComponents(destination);\n        \n        console.log('\u2705 VARIANT SWITCH SEQUENCE COMPLETED:', {\n          sourceId: sourceElement.getAttribute('data-figma-id'),\n          destinationId: destination.getAttribute('data-figma-id'),\n          transitionType: transitionType\n        });\n      }\n      \n      // Helper function to perform instant variant switch\n      function performInstantVariantSwitch(allVariants, destination) {\n        console.log('\u26A1 PERFORMING INSTANT VARIANT SWITCH');\n        \n        // Hide all variants\n        allVariants.forEach(variant => {\n          variant.classList.add('variant-hidden');\n          variant.classList.remove('variant-active');\n          variant.style.display = 'none';\n          variant.style.visibility = 'hidden';\n          variant.style.opacity = '0';\n          // Don't reset positions for hidden variants - let them keep their natural positions\n          if (!variant.style.position || variant.style.position === 'static') {\n            variant.style.position = 'relative';\n          }\n        });\n        \n        // Show destination variant\n        destination.classList.add('variant-active');\n        destination.classList.remove('variant-hidden');\n        destination.style.display = 'flex';\n        destination.style.visibility = 'visible';\n        destination.style.opacity = '1';\n        // Don't reset position for destination - let it keep its natural position\n        if (!destination.style.position || destination.style.position === 'static') {\n          destination.style.position = 'relative';\n        }\n        \n        console.log('\u2705 INSTANT VARIANT SWITCH COMPLETED:', {\n          destinationId: destination.getAttribute('data-figma-id'),\n          destinationName: destination.getAttribute('data-figma-name'),\n          display: destination.style.display,\n          visibility: destination.style.visibility,\n          opacity: destination.style.opacity\n        });\n        \n        // Start timeout reactions\n        startTimeoutReactionsForNewlyActiveVariant(destination);\n        startTimeoutReactionsForNestedComponents(destination);\n      }\n      \n      // Main reaction handler function\n      function handleReaction(sourceElement, destinationId, transitionType, transitionDuration) {\n        console.log('\uD83C\uDFAF REACTION TRIGGERED:', {\n          sourceId: sourceElement.getAttribute('data-figma-id'),\n          sourceName: sourceElement.getAttribute('data-figma-name'),\n          destinationId: destinationId,\n          transitionType: transitionType,\n          transitionDuration: transitionDuration\n        });\n        \n        // Prevent multiple simultaneous transitions\n        if (isTransitionInProgress) {\n          console.log('\u26A0\uFE0F TRANSITION ALREADY IN PROGRESS - skipping');\n          return;\n        }\n        \n        // Set transition lock\n        isTransitionInProgress = true;\n        \n        // Safety timeout\n        const safetyTimeout = setTimeout(() => {\n          if (isTransitionInProgress) {\n            console.log('WARNING: Transition lock stuck, forcing release');\n            isTransitionInProgress = false;\n            currentTransitionPromise = null;\n          }\n        }, 10000); // Increased to 10 seconds\n        \n        if (destinationId) {\n          const destination = document.querySelector(`[data-figma-id=\"${destinationId}\"]`);\n          \n          if (!destination) {\n            console.error('Destination element not found:', destinationId);\n            clearTimeout(safetyTimeout);\n            isTransitionInProgress = false;\n            return;\n          }\n          \n          // Check if this is a variant switch within a component set\n          const sourceComponentSet = sourceElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const destinationComponentSet = destination.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          \n          if (sourceComponentSet && destinationComponentSet && sourceComponentSet === destinationComponentSet) {\n            // This is a variant switch\n            console.log('\uD83D\uDD04 VARIANT SWITCH DETECTED:', {\n              componentSetId: sourceComponentSet.getAttribute('data-figma-id'),\n              componentSetName: sourceComponentSet.getAttribute('data-figma-name')\n            });\n            \n            const componentSet = sourceComponentSet;\n            const allVariants = Array.from(componentSet.children).filter(child => \n              child.getAttribute('data-figma-type') === 'COMPONENT'\n            );\n            \n            console.log('\uD83D\uDCCA VARIANT ANALYSIS:', {\n              totalVariants: allVariants.length,\n              variantIds: allVariants.map(v => v.getAttribute('data-figma-id')),\n              variantNames: allVariants.map(v => v.getAttribute('data-figma-name'))\n            });\n            \n            // Check if transition type is null/undefined (instant transition) or a recognized animated type\n            const isAnimated = transitionType === 'SMART_ANIMATE' || \n                              transitionType === 'BOUNCY' || \n                              transitionType === 'EASE_IN_AND_OUT' || \n                              transitionType === 'EASE_IN_AND_OUT_BACK' || \n                              transitionType === 'EASE_IN' || \n                              transitionType === 'EASE_OUT' || \n                              transitionType === 'LINEAR' || \n                              transitionType === 'GENTLE';\n            \n            // Only use fallback values if we have a recognized animated transition type\n            const effectiveTransitionType = isAnimated ? (transitionType || 'EASE_OUT') : transitionType;\n            const effectiveTransitionDuration = isAnimated ? (transitionDuration || '0.3') : transitionDuration;\n            \n            if (isAnimated) {\n              console.log('\uD83C\uDFAC ANIMATED TRANSITION SELECTED:', {\n                transitionType: effectiveTransitionType,\n                transitionDuration: effectiveTransitionDuration\n              });\n              \n              currentTransitionPromise = handleAnimatedVariantSwitch(sourceElement, destination, allVariants, effectiveTransitionType, effectiveTransitionDuration)\n                .then(() => {\n                  clearTimeout(safetyTimeout);\n                  isTransitionInProgress = false;\n                  currentTransitionPromise = null;\n                })\n                .catch((error) => {\n                  console.error('Modular animation error:', error);\n                  clearTimeout(safetyTimeout);\n                  isTransitionInProgress = false;\n                  currentTransitionPromise = null;\n                });\n            } else {\n              console.log('\u26A1 INSTANT TRANSITION SELECTED:', {\n                transitionType: effectiveTransitionType,\n                reason: 'Not recognized as animated transition type'\n              });\n              \n              performInstantVariantSwitch(allVariants, destination);\n              clearTimeout(safetyTimeout);\n              isTransitionInProgress = false;\n              currentTransitionPromise = null;\n            }\n          } else {\n            // This is a regular transition (not variant switching)\n            if (transitionType === 'DISSOLVE') {\n              console.log('\uD83C\uDFAD DISSOLVE TRANSITION SELECTED:', {\n                transitionType: transitionType,\n                transitionDuration: transitionDuration\n              });\n              \n              // Hide source element\n              sourceElement.style.opacity = '0';\n              sourceElement.style.visibility = 'hidden';\n              \n              // Show destination after delay\n              setTimeout(() => {\n                destination.classList.add('variant-active');\n                destination.classList.remove('variant-hidden');\n                destination.style.opacity = '1';\n                destination.style.visibility = 'visible';\n                \n                startTimeoutReactionsForNewlyActiveVariant(destination);\n                startTimeoutReactionsForNestedComponents(destination);\n                \n                clearTimeout(safetyTimeout);\n                isTransitionInProgress = false;\n                currentTransitionPromise = null;\n              }, parseFloat(transitionDuration || '300'));\n            } else {\n              console.log('\u26A1 INSTANT TRANSITION SELECTED (non-variant):', {\n                transitionType: transitionType,\n                reason: 'Not a dissolve transition'\n              });\n              \n              destination.classList.add('variant-active');\n              destination.classList.remove('variant-hidden');\n              destination.style.opacity = '1';\n              destination.style.visibility = 'visible';\n              \n              startTimeoutReactionsForNewlyActiveVariant(destination);\n              startTimeoutReactionsForNestedComponents(destination);\n              \n              clearTimeout(safetyTimeout);\n              isTransitionInProgress = false;\n              currentTransitionPromise = null;\n            }\n          }\n        } else {\n          // Handle case where destinationId is null (final variant - no further transitions)\n          clearTimeout(safetyTimeout);\n          isTransitionInProgress = false;\n          currentTransitionPromise = null;\n        }\n      }\n      \n      // Global timer tracking\n      const activeTimers = new Map();\n      \n      // Function to start timeout reactions for nested components within a parent element\n      function startTimeoutReactionsForNestedComponents(parentElement) {\n        if (!parentElement) return;\n        \n        // Find all nested components with timeout reactions within the parent\n        const nestedComponents = parentElement.querySelectorAll('[data-has-reactions=\"true\"]');\n        \n        nestedComponents.forEach(element => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          const computedStyle = window.getComputedStyle(element);\n          \n          // Only start timers for elements that are actually visible\n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n            \n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId);\n                const actionType = element.getAttribute('data-reaction-action-type');\n                const destinationId = element.getAttribute('data-reaction-destination');\n                const transitionType = element.getAttribute('data-reaction-transition-type');\n                const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n                \n                handleReaction(element, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');\n          }\n        });\n      }\n      \n      // Function to start timeout reactions for a specific newly active variant\n      function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {\n        if (!newlyActiveElement) return;\n        \n        const elementId = newlyActiveElement.getAttribute('data-figma-id');\n        const elementName = newlyActiveElement.getAttribute('data-figma-name');\n        const parentComponent = newlyActiveElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n        const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n        \n        console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);\n        \n        // Only start timers for variants that are actually visible (not hidden by CSS)\n        const computedStyle = window.getComputedStyle(newlyActiveElement);\n        \n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');\n          const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');\n          const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');\n          const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');\n          const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');\n          \n          // Handle timeout reactions only for active variants that don't have an active timer\n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId); // Clear the timer when it completes\n              handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n          } else if (activeTimers.has(elementId)) {\n            console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');\n          }\n          \n          // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant\n          startTimeoutReactionsForNestedComponents(newlyActiveElement);\n        } else {\n          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n        }\n      }\n      \n      // Make functions globally available\n      window.handleReaction = handleReaction;\n      window.startTimeoutReactionsForNewlyActiveVariant = startTimeoutReactionsForNewlyActiveVariant;\n      window.startTimeoutReactionsForNestedComponents = startTimeoutReactionsForNestedComponents;\n    ";
}


/***/ }),

/***/ 825:
/***/ ((__unused_webpack_module, exports) => {


/**
 * Simple Animation System
 *
 * A very basic animation system that:
 * 1. Takes a source element and target element
 * 2. Animates the source element to match the target's position
 * 3. Shows the target element when done
 *
 * No complex three-phase system, no copying, just simple CSS transitions.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.simpleAnimate = simpleAnimate;
exports.simpleVariantSwitch = simpleVariantSwitch;
exports.instantVariantSwitch = instantVariantSwitch;
exports.resetAnimationState = resetAnimationState;
exports.officialStyleAnimate = officialStyleAnimate;
exports.generateSimpleTransitionHandler = generateSimpleTransitionHandler;
/**
 * Helper function to find all elements within source and target variants that have animated property changes
 */
function findAnimatedElementsAndChanges(sourceVariant, targetVariant, options) {
    if (options === void 0) { options = {}; }
    var changes = [];
    var _a = options.animateColor, animateColor = _a === void 0 ? false : _a, _b = options.animateShadow, animateShadow = _b === void 0 ? false : _b, _c = options.animateSize, animateSize = _c === void 0 ? false : _c;
    console.log('🔍 FINDING ANIMATED ELEMENTS AND CHANGES');
    console.log('📋 Source variant:', sourceVariant.getAttribute('data-figma-id'));
    console.log('📋 Target variant:', targetVariant.getAttribute('data-figma-id'));
    // Get all elements with data-figma-id in both variants
    var sourceElements = sourceVariant.querySelectorAll('[data-figma-id]');
    var targetElements = targetVariant.querySelectorAll('[data-figma-id]');
    console.log('🔍 Found', sourceElements.length, 'elements in source variant');
    console.log('🔍 Found', targetElements.length, 'elements in target variant');
    // Create maps of target elements by their figma ID and name for lookup
    var targetElementMapById = new Map();
    var targetElementMapByName = new Map();
    targetElements.forEach(function (element) {
        var figmaId = element.getAttribute('data-figma-id');
        var figmaName = element.getAttribute('data-figma-name');
        if (figmaId) {
            targetElementMapById.set(figmaId, element);
        }
        if (figmaName) {
            targetElementMapByName.set(figmaName, element);
        }
    });
    // Check each source element for changes
    sourceElements.forEach(function (sourceElement) {
        var figmaId = sourceElement.getAttribute('data-figma-id');
        var figmaName = sourceElement.getAttribute('data-figma-name');
        if (!figmaId && !figmaName)
            return;
        // Try to find target element by ID first, then by name as fallback
        var targetElement = figmaId ? targetElementMapById.get(figmaId) : null;
        if (!targetElement && figmaName) {
            targetElement = targetElementMapByName.get(figmaName);
            if (targetElement) {
                console.log('🔍 Found target element by name instead of ID:', figmaName);
            }
        }
        if (!targetElement) {
            console.log('🔍 No matching target element found for:', figmaId || figmaName);
            return;
        }
        // Get positions from Figma coordinates stored in data attributes
        var sourceFigmaX = parseFloat(sourceElement.getAttribute('data-figma-x') || '0') || 0;
        var sourceFigmaY = parseFloat(sourceElement.getAttribute('data-figma-y') || '0') || 0;
        var targetFigmaX = parseFloat(targetElement.getAttribute('data-figma-x') || '0') || 0;
        var targetFigmaY = parseFloat(targetElement.getAttribute('data-figma-y') || '0') || 0;
        // Calculate the difference using Figma coordinates
        var deltaX = targetFigmaX - sourceFigmaX;
        var deltaY = targetFigmaY - sourceFigmaY;
        var hasPositionChange = Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1;
        // Initialize change object
        var change = {
            sourceElement: sourceElement,
            targetElement: targetElement,
            deltaX: deltaX,
            deltaY: deltaY,
            hasPositionChange: hasPositionChange,
            hasColorChange: false,
            hasBorderColorChange: false,
            hasOpacityChange: false,
            hasShadowChange: false,
            hasSizeChange: false,
            sourceColor: '',
            targetColor: '',
            sourceBorderColor: '',
            targetBorderColor: '',
            sourceOpacity: '',
            targetOpacity: '',
            sourceShadow: '',
            targetShadow: '',
            sourceWidth: '',
            targetWidth: '',
            sourceHeight: '',
            targetHeight: '',
            sourceMinWidth: '',
            targetMinWidth: '',
            sourceMinHeight: '',
            targetMinHeight: '',
            sourceMaxWidth: '',
            targetMaxWidth: '',
            sourceMaxHeight: '',
            targetMaxHeight: ''
        };
        // Check for color changes
        if (animateColor) {
            var sourceComputedStyle = window.getComputedStyle(sourceElement);
            var targetComputedStyle = window.getComputedStyle(targetElement);
            change.sourceColor = sourceComputedStyle.backgroundColor;
            change.targetColor = targetComputedStyle.backgroundColor;
            change.sourceBorderColor = sourceComputedStyle.borderColor;
            change.targetBorderColor = targetComputedStyle.borderColor;
            change.sourceOpacity = sourceComputedStyle.opacity;
            change.targetOpacity = targetComputedStyle.opacity;
            // Ensure we have valid color values
            if (!change.sourceColor || change.sourceColor === 'rgba(0, 0, 0, 0)' || change.sourceColor === 'transparent') {
                change.sourceColor = 'rgb(255, 107, 107)'; // Default red
            }
            if (!change.targetColor || change.targetColor === 'rgba(0, 0, 0, 0)' || change.targetColor === 'transparent') {
                change.targetColor = 'rgb(243, 156, 18)'; // Default orange
            }
            change.hasColorChange = change.sourceColor !== change.targetColor;
            change.hasBorderColorChange = change.sourceBorderColor !== change.targetBorderColor;
            change.hasOpacityChange = change.sourceOpacity !== change.targetOpacity;
        }
        // Check for shadow changes
        if (animateShadow) {
            var sourceComputedStyle = window.getComputedStyle(sourceElement);
            var targetComputedStyle = window.getComputedStyle(targetElement);
            change.sourceShadow = sourceComputedStyle.boxShadow;
            change.targetShadow = targetComputedStyle.boxShadow;
            // Ensure we have valid shadow values
            if (!change.sourceShadow || change.sourceShadow === 'none') {
                change.sourceShadow = '0px 0px 0px 0px rgba(0, 0, 0, 0)';
            }
            if (!change.targetShadow || change.targetShadow === 'none') {
                change.targetShadow = '0px 0px 0px 0px rgba(0, 0, 0, 0)';
            }
            change.hasShadowChange = change.sourceShadow !== change.targetShadow;
        }
        // Check for size changes
        if (animateSize) {
            var sourceComputedStyle = window.getComputedStyle(sourceElement);
            var targetComputedStyle = window.getComputedStyle(targetElement);
            change.sourceWidth = sourceComputedStyle.width;
            change.targetWidth = targetComputedStyle.width;
            change.sourceHeight = sourceComputedStyle.height;
            change.targetHeight = targetComputedStyle.height;
            change.sourceMinWidth = sourceComputedStyle.minWidth;
            change.targetMinWidth = targetComputedStyle.minWidth;
            change.sourceMinHeight = sourceComputedStyle.minHeight;
            change.targetMinHeight = targetComputedStyle.minHeight;
            change.sourceMaxWidth = sourceComputedStyle.maxWidth;
            change.targetMaxWidth = targetComputedStyle.maxWidth;
            change.sourceMaxHeight = sourceComputedStyle.maxHeight;
            change.targetMaxHeight = targetComputedStyle.maxHeight;
            change.hasSizeChange = (change.sourceWidth !== change.targetWidth ||
                change.sourceHeight !== change.targetHeight ||
                change.sourceMinWidth !== change.targetMinWidth ||
                change.sourceMinHeight !== change.targetMinHeight ||
                change.sourceMaxWidth !== change.targetMaxWidth ||
                change.sourceMaxHeight !== change.targetMaxHeight);
        }
        // Only add to changes if there's actually something to animate
        var hasAnyChange = hasPositionChange ||
            (animateColor && (change.hasColorChange || change.hasBorderColorChange || change.hasOpacityChange)) ||
            (animateShadow && change.hasShadowChange) ||
            (animateSize && change.hasSizeChange);
        if (hasAnyChange) {
            console.log('🔍 Found changes for element:', figmaId, {
                hasPositionChange: hasPositionChange,
                hasColorChange: change.hasColorChange,
                hasShadowChange: change.hasShadowChange,
                hasSizeChange: change.hasSizeChange,
                deltaX: deltaX,
                deltaY: deltaY
            });
            changes.push(change);
        }
    });
    console.log('🔍 Total elements with changes:', changes.length);
    return changes;
}
/**
 * Simple animation function that animates a specific element based on detected changes
 */
function simpleAnimate(change, options) {
    if (options === void 0) { options = {}; }
    return new Promise(function (resolve) {
        var _a = options.duration, duration = _a === void 0 ? 0.5 : _a, _b = options.easing, easing = _b === void 0 ? 'ease-in-out' : _b, onComplete = options.onComplete;
        var sourceElement = change.sourceElement, targetElement = change.targetElement;
        console.log('🎬 SIMPLE ANIMATION: Starting animation for element:', sourceElement.getAttribute('data-figma-id'));
        console.log('📊 Position delta:', { deltaX: change.deltaX, deltaY: change.deltaY });
        console.log('📊 Has position change:', change.hasPositionChange);
        console.log('📊 Has color change:', change.hasColorChange);
        console.log('📊 Has shadow change:', change.hasShadowChange);
        console.log('📊 Has size change:', change.hasSizeChange);
        // Use CSS animations instead of transitions for better simultaneous control
        var animationName = "simple-animation-".concat(Date.now(), "-").concat(Math.random());
        // Create the keyframes for simultaneous animation
        var keyframes = "\n      @keyframes ".concat(animationName, " {\n        0% {\n          transform: translate(0px, 0px);\n          ").concat(change.hasColorChange ? "background-color: ".concat(change.sourceColor, ";") : '', "\n          ").concat(change.hasBorderColorChange ? "border-color: ".concat(change.sourceBorderColor, ";") : '', "\n          ").concat(change.hasOpacityChange ? "opacity: ".concat(change.sourceOpacity, ";") : '', "\n          ").concat(change.hasShadowChange ? "box-shadow: ".concat(change.sourceShadow, ";") : '', "\n          ").concat(change.hasSizeChange ? "width: ".concat(change.sourceWidth, "; height: ").concat(change.sourceHeight, "; min-width: ").concat(change.sourceMinWidth, "; min-height: ").concat(change.sourceMinHeight, "; max-width: ").concat(change.sourceMaxWidth, "; max-height: ").concat(change.sourceMaxHeight, ";") : '', "\n        }\n        100% {\n          transform: translate(").concat(change.deltaX, "px, ").concat(change.deltaY, "px);\n          ").concat(change.hasColorChange ? "background-color: ".concat(change.targetColor, ";") : '', "\n          ").concat(change.hasBorderColorChange ? "border-color: ".concat(change.targetBorderColor, ";") : '', "\n          ").concat(change.hasOpacityChange ? "opacity: ".concat(change.targetOpacity, ";") : '', "\n          ").concat(change.hasShadowChange ? "box-shadow: ".concat(change.targetShadow, ";") : '', "\n          ").concat(change.hasSizeChange ? "width: ".concat(change.targetWidth, "; height: ").concat(change.targetHeight, "; min-width: ").concat(change.targetMinWidth, "; min-height: ").concat(change.targetMinHeight, "; max-width: ").concat(change.targetMaxWidth, "; max-height: ").concat(change.targetMaxHeight, ";") : '', "\n        }\n      }\n    ");
        console.log('🎬 Keyframes created:', keyframes);
        console.log('🎬 Expected final transform:', "translate(".concat(change.deltaX, "px, ").concat(change.deltaY, "px)"));
        // Add the keyframes to the document
        var style = document.createElement('style');
        style.textContent = keyframes;
        document.head.appendChild(style);
        // Disable any existing CSS transitions that might interfere
        sourceElement.style.transition = 'none';
        // Apply the animation
        sourceElement.style.animation = "".concat(animationName, " ").concat(duration, "s ").concat(easing, " forwards");
        // Debug: Check if animation is actually running
        setTimeout(function () {
            var computedStyle = window.getComputedStyle(sourceElement);
            console.log('🎬 Animation debug for element:', sourceElement.getAttribute('data-figma-id'));
            console.log('🎬 Computed animation:', computedStyle.animation);
            console.log('🎬 Computed transform:', computedStyle.transform);
        }, 100);
        // Clean up the style element after animation
        setTimeout(function () {
            if (document.head.contains(style)) {
                document.head.removeChild(style);
            }
        }, duration * 1000 + 100);
        // Listen for animation completion
        var onAnimationEnd = function (event) {
            if (event.animationName === animationName) {
                console.log('✅ SIMPLE ANIMATION: Animation completed for element:', sourceElement.getAttribute('data-figma-id'));
                // Log the final computed values
                var finalComputedStyle = window.getComputedStyle(sourceElement);
                console.log('🎬 Final computed transform:', finalComputedStyle.transform);
                console.log('🎬 Final computed color:', finalComputedStyle.backgroundColor);
                console.log('🎬 Final computed shadow:', finalComputedStyle.boxShadow);
                console.log('🎬 Final computed width:', finalComputedStyle.width);
                console.log('🎬 Final computed height:', finalComputedStyle.height);
                // Clean up
                sourceElement.removeEventListener('animationend', onAnimationEnd);
                sourceElement.style.animation = '';
                // Call completion callback
                if (onComplete) {
                    onComplete();
                }
                resolve();
            }
        };
        sourceElement.addEventListener('animationend', onAnimationEnd);
        // Fallback timeout
        setTimeout(function () {
            console.log('⏰ SIMPLE ANIMATION: Animation completed via timeout for element:', sourceElement.getAttribute('data-figma-id'));
            sourceElement.removeEventListener('animationend', onAnimationEnd);
            sourceElement.style.animation = '';
            if (onComplete) {
                onComplete();
            }
            resolve();
        }, duration * 1000 + 1000);
    });
}
/**
 * Simple variant switch function that handles nested element animations
 */
function simpleVariantSwitch(sourceElement, targetElement, options) {
    if (options === void 0) { options = {}; }
    console.log('🔄 SIMPLE VARIANT SWITCH: Starting variant switch');
    // Find all animated elements and their changes
    var changes = findAnimatedElementsAndChanges(sourceElement, targetElement, options);
    if (changes.length === 0) {
        console.log('🔄 No changes detected, performing instant switch');
        // If no changes detected, just do an instant switch
        sourceElement.style.display = 'none';
        targetElement.style.display = 'flex';
        return Promise.resolve();
    }
    console.log('🔄 Found', changes.length, 'elements with changes to animate');
    // Animate all changes simultaneously
    var animationPromises = changes.map(function (change) {
        return simpleAnimate(change, options);
    });
    return Promise.all(animationPromises).then(function () {
        console.log('✅ All animations completed');
        // Hide source and show target after all animations complete
        sourceElement.style.display = 'none';
        targetElement.style.display = 'flex';
    });
}
/**
 * Instant variant switch (no animation)
 */
function instantVariantSwitch(sourceElement, targetElement) {
    console.log('⚡ INSTANT VARIANT SWITCH: Switching without animation');
    sourceElement.style.display = 'none';
    targetElement.style.display = 'flex';
}
/**
 * Reset animation state
 */
function resetAnimationState(sourceElement, targetElement) {
    console.log('🔄 RESET: Resetting animation state');
    // Reset source element
    sourceElement.style.display = 'flex';
    sourceElement.style.transition = '';
    sourceElement.style.transform = '';
    // Reset target element
    targetElement.style.display = 'none';
    targetElement.style.transition = '';
    targetElement.style.transform = '';
}
/**
 * Drop-in replacement for the official animation system
 * Uses the simple animation approach but provides the same interface
 */
function officialStyleAnimate(sourceElement, targetElement, allVariants, transitionType, transitionDuration) {
    return new Promise(function (resolve) {
        console.log('🎬 OFFICIAL-STYLE ANIMATION: Starting with simple approach');
        // Keep source visible for animation, but hide target initially
        allVariants.forEach(function (variant) {
            if (variant === sourceElement) {
                variant.style.display = 'flex';
                variant.classList.add('variant-active');
                variant.classList.remove('variant-hidden');
            }
            else if (variant === targetElement) {
                // Keep target hidden but prepare it
                variant.style.display = 'none';
                variant.classList.add('variant-hidden');
                variant.classList.remove('variant-active');
            }
            else {
                variant.style.display = 'none';
                variant.classList.add('variant-hidden');
                variant.classList.remove('variant-active');
            }
        });
        // Use the simple animation approach with the new system
        var duration = parseFloat(transitionDuration.toString()) || 0.5;
        var easing = getEasingFromTransitionType(transitionType);
        // Find all animated elements and their changes
        var changes = findAnimatedElementsAndChanges(sourceElement, targetElement, {
            animateColor: true,
            animateShadow: true,
            animateSize: true
        });
        if (changes.length === 0) {
            console.log('🔄 No changes detected, performing instant switch');
            // If no changes detected, just do an instant switch
            sourceElement.style.display = 'none';
            sourceElement.classList.add('variant-hidden');
            sourceElement.classList.remove('variant-active');
            targetElement.style.display = 'flex';
            targetElement.classList.add('variant-active');
            targetElement.classList.remove('variant-hidden');
            console.log('✅ OFFICIAL-STYLE ANIMATION: Completed');
            resolve();
        }
        else {
            console.log('🔄 Found', changes.length, 'elements with changes to animate');
            // Animate all changes simultaneously
            var animationPromises = changes.map(function (change) {
                return simpleAnimate(change, {
                    duration: duration,
                    easing: easing
                });
            });
            Promise.all(animationPromises).then(function () {
                console.log('✅ All animations completed');
                // Show target and hide source after all animations complete
                sourceElement.style.display = 'none';
                sourceElement.classList.add('variant-hidden');
                sourceElement.classList.remove('variant-active');
                targetElement.style.display = 'flex';
                targetElement.classList.add('variant-active');
                targetElement.classList.remove('variant-hidden');
                console.log('✅ OFFICIAL-STYLE ANIMATION: Completed');
                resolve();
            });
        }
    });
}
/**
 * Helper function to convert transition types to easing functions
 */
function getEasingFromTransitionType(transitionType) {
    switch (transitionType) {
        case 'EASE_IN_AND_OUT_BACK':
            return 'cubic-bezier(0.68, -0.6, 0.32, 1.6)';
        case 'EASE_IN_AND_OUT':
            return 'ease-in-out';
        case 'EASE_IN':
            return 'ease-in';
        case 'EASE_OUT':
            return 'ease-out';
        case 'LINEAR':
            return 'linear';
        case 'BOUNCY':
            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';
        case 'GENTLE':
            return 'ease-in-out';
        case 'SMART_ANIMATE':
            return 'ease-in-out';
        default:
            return 'ease-out';
    }
}
/**
 * Generate JavaScript code for the official system's transition handler
 * but using the simple animation approach internally
 */
function generateSimpleTransitionHandler() {
    return "\n    // Global transition lock to prevent multiple simultaneous transitions\n    let isTransitionInProgress = false;\n    \n    // Animation types\n    const AnimationType = {\n      SIMPLE: 'SIMPLE',\n      SIZE: 'SIZE', \n      TRANSFORM: 'TRANSFORM'\n    };\n    \n    // Translation conditions\n    const TranslationCondition = {\n      ABSOLUTE: 'ABSOLUTE',\n      RELATIVE_PADDING: 'RELATIVE_PADDING',\n      RELATIVE_ALIGNMENT: 'RELATIVE_ALIGNMENT'\n    };\n    \n\n    \n    /**\n     * Helper function to get easing function\n     */\n    function getEasingFunction(animationType) {\n      switch (animationType) {\n        case 'EASE_IN_AND_OUT_BACK':\n          return 'cubic-bezier(0.68, -0.6, 0.32, 1.6)';\n        case 'EASE_IN_AND_OUT':\n          return 'ease-in-out';\n        case 'EASE_IN':\n          return 'ease-in';\n        case 'EASE_OUT':\n          return 'ease-out';\n        case 'LINEAR':\n          return 'linear';\n        case 'BOUNCY':\n          return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';\n        case 'GENTLE':\n          return 'ease-in-out';\n        case 'SMART_ANIMATE':\n          return 'ease-in-out';\n        default:\n          return 'ease-out';\n      }\n    }\n    \n    /**\n     * Main reaction handler function - entry point for all reactions\n     */\n    function handleReaction(sourceElement, destinationId, transitionType, transitionDuration) {\n      console.log('\uD83C\uDFAF REACTION TRIGGERED:', {\n        sourceId: sourceElement.getAttribute('data-figma-id'),\n        sourceName: sourceElement.getAttribute('data-figma-name'),\n        destinationId: destinationId,\n        transitionType: transitionType,\n        transitionDuration: transitionDuration\n      });\n      \n      // Check if transition is already in progress\n      if (isTransitionInProgress) {\n        console.log('\u274C Transition already in progress, skipping reaction');\n        return;\n      }\n      \n      // Find the destination element\n      const destination = document.querySelector('[data-figma-id=\"' + destinationId + '\"]');\n      if (!destination) {\n        console.error('\u274C Destination element not found:', destinationId);\n        return;\n      }\n      \n      // Find all variants in the same component set\n      const componentSet = sourceElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n      if (!componentSet) {\n        console.error('\u274C Component set not found for source element');\n        return;\n      }\n      \n      const allVariants = Array.from(componentSet.children).filter(child => \n        child.getAttribute('data-figma-type') === 'COMPONENT'\n      );\n      \n      console.log('\uD83C\uDFAF Found', allVariants.length, 'variants in component set');\n      \n      // Determine if we should animate or perform instant switch\n      if (transitionType && transitionType !== 'INSTANT' && transitionDuration && parseFloat(transitionDuration) > 0) {\n        // Use simple animated variant switch\n        console.log('\uD83C\uDFAD Using simple animated variant switch');\n        handleSimpleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration);\n      } else {\n        // Use instant variant switch\n        console.log('\u26A1 Using instant variant switch');\n        performInstantVariantSwitch(allVariants, destination);\n      }\n    }\n    \n    /**\n     * Helper function to find all elements within source and target variants that have animated property changes\n     */\n    function findAnimatedElementsAndChanges(sourceVariant, targetVariant, options = {}) {\n      const changes = [];\n      const { animateColor = false, animateShadow = false, animateSize = false } = options;\n\n      console.log('\uD83D\uDD0D FINDING ANIMATED ELEMENTS AND CHANGES');\n      console.log('\uD83D\uDCCB Source variant:', sourceVariant.getAttribute('data-figma-id'));\n      console.log('\uD83D\uDCCB Target variant:', targetVariant.getAttribute('data-figma-id'));\n\n      // Get all elements with data-figma-id in both variants\n      const sourceElements = sourceVariant.querySelectorAll('[data-figma-id]');\n      const targetElements = targetVariant.querySelectorAll('[data-figma-id]');\n\n      console.log('\uD83D\uDD0D Found', sourceElements.length, 'elements in source variant');\n      console.log('\uD83D\uDD0D Found', targetElements.length, 'elements in target variant');\n\n      // Create maps of target elements by their figma ID and name for lookup\n      const targetElementMapById = new Map();\n      const targetElementMapByName = new Map();\n      targetElements.forEach(element => {\n        const figmaId = element.getAttribute('data-figma-id');\n        const figmaName = element.getAttribute('data-figma-name');\n        if (figmaId) {\n          targetElementMapById.set(figmaId, element);\n        }\n        if (figmaName) {\n          targetElementMapByName.set(figmaName, element);\n        }\n      });\n\n      // Check each source element for changes\n      sourceElements.forEach(sourceElement => {\n        const figmaId = sourceElement.getAttribute('data-figma-id');\n        const figmaName = sourceElement.getAttribute('data-figma-name');\n        if (!figmaId && !figmaName) return;\n\n        // Try to find target element by ID first, then by name as fallback\n        let targetElement = figmaId ? targetElementMapById.get(figmaId) : null;\n        if (!targetElement && figmaName) {\n          targetElement = targetElementMapByName.get(figmaName);\n          if (targetElement) {\n            console.log('\uD83D\uDD0D Found target element by name instead of ID:', figmaName);\n          }\n        }\n        \n        if (!targetElement) {\n          console.log('\uD83D\uDD0D No matching target element found for:', figmaId || figmaName);\n          return;\n        }\n\n        // Get positions from Figma coordinates stored in data attributes\n        const sourceFigmaX = parseFloat(sourceElement.getAttribute('data-figma-x') || '0') || 0;\n        const sourceFigmaY = parseFloat(sourceElement.getAttribute('data-figma-y') || '0') || 0;\n        const targetFigmaX = parseFloat(targetElement.getAttribute('data-figma-x') || '0') || 0;\n        const targetFigmaY = parseFloat(targetElement.getAttribute('data-figma-y') || '0') || 0;\n        \n        // Calculate the difference using Figma coordinates\n        const deltaX = targetFigmaX - sourceFigmaX;\n        const deltaY = targetFigmaY - sourceFigmaY;\n        const hasPositionChange = Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1;\n\n        // Initialize change object\n        const change = {\n          sourceElement: sourceElement,\n          targetElement: targetElement,\n          deltaX: deltaX,\n          deltaY: deltaY,\n          hasPositionChange: hasPositionChange,\n          hasColorChange: false,\n          hasBorderColorChange: false,\n          hasOpacityChange: false,\n          hasShadowChange: false,\n          hasSizeChange: false,\n          sourceColor: '',\n          targetColor: '',\n          sourceBorderColor: '',\n          targetBorderColor: '',\n          sourceOpacity: '',\n          targetOpacity: '',\n          sourceShadow: '',\n          targetShadow: '',\n          sourceWidth: '',\n          targetWidth: '',\n          sourceHeight: '',\n          targetHeight: '',\n          sourceMinWidth: '',\n          targetMinWidth: '',\n          sourceMinHeight: '',\n          targetMinHeight: '',\n          sourceMaxWidth: '',\n          targetMaxWidth: '',\n          sourceMaxHeight: '',\n          targetMaxHeight: ''\n        };\n\n        // Check for color changes\n        if (animateColor) {\n          const sourceComputedStyle = window.getComputedStyle(sourceElement);\n          const targetComputedStyle = window.getComputedStyle(targetElement);\n          \n          change.sourceColor = sourceComputedStyle.backgroundColor;\n          change.targetColor = targetComputedStyle.backgroundColor;\n          change.sourceBorderColor = sourceComputedStyle.borderColor;\n          change.targetBorderColor = targetComputedStyle.borderColor;\n          change.sourceOpacity = sourceComputedStyle.opacity;\n          change.targetOpacity = targetComputedStyle.opacity;\n          \n          // Ensure we have valid color values\n          if (!change.sourceColor || change.sourceColor === 'rgba(0, 0, 0, 0)' || change.sourceColor === 'transparent') {\n            change.sourceColor = 'rgb(255, 107, 107)';\n          }\n          if (!change.targetColor || change.targetColor === 'rgba(0, 0, 0, 0)' || change.targetColor === 'transparent') {\n            change.targetColor = 'rgb(243, 156, 18)';\n          }\n          \n          change.hasColorChange = change.sourceColor !== change.targetColor;\n          change.hasBorderColorChange = change.sourceBorderColor !== change.targetBorderColor;\n          change.hasOpacityChange = change.sourceOpacity !== change.targetOpacity;\n        }\n\n        // Check for shadow changes\n        if (animateShadow) {\n          const sourceComputedStyle = window.getComputedStyle(sourceElement);\n          const targetComputedStyle = window.getComputedStyle(targetElement);\n          \n          change.sourceShadow = sourceComputedStyle.boxShadow;\n          change.targetShadow = targetComputedStyle.boxShadow;\n          \n          // Ensure we have valid shadow values\n          if (!change.sourceShadow || change.sourceShadow === 'none') {\n            change.sourceShadow = '0px 0px 0px 0px rgba(0, 0, 0, 0)';\n          }\n          if (!change.targetShadow || change.targetShadow === 'none') {\n            change.targetShadow = '0px 0px 0px 0px rgba(0, 0, 0, 0)';\n          }\n          \n          change.hasShadowChange = change.sourceShadow !== change.targetShadow;\n        }\n\n        // Check for size changes\n        if (animateSize) {\n          const sourceComputedStyle = window.getComputedStyle(sourceElement);\n          const targetComputedStyle = window.getComputedStyle(targetElement);\n          \n          change.sourceWidth = sourceComputedStyle.width;\n          change.targetWidth = targetComputedStyle.width;\n          change.sourceHeight = sourceComputedStyle.height;\n          change.targetHeight = targetComputedStyle.height;\n          change.sourceMinWidth = sourceComputedStyle.minWidth;\n          change.targetMinWidth = targetComputedStyle.minWidth;\n          change.sourceMinHeight = sourceComputedStyle.minHeight;\n          change.targetMinHeight = targetComputedStyle.minHeight;\n          change.sourceMaxWidth = sourceComputedStyle.maxWidth;\n          change.targetMaxWidth = targetComputedStyle.maxWidth;\n          change.sourceMaxHeight = sourceComputedStyle.maxHeight;\n          change.targetMaxHeight = targetComputedStyle.maxHeight;\n          \n          change.hasSizeChange = (\n            change.sourceWidth !== change.targetWidth ||\n            change.sourceHeight !== change.targetHeight ||\n            change.sourceMinWidth !== change.targetMinWidth ||\n            change.sourceMinHeight !== change.targetMinHeight ||\n            change.sourceMaxWidth !== change.targetMaxWidth ||\n            change.sourceMaxHeight !== change.targetMaxHeight\n          );\n        }\n\n        // Only add to changes if there's actually something to animate\n        const hasAnyChange = hasPositionChange || \n                            (animateColor && (change.hasColorChange || change.hasBorderColorChange || change.hasOpacityChange)) ||\n                            (animateShadow && change.hasShadowChange) ||\n                            (animateSize && change.hasSizeChange);\n\n        if (hasAnyChange) {\n          console.log('\uD83D\uDD0D Found changes for element:', figmaId, {\n            hasPositionChange: hasPositionChange,\n            hasColorChange: change.hasColorChange,\n            hasShadowChange: change.hasShadowChange,\n            hasSizeChange: change.hasSizeChange,\n            deltaX: deltaX,\n            deltaY: deltaY\n          });\n          changes.push(change);\n        }\n      });\n\n      console.log('\uD83D\uDD0D Total elements with changes:', changes.length);\n      return changes;\n    }\n\n    /**\n     * Simple animation function that animates a specific element based on detected changes\n     */\n    function simpleAnimate(change, options = {}) {\n      return new Promise((resolve) => {\n        const {\n          duration = 0.5,\n          easing = 'ease-in-out',\n          onComplete\n        } = options;\n\n        const { sourceElement, targetElement } = change;\n\n        console.log('\uD83C\uDFAC SIMPLE ANIMATION: Starting animation for element:', sourceElement.getAttribute('data-figma-id'));\n        console.log('\uD83D\uDCCA Position delta:', { deltaX: change.deltaX, deltaY: change.deltaY });\n        console.log('\uD83D\uDCCA Has position change:', change.hasPositionChange);\n        console.log('\uD83D\uDCCA Has color change:', change.hasColorChange);\n        console.log('\uD83D\uDCCA Has shadow change:', change.hasShadowChange);\n        console.log('\uD83D\uDCCA Has size change:', change.hasSizeChange);\n\n        // Use CSS animations instead of transitions\n        const animationName = 'simple-animation-' + Date.now() + '-' + Math.random();\n        \n        // Create the keyframes for simultaneous animation\n        const keyframes = `\n          @keyframes ${animationName} {\n            0% {\n              transform: translate(0px, 0px);\n              ${change.hasColorChange ? `background-color: ${change.sourceColor};` : ''}\n              ${change.hasBorderColorChange ? `border-color: ${change.sourceBorderColor};` : ''}\n              ${change.hasOpacityChange ? `opacity: ${change.sourceOpacity};` : ''}\n              ${change.hasShadowChange ? `box-shadow: ${change.sourceShadow};` : ''}\n              ${change.hasSizeChange ? `width: ${change.sourceWidth}; height: ${change.sourceHeight}; min-width: ${change.sourceMinWidth}; min-height: ${change.sourceMinHeight}; max-width: ${change.sourceMaxWidth}; max-height: ${change.sourceMaxHeight};` : ''}\n            }\n            100% {\n              transform: translate(${change.deltaX}px, ${change.deltaY}px);\n              ${change.hasColorChange ? `background-color: ${change.targetColor};` : ''}\n              ${change.hasBorderColorChange ? `border-color: ${change.targetBorderColor};` : ''}\n              ${change.hasOpacityChange ? `opacity: ${change.targetOpacity};` : ''}\n              ${change.hasShadowChange ? `box-shadow: ${change.targetShadow};` : ''}\n              ${change.hasSizeChange ? `width: ${change.targetWidth}; height: ${change.targetHeight}; min-width: ${change.targetMinWidth}; min-height: ${change.targetMinHeight}; max-width: ${change.targetMaxWidth}; max-height: ${change.targetMaxHeight};` : ''}\n            }\n          }\n        `;\n        \n        console.log('\uD83C\uDFAC Keyframes created:', keyframes);\n        \n        // Add the keyframes to the document\n        const style = document.createElement('style');\n        style.textContent = keyframes;\n        document.head.appendChild(style);\n        \n        // Disable any existing CSS transitions that might interfere\n        sourceElement.style.transition = 'none';\n        \n        // Apply the animation\n        sourceElement.style.animation = `${animationName} ${duration}s ${easing} forwards`;\n        \n        // Debug: Check if animation is actually running\n        setTimeout(() => {\n          const computedStyle = window.getComputedStyle(sourceElement);\n          console.log('\uD83C\uDFAC Animation debug for element:', sourceElement.getAttribute('data-figma-id'));\n          console.log('\uD83C\uDFAC Computed animation:', computedStyle.animation);\n          console.log('\uD83C\uDFAC Computed transform:', computedStyle.transform);\n        }, 100);\n        \n        // Clean up the style element after animation\n        setTimeout(() => {\n          if (document.head.contains(style)) {\n            document.head.removeChild(style);\n          }\n        }, duration * 1000 + 100);\n\n        // Listen for animation completion\n        const onAnimationEnd = (event) => {\n          if (event.animationName === animationName) {\n            console.log('\u2705 SIMPLE ANIMATION: Animation completed for element:', sourceElement.getAttribute('data-figma-id'));\n            \n            // Log the final computed values\n            const finalComputedStyle = window.getComputedStyle(sourceElement);\n            console.log('\uD83C\uDFAC Final computed transform:', finalComputedStyle.transform);\n            console.log('\uD83C\uDFAC Final computed color:', finalComputedStyle.backgroundColor);\n            console.log('\uD83C\uDFAC Final computed shadow:', finalComputedStyle.boxShadow);\n            console.log('\uD83C\uDFAC Final computed width:', finalComputedStyle.width);\n            console.log('\uD83C\uDFAC Final computed height:', finalComputedStyle.height);\n            \n            // Clean up\n            sourceElement.removeEventListener('animationend', onAnimationEnd);\n            sourceElement.style.animation = '';\n            \n            // Call completion callback\n            if (onComplete) {\n              onComplete();\n            }\n            \n            resolve();\n          }\n        };\n        \n        sourceElement.addEventListener('animationend', onAnimationEnd);\n        \n        // Fallback timeout\n        setTimeout(() => {\n          console.log('\u23F0 SIMPLE ANIMATION: Animation completed via timeout for element:', sourceElement.getAttribute('data-figma-id'));\n          sourceElement.removeEventListener('animationend', onAnimationEnd);\n          sourceElement.style.animation = '';\n          \n          if (onComplete) {\n            onComplete();\n          }\n          \n          resolve();\n        }, duration * 1000 + 1000);\n      });\n    }\n\n    /**\n     * Main function to handle animated variant switching using simple approach\n     */\n    async function handleSimpleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration) {\n      console.log('\uD83D\uDD04 SIMPLE ANIMATED VARIANT SWITCH START:', {\n        sourceId: sourceElement.getAttribute('data-figma-id'),\n        sourceName: sourceElement.getAttribute('data-figma-name'),\n        destinationId: destination.getAttribute('data-figma-id'),\n        destinationName: destination.getAttribute('data-figma-name'),\n        transitionType: transitionType,\n        transitionDuration: transitionDuration,\n        totalVariants: allVariants.length\n      });\n      \n      // Check if transition is already in progress\n      if (isTransitionInProgress) {\n        console.log('\u274C Transition already in progress, skipping');\n        return;\n      }\n      \n      isTransitionInProgress = true;\n      \n      // Clear any pending timeout reactions to prevent conflicts\n      if (window.clearAllTimeoutReactions) {\n        window.clearAllTimeoutReactions();\n      }\n      \n      try {\n        // Keep both source and target visible during animation\n        allVariants.forEach(variant => {\n          if (variant === sourceElement) {\n            variant.style.display = 'flex';\n            variant.classList.add('variant-active');\n            variant.classList.remove('variant-hidden');\n          } else if (variant === destination) {\n            // Keep target visible but positioned absolutely for animation\n            variant.style.display = 'flex';\n            variant.style.position = 'absolute';\n            variant.style.top = '0';\n            variant.style.left = '0';\n            variant.style.zIndex = '1';\n            variant.classList.add('variant-hidden');\n            variant.classList.remove('variant-active');\n          } else {\n            variant.style.display = 'none';\n            variant.classList.add('variant-hidden');\n            variant.classList.remove('variant-active');\n          }\n        });\n        \n        // Find all animated elements and their changes\n        const changes = findAnimatedElementsAndChanges(sourceElement, destination, {\n          animateColor: true,\n          animateShadow: true,\n          animateSize: true\n        });\n        \n        if (changes.length === 0) {\n          console.log('\uD83D\uDD04 No changes detected, performing instant switch');\n          // If no changes detected, just do an instant switch\n          sourceElement.style.display = 'none';\n          sourceElement.classList.add('variant-hidden');\n          sourceElement.classList.remove('variant-active');\n          \n          destination.style.display = 'flex';\n          destination.classList.add('variant-active');\n          destination.classList.remove('variant-hidden');\n        } else {\n          console.log('\uD83D\uDD04 Found', changes.length, 'elements with changes to animate');\n          \n          // Use the simple animation approach\n          const duration = parseFloat(transitionDuration.toString()) || 0.5;\n          const easing = getEasingFunction(transitionType);\n          \n          // Animate all changes simultaneously\n          const animationPromises = changes.map(change => \n            simpleAnimate(change, {\n              duration,\n              easing\n            })\n          );\n          \n          await Promise.all(animationPromises);\n          \n          console.log('\u2705 All animations completed');\n          \n          // Show target and hide source after all animations complete\n          sourceElement.style.display = 'none';\n          sourceElement.classList.add('variant-hidden');\n          sourceElement.classList.remove('variant-active');\n          \n          // Reset target positioning and make it active\n          destination.style.position = '';\n          destination.style.top = '';\n          destination.style.left = '';\n          destination.style.zIndex = '';\n          destination.style.display = 'flex';\n          destination.classList.add('variant-active');\n          destination.classList.remove('variant-hidden');\n        }\n        \n        // Start timeout reactions for the new active variant\n        if (window.startTimeoutReactionsForNewlyActiveVariant) {\n          window.startTimeoutReactionsForNewlyActiveVariant(destination);\n        }\n        if (window.startTimeoutReactionsForNestedComponents) {\n          window.startTimeoutReactionsForNestedComponents(destination);\n        }\n        \n        console.log('\u2705 SIMPLE ANIMATED VARIANT SWITCH COMPLETED');\n        \n      } catch (error) {\n        console.error('\u274C Error during simple animated variant switch:', error);\n      } finally {\n        isTransitionInProgress = false;\n      }\n    }\n    \n    /**\n     * Function to perform instant variant switch (no animation)\n     */\n    function performInstantVariantSwitch(allVariants, destination) {\n      console.log('\u26A1 PERFORMING INSTANT VARIANT SWITCH');\n      \n      // Hide all variants - only use display\n      allVariants.forEach(variant => {\n        variant.classList.add('variant-hidden');\n        variant.classList.remove('variant-active');\n        variant.style.display = 'none';\n        if (!variant.style.position || variant.style.position === 'static') {\n          variant.style.position = 'relative';\n        }\n      });\n      \n      // Show destination variant - only use display\n      destination.classList.add('variant-active');\n      destination.classList.remove('variant-hidden');\n      destination.style.display = 'flex';\n      if (!destination.style.position || destination.style.position === 'static') {\n        destination.style.position = 'relative';\n      }\n      \n      console.log('\u2705 INSTANT VARIANT SWITCH COMPLETED');\n      \n      // Start timeout reactions\n      if (window.startTimeoutReactionsForNewlyActiveVariant) {\n        window.startTimeoutReactionsForNewlyActiveVariant(destination);\n      }\n      if (window.startTimeoutReactionsForNestedComponents) {\n        window.startTimeoutReactionsForNestedComponents(destination);\n      }\n    }\n    \n    // Export the main functions for external use\n    window.handleReaction = handleReaction;\n    window.handleSimpleAnimatedVariantSwitch = handleSimpleAnimatedVariantSwitch;\n    window.performInstantVariantSwitch = performInstantVariantSwitch;\n    \n    console.log('\u2705 Simple transition handler loaded');\n  ";
}


/***/ }),

/***/ 925:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// Browser-only entry point for the refactored system
// This file only includes code that runs in the browser, not in the Figma plugin
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Import all the event handling and animation modules
__exportStar(__webpack_require__(995), exports);
__exportStar(__webpack_require__(261), exports);
__exportStar(__webpack_require__(120), exports);
__exportStar(__webpack_require__(332), exports);
__exportStar(__webpack_require__(44), exports);
__exportStar(__webpack_require__(275), exports);
// Import the modular transition handler function
var modular_transition_handler_1 = __webpack_require__(821);
// Store the function for later execution
var modularTransitionHandlerCode = null;
// Function to execute the modular transition handler when needed
function executeModularTransitionHandler() {
    if (!modularTransitionHandlerCode) {
        modularTransitionHandlerCode = (0, modular_transition_handler_1.createModularSmartAnimateHandler)();
    }
    try {
        eval(modularTransitionHandlerCode);
        console.log('DEBUG: Modular transition handler executed successfully');
        return true;
    }
    catch (error) {
        console.error('DEBUG: Error executing modular transition handler:', error);
        return false;
    }
}
// Initialize the system when loaded in browser
if (typeof window !== 'undefined') {
    console.log('DEBUG: Refactored system loaded in browser');
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeSystem);
    }
    else {
        initializeSystem();
    }
}
function initializeSystem() {
    console.log('DEBUG: Initializing refactored system with modular transition handler');
    // Execute the modular transition handler to expose handleReaction and variant switching functions
    if (executeModularTransitionHandler()) {
        console.log('DEBUG: Modular transition handler executed successfully');
    }
    else {
        console.error('DEBUG: Failed to execute modular transition handler');
    }
    // Check if the functions are available
    setTimeout(function () {
        if (window.handleReaction) {
            console.log('DEBUG: handleReaction function is available globally');
        }
        else {
            console.error('DEBUG: handleReaction function not found - the modular transition handler may not be properly loaded');
        }
        if (window.handleAnimatedVariantSwitch) {
            console.log('DEBUG: handleAnimatedVariantSwitch function is available globally');
        }
        else {
            console.error('DEBUG: handleAnimatedVariantSwitch function not found');
        }
        if (window.performInstantVariantSwitch) {
            console.log('DEBUG: performInstantVariantSwitch function is available globally');
        }
        else {
            console.error('DEBUG: performInstantVariantSwitch function not found');
        }
    }, 100);
    console.log('DEBUG: Modular transition handler functions available');
}


/***/ }),

/***/ 995:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateEventHandlingJavaScript = exports.generateVariantAttributes = exports.generateReactionAttributes = void 0;
// Re-export from the new modular events structure
var index_1 = __webpack_require__(172);
Object.defineProperty(exports, "generateReactionAttributes", ({ enumerable: true, get: function () { return index_1.generateReactionAttributes; } }));
Object.defineProperty(exports, "generateVariantAttributes", ({ enumerable: true, get: function () { return index_1.generateVariantAttributes; } }));
Object.defineProperty(exports, "generateEventHandlingJavaScript", ({ enumerable: true, get: function () { return index_1.generateEventHandlingJavaScript; } }));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(925);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});