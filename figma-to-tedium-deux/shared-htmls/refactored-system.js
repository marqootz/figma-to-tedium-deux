(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["FigmaRefactoredSystem"] = factory();
	else
		root["FigmaRefactoredSystem"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 44:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createComponentSetInitializer = createComponentSetInitializer;
// Component set initialization logic
function createComponentSetInitializer() {
    return "\n      // Initialize component set variants - handle both single and multiple variants\n      // Handle both COMPONENT_SET and COMPONENT elements that contain variants\n      // With the new 1:1 structure, this will handle nested component sets correctly\n      const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"], [data-figma-type=\"COMPONENT\"]');\n      componentSets.forEach(componentSet => {\n        // Find all COMPONENT children - these are the variants\n        // Some may have explicit variant attributes, others are variants by hierarchy\n        const variants = componentSet.querySelectorAll('[data-figma-type=\"COMPONENT\"]');\n        \n        // Handle both single and multiple variants\n        if (variants.length >= 1) {\n          console.log('Initializing component set/instance with', variants.length, 'variants:', {\n            componentSetId: componentSet.getAttribute('data-figma-id'),\n            componentSetName: componentSet.getAttribute('data-figma-name'),\n            componentSetType: componentSet.getAttribute('data-figma-type'),\n            parentType: componentSet.parentElement?.getAttribute('data-figma-type'),\n            parentId: componentSet.parentElement?.getAttribute('data-figma-id'),\n            variantIds: Array.from(variants).map(v => v.getAttribute('data-figma-id'))\n          });\n          \n          // Reset opacity for all variants to ensure clean initial state\n          variants.forEach(variant => {\n            variant.style.opacity = '1'; // Ensure all variants start with opacity 1\n          });\n          \n          // For single components, just make them visible\n          if (variants.length === 1) {\n            const singleVariant = variants[0];\n            singleVariant.classList.add('variant-active');\n            singleVariant.classList.remove('variant-hidden');\n            console.log('Set single variant as active:', singleVariant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));\n          } else {\n            // For multiple variants, the FIRST variant should be active initially (where reactions are)\n            // This ensures the animation starts from the variant with reactions\n            variants.forEach((variant, index) => {\n              if (index === 0) {\n                variant.classList.add('variant-active');\n                variant.classList.remove('variant-hidden');\n                console.log('Set first variant as active (with reactions):', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));\n              } else {\n                variant.classList.add('variant-hidden');\n                variant.classList.remove('variant-active');\n                console.log('Set variant as hidden:', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));\n              }\n            });\n          }\n        }\n      });\n  ";
}


/***/ }),

/***/ 82:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPropertyDetector = createPropertyDetector;
// Property change detection logic
function createPropertyDetector() {
    return "\n      // Helper function to find elements with property changes between variants\n      function findElementsWithPropertyChanges(targetVariant, currentVariant) {\n        console.log('DEBUG: findElementsWithPropertyChanges called');\n        console.log('  Target variant ID:', targetVariant.getAttribute('data-figma-id'), 'Name:', targetVariant.getAttribute('data-figma-name'));\n        console.log('  Current variant ID:', currentVariant.getAttribute('data-figma-id'), 'Name:', currentVariant.getAttribute('data-figma-name'));\n        \n        if (!currentVariant) {\n          console.log('DEBUG: No current variant provided, returning empty array');\n          return [];\n        }\n        \n        const targetElements = targetVariant.querySelectorAll('[data-figma-id]');\n        const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');\n        const sourceElementMap = new Map();\n        const elementsToAnimate = [];\n\n        console.log('DEBUG: Found', targetElements.length, 'target elements and', sourceElements.length, 'source elements');\n\n        // Build source element map by name\n        sourceElements.forEach(function(sourceElement) {\n          const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');\n          if (sourceName) {\n            sourceElementMap.set(sourceName, sourceElement);\n            console.log('  Mapped source element:', sourceName, '->', sourceElement.getAttribute('data-figma-id'));\n          }\n        });\n\n        // Analyze each target element for property changes\n        targetElements.forEach(function(element, index) {\n          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n          const sourceElement = sourceElementMap.get(targetName);\n          \n          console.log('DEBUG: Analyzing target element ' + (index + 1) + ':', targetName);\n          console.log('  Target element ID:', element.getAttribute('data-figma-id'));\n          console.log('  Source element found:', !!sourceElement);\n          \n          if (sourceElement) {\n            console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));\n            const changes = detectPropertyChanges(element, sourceElement);\n            \n            if (changes.hasChanges) {\n              elementsToAnimate.push({\n                element: sourceElement,  // Use SOURCE element (from copy) instead of target\n                sourceElement: sourceElement,\n                changes: changes\n              });\n              console.log('DEBUG: Found element with property changes:', targetName, 'changes:', changes);\n            } else {\n              console.log('DEBUG: No changes detected for element:', targetName);\n            }\n          } else {\n            console.log('DEBUG: No matching source element found for:', targetName);\n          }\n        });\n        \n        console.log('DEBUG: Returning', elementsToAnimate.length, 'elements to animate');\n        return elementsToAnimate;\n      }\n\n      // Helper function to detect property changes between elements\n      function detectPropertyChanges(targetElement, sourceElement) {\n        const changes = {\n          hasChanges: false,\n          positionX: { changed: false, sourceValue: null, targetValue: null },\n          positionY: { changed: false, sourceValue: null, targetValue: null },\n          backgroundColor: { changed: false, sourceValue: null, targetValue: null },\n          color: { changed: false, sourceValue: null, targetValue: null },\n          justifyContent: { changed: false, sourceValue: null, targetValue: null },\n          alignItems: { changed: false, sourceValue: null, targetValue: null }\n        };\n\n        try {\n          // Check position changes by comparing the computed styles\n          const sourceStyle = window.getComputedStyle(sourceElement);\n          const targetStyle = window.getComputedStyle(targetElement);\n          \n          // Check left position changes - use Figma data attributes for more accurate positioning\n          const sourceLeft = parseFloat(sourceStyle.left) || 0;\n          const targetLeft = parseFloat(targetStyle.left) || 0;\n          \n          // Get Figma position data for more accurate target positioning\n          const sourceFigmaX = parseFloat(sourceElement.getAttribute('data-figma-x')) || 0;\n          const targetFigmaX = parseFloat(targetElement.getAttribute('data-figma-x')) || 0;\n          \n          // CRITICAL FIX: Check if the source element has a transform applied from a previous animation\n          // If so, we need to account for that in the position calculation\n          const sourceTransform = sourceStyle.transform;\n          let sourceTransformOffset = 0;\n          if (sourceTransform && sourceTransform !== 'none') {\n            // Extract translateX value from transform matrix\n            const matrix = new DOMMatrix(sourceTransform);\n            sourceTransformOffset = matrix.m41; // m41 is the translateX value\n            console.log('DEBUG: Source element has transform:', sourceTransform, 'translateX offset:', sourceTransformOffset);\n          }\n          \n          // Log detailed information about the elements\n          const sourceName = sourceElement.getAttribute('data-figma-name');\n          const targetName = targetElement.getAttribute('data-figma-name');\n          const sourceId = sourceElement.getAttribute('data-figma-id');\n          const targetId = targetElement.getAttribute('data-figma-id');\n          \n          console.log('DEBUG: Analyzing elements:');\n          console.log('  Source:', sourceName, 'ID:', sourceId, 'Left:', sourceLeft, 'FigmaX:', sourceFigmaX);\n          console.log('  Target:', targetName, 'ID:', targetId, 'Left:', targetLeft, 'FigmaX:', targetFigmaX);\n          \n          // Log parent container dimensions\n          const sourceContainer = sourceElement.closest('[data-figma-type=\"COMPONENT_SET\"], [data-figma-type=\"COMPONENT\"]');\n          const targetContainer = targetElement.closest('[data-figma-type=\"COMPONENT_SET\"], [data-figma-type=\"COMPONENT\"]');\n          \n          if (sourceContainer) {\n            const sourceContainerRect = sourceContainer.getBoundingClientRect();\n            console.log('  Source container dimensions:', sourceContainerRect.width, 'x', sourceContainerRect.height);\n          }\n          \n          if (targetContainer) {\n            const targetContainerRect = targetContainer.getBoundingClientRect();\n            console.log('  Target container dimensions:', targetContainerRect.width, 'x', targetContainerRect.height);\n          }\n          \n          // Log viewport dimensions\n          console.log('  Viewport dimensions:', window.innerWidth, 'x', window.innerHeight);\n          \n          // Log element dimensions\n          const sourceRect = sourceElement.getBoundingClientRect();\n          const targetRect = targetElement.getBoundingClientRect();\n          console.log('  Source element dimensions:', sourceRect.width, 'x', sourceRect.height);\n          console.log('  Target element dimensions:', targetRect.width, 'x', targetRect.height);\n          \n          // Check if target element is properly rendered\n          if (targetRect.width === 0 && targetRect.height === 0) {\n            console.log('DEBUG: Target element has zero dimensions, skipping animation');\n            return changes;\n          }\n          \n          // CRITICAL FIX: Use current computed position for source if element has been animated\n          // This ensures we detect changes from the actual current position, not the original Figma position\n          const sourceHasBeenAnimated = sourceElement.style.position === 'absolute' && \n                                       (sourceElement.style.left || sourceElement.style.top);\n          \n          // Calculate target position by scaling Figma coordinates to actual rendered size\n          // Use SOURCE element's parent (copy) for scaling since we're animating the copy\n          const sourceContainerForScaling = sourceElement.closest('[data-figma-type=\"COMPONENT_SET\"], [data-figma-type=\"COMPONENT\"]');\n          const targetContainerForScaling = sourceElement.closest('[data-figma-type=\"COMPONENT_SET\"], [data-figma-type=\"COMPONENT\"]');\n          \n          let finalTargetLeft = 0; // Start with 0, will be calculated below\n          let finalTargetTop = 0; // Start with 0, will be calculated below\n          // Always use computed styles for consistency\n          let finalSourceLeft = parseFloat(sourceStyle.left) || 0;\n          let finalSourceTop = parseFloat(sourceStyle.top) || 0;\n          \n          // Add transform offset if present\n          finalSourceLeft += sourceTransformOffset;\n          \n          // Check if the source element has a transform applied from a previous animation\n          // If so, we need to account for that in the position calculation\n          let sourceTransformYOffset = 0;\n          if (sourceTransform && sourceTransform !== 'none') {\n            // Extract translateY value from transform matrix\n            const matrix = new DOMMatrix(sourceTransform);\n            sourceTransformYOffset = matrix.m42; // m42 is the translateY value\n            console.log('DEBUG: Source element has transform:', sourceTransform, 'translateY offset:', sourceTransformYOffset);\n          }\n          \n          // Add transform offset if present\n          finalSourceTop += sourceTransformYOffset;\n          \n          // STEP 1-2: Query source and target to observe value differences\n          // Check for alignment/justify differences between source and target parents\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          \n          if (sourceParent && targetParent) {\n            const sourceParentStyle = window.getComputedStyle(sourceParent);\n            const targetParentStyle = window.getComputedStyle(targetParent);\n            \n            const sourceJustifyContent = sourceParentStyle.justifyContent;\n            const targetJustifyContent = targetParentStyle.justifyContent;\n            const sourceAlignItems = sourceParentStyle.alignItems;\n            const targetAlignItems = targetParentStyle.alignItems;\n            \n            console.log('DEBUG: Alignment analysis:', {\n              sourceJustifyContent,\n              targetJustifyContent,\n              sourceAlignItems,\n              targetAlignItems,\n              sourceElementId: sourceElement.getAttribute('data-figma-id'),\n              targetElementId: targetElement.getAttribute('data-figma-id')\n            });\n            \n            // STEP 3: If there's an alignment/justify difference, it's ultimately a position change\n            const hasJustifyChange = sourceJustifyContent !== targetJustifyContent;\n            const hasAlignChange = sourceAlignItems !== targetAlignItems;\n            \n            if (hasJustifyChange || hasAlignChange) {\n              console.log('DEBUG: Alignment/justify change detected - calculating position difference');\n              \n              // STEP 4: Query the corresponding nodes in source and target to find absolute/computed position\n              const sourceRect = sourceElement.getBoundingClientRect();\n              const targetRect = targetElement.getBoundingClientRect();\n              const sourceParentRect = sourceParent.getBoundingClientRect();\n              const targetParentRect = targetParent.getBoundingClientRect();\n              \n              // Calculate relative positions within their containers\n              const sourceRelativeLeft = sourceRect.left - sourceParentRect.left;\n              const targetRelativeLeft = targetRect.left - targetParentRect.left;\n              const sourceRelativeTop = sourceRect.top - sourceParentRect.top;\n              const targetRelativeTop = targetRect.top - targetParentRect.top;\n              \n              console.log('DEBUG: Position analysis:', {\n                sourceRelativeLeft,\n                targetRelativeLeft,\n                sourceRelativeTop,\n                targetRelativeTop,\n                xDifference: Math.abs(sourceRelativeLeft - targetRelativeLeft),\n                yDifference: Math.abs(sourceRelativeTop - targetRelativeTop)\n              });\n              \n              // STEP 5: Calculate position difference\n              const xDifference = targetRelativeLeft - sourceRelativeLeft;\n              const yDifference = targetRelativeTop - sourceRelativeTop;\n              \n              // STEP 6: Set up animation values\n              if (Math.abs(xDifference) > 1) {\n                finalTargetLeft = finalSourceLeft + xDifference;\n                console.log('DEBUG: X position change calculated:', {\n                  sourceLeft: finalSourceLeft,\n                  targetLeft: finalTargetLeft,\n                  difference: xDifference,\n                  justifyChange: hasJustifyChange ? (sourceJustifyContent + ' -> ' + targetJustifyContent) : 'none'\n                });\n              }\n              \n              if (Math.abs(yDifference) > 1) {\n                finalTargetTop = finalSourceTop + yDifference;\n                console.log('DEBUG: Y position change calculated:', {\n                  sourceTop: finalSourceTop,\n                  targetTop: finalTargetTop,\n                  difference: yDifference,\n                  alignChange: hasAlignChange ? (sourceAlignItems + ' -> ' + targetAlignItems) : 'none'\n                });\n              }\n            } else {\n              console.log('DEBUG: No alignment/justify changes detected');\n              // Fallback to direct position comparison if no alignment changes\n              const sourceRect = sourceElement.getBoundingClientRect();\n              const targetRect = targetElement.getBoundingClientRect();\n              const sourceParentRect = sourceParent.getBoundingClientRect();\n              const targetParentRect = targetParent.getBoundingClientRect();\n              \n              const sourceRelativeLeft = sourceRect.left - sourceParentRect.left;\n              const targetRelativeLeft = targetRect.left - targetParentRect.left;\n              const sourceRelativeTop = sourceRect.top - sourceParentRect.top;\n              const targetRelativeTop = targetRect.top - targetParentRect.top;\n              \n              finalTargetLeft = targetRelativeLeft;\n              finalTargetTop = targetRelativeTop;\n            }\n          } else {\n            console.log('DEBUG: No parent elements found, using fallback calculation');\n            finalTargetLeft = parseFloat(targetStyle.left) || 0;\n            finalTargetTop = parseFloat(targetStyle.top) || 0;\n          }\n          \n          console.log('DEBUG: X Position Analysis:');\n          console.log('  Source has been animated:', sourceHasBeenAnimated);\n          console.log('  Source computed left:', sourceLeft, 'Source Figma X:', sourceFigmaX, 'Transform offset:', sourceTransformOffset, 'Final source left:', finalSourceLeft);\n          console.log('  Target computed left:', targetLeft, 'Target Figma X:', targetFigmaX, 'Final target left:', finalTargetLeft);\n          \n          if (Math.abs(finalSourceLeft - finalTargetLeft) > 1) {\n            changes.positionX.changed = true;\n            changes.positionX.sourceValue = finalSourceLeft;\n            changes.positionX.targetValue = finalTargetLeft;\n            changes.hasChanges = true;\n            console.log('DEBUG: Position X change detected:', finalSourceLeft, '->', finalTargetLeft, '(scaled from Figma coordinates)');\n            console.log('DEBUG: Position X change details:');\n            console.log('  Source element rect:', sourceElement.getBoundingClientRect());\n            console.log('  Target element rect:', targetElement.getBoundingClientRect());\n            console.log('  Source element computed style:', window.getComputedStyle(sourceElement).left);\n            console.log('  Target element computed style:', window.getComputedStyle(targetElement).left);\n          } else {\n            console.log('DEBUG: No X position change detected - difference:', Math.abs(finalSourceLeft - finalTargetLeft));\n          }\n          \n          // Y position calculation is now handled in the X position section above\n          // where we calculate both X and Y positions together based on alignment changes\n          \n          console.log('DEBUG: Y Position Analysis:');\n          console.log('  Final source top:', finalSourceTop);\n          console.log('  Final target top:', finalTargetTop);\n          console.log('  Difference:', Math.abs(finalSourceTop - finalTargetTop));\n          \n          if (Math.abs(finalSourceTop - finalTargetTop) > 1) {\n            changes.positionY.changed = true;\n            changes.positionY.sourceValue = finalSourceTop;\n            changes.positionY.targetValue = finalTargetTop;\n            changes.hasChanges = true;\n            console.log('DEBUG: Position Y change detected:', finalSourceTop, '->', finalTargetTop);\n          } else {\n            console.log('DEBUG: No Y position change detected - difference:', Math.abs(finalSourceTop - finalTargetTop));\n          }\n\n          // Check style changes - use more specific comparison\n          const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';\n          const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';\n          \n          if (sourceBg !== targetBg) {\n            changes.backgroundColor.changed = true;\n            changes.backgroundColor.sourceValue = sourceBg;\n            changes.backgroundColor.targetValue = targetBg;\n            changes.hasChanges = true;\n            console.log('DEBUG: Background color change detected:', sourceBg, '->', targetBg);\n          }\n          \n          if (sourceStyle.color !== targetStyle.color) {\n            changes.color.changed = true;\n            changes.color.sourceValue = sourceStyle.color;\n            changes.color.targetValue = targetStyle.color;\n            changes.hasChanges = true;\n            console.log('DEBUG: Color change detected:', sourceStyle.color, '->', targetStyle.color);\n          }\n          \n          if (sourceStyle.justifyContent !== targetStyle.justifyContent) {\n            changes.justifyContent.changed = true;\n            changes.justifyContent.sourceValue = sourceStyle.justifyContent;\n            changes.justifyContent.targetValue = targetStyle.justifyContent;\n            changes.hasChanges = true;\n          }\n          \n          if (sourceStyle.alignItems !== targetStyle.alignItems) {\n            changes.alignItems.changed = true;\n            changes.alignItems.sourceValue = sourceStyle.alignItems;\n            changes.alignItems.targetValue = targetStyle.alignItems;\n            changes.hasChanges = true;\n          }\n        } catch (error) {\n          console.log('DEBUG: Error detecting property changes:', error);\n        }\n\n        return changes;\n      }\n  ";
}


/***/ }),

/***/ 120:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createVariantSwitchingHandler = createVariantSwitchingHandler;
// Variant switching handler - instant switching only, no animation
function createVariantSwitchingHandler() {
    return "\n      // Handle variant switching - instant switching only, no animation\n      // This is a simple slideshow-like system that switches between variants instantly\n      const variantButtons = document.querySelectorAll('[data-variant], [data-variant-property-1]');\n      variantButtons.forEach(button => {\n        button.addEventListener('click', function() {\n          console.log('DEBUG: Variant switch clicked');\n          \n          const variant = this.getAttribute('data-variant') || this.getAttribute('data-variant-property-1');\n          const targetId = this.getAttribute('data-target');\n          \n          if (targetId) {\n            const target = document.querySelector(`[data-figma-id=\"${targetId}\"]`);\n            if (target) {\n              console.log('Variant switch:', { variant, targetId, targetName: target.getAttribute('data-figma-name') });\n              \n              // Find the specific component set that contains this button\n              let componentSet = target;\n              let buttonElement = this;\n              \n              // Walk up the DOM tree to find the immediate component set parent\n              while (buttonElement && buttonElement.parentElement) {\n                buttonElement = buttonElement.parentElement;\n                if (buttonElement.getAttribute('data-figma-type') === 'COMPONENT_SET') {\n                  componentSet = buttonElement;\n                  console.log('Found component set for switching:', {\n                    id: componentSet.getAttribute('data-figma-id'),\n                    name: componentSet.getAttribute('data-figma-name')\n                  });\n                  break;\n                }\n              }\n              \n              // Get all variants within this specific component set instance\n              const allVariants = Array.from(componentSet.children).filter(child => \n                child.getAttribute('data-figma-type') === 'COMPONENT' &&\n                (child.getAttribute('data-variant') || child.getAttribute('data-variant-property-1'))\n              );\n              \n              console.log('Found', allVariants.length, 'variants in component set:', componentSet.getAttribute('data-figma-id'));\n              \n              // INSTANT VARIANT SWITCHING - Hide all variants\n              allVariants.forEach(variant => {\n                variant.classList.add('variant-hidden');\n                variant.classList.remove('variant-active');\n                // Ensure all variants maintain their original positioning (relative with 0px)\n                variant.style.position = 'relative';\n                variant.style.top = '0px';\n                variant.style.left = '0px';\n                console.log('Hidden variant:', variant.getAttribute('data-figma-id'));\n              });\n              \n              // Show selected variant instantly\n              const selectedVariant = allVariants.find(v => \n                v.getAttribute('data-variant') === variant || \n                v.getAttribute('data-variant-property-1') === variant\n              );\n              \n              if (selectedVariant) {\n                selectedVariant.classList.add('variant-active');\n                selectedVariant.classList.remove('variant-hidden');\n                // Ensure selected variant maintains its original positioning\n                selectedVariant.style.position = 'relative';\n                selectedVariant.style.top = '0px';\n                selectedVariant.style.left = '0px';\n                console.log('Switched to variant:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));\n                \n                // Start timeout reactions for the newly active variant\n                startTimeoutReactionsForNewlyActiveVariant(selectedVariant);\n                startTimeoutReactionsForNestedComponents(selectedVariant);\n              } else {\n                console.log('Selected variant not found:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));\n              }\n            }\n          }\n        });\n      });\n  ";
}


/***/ }),

/***/ 172:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEasingFunction = exports.applyAnimationChange = exports.createAnimationContext = exports.detectAnimationChanges = exports.getTranslationCondition = exports.getAnimationType = exports.TranslationCondition = exports.AnimationType = exports.createComponentSetInitializer = exports.createModularSmartAnimateHandler = exports.createPropertyDetector = exports.createTimeoutHandler = exports.createReactionHandler = exports.createVariantSwitchingHandler = exports.generateVariantAttributes = exports.generateReactionAttributes = void 0;
exports.generateEventHandlingJavaScript = generateEventHandlingJavaScript;
exports.generateExternalScriptReference = generateExternalScriptReference;
// Re-export all event functions
var attributes_1 = __webpack_require__(275);
Object.defineProperty(exports, "generateReactionAttributes", ({ enumerable: true, get: function () { return attributes_1.generateReactionAttributes; } }));
Object.defineProperty(exports, "generateVariantAttributes", ({ enumerable: true, get: function () { return attributes_1.generateVariantAttributes; } }));
var variant_handler_1 = __webpack_require__(120);
Object.defineProperty(exports, "createVariantSwitchingHandler", ({ enumerable: true, get: function () { return variant_handler_1.createVariantSwitchingHandler; } }));
var reaction_handler_1 = __webpack_require__(332);
Object.defineProperty(exports, "createReactionHandler", ({ enumerable: true, get: function () { return reaction_handler_1.createReactionHandler; } }));
Object.defineProperty(exports, "createTimeoutHandler", ({ enumerable: true, get: function () { return reaction_handler_1.createTimeoutHandler; } }));
var property_detector_1 = __webpack_require__(82);
Object.defineProperty(exports, "createPropertyDetector", ({ enumerable: true, get: function () { return property_detector_1.createPropertyDetector; } }));
// export { createSmartAnimateHandler } from './transition-handler';
var modular_transition_handler_1 = __webpack_require__(821);
Object.defineProperty(exports, "createModularSmartAnimateHandler", ({ enumerable: true, get: function () { return modular_transition_handler_1.createModularSmartAnimateHandler; } }));
var initializer_1 = __webpack_require__(44);
Object.defineProperty(exports, "createComponentSetInitializer", ({ enumerable: true, get: function () { return initializer_1.createComponentSetInitializer; } }));
// Export animation system types and functions
var animation_system_1 = __webpack_require__(286);
Object.defineProperty(exports, "AnimationType", ({ enumerable: true, get: function () { return animation_system_1.AnimationType; } }));
Object.defineProperty(exports, "TranslationCondition", ({ enumerable: true, get: function () { return animation_system_1.TranslationCondition; } }));
Object.defineProperty(exports, "getAnimationType", ({ enumerable: true, get: function () { return animation_system_1.getAnimationType; } }));
Object.defineProperty(exports, "getTranslationCondition", ({ enumerable: true, get: function () { return animation_system_1.getTranslationCondition; } }));
Object.defineProperty(exports, "detectAnimationChanges", ({ enumerable: true, get: function () { return animation_system_1.detectAnimationChanges; } }));
Object.defineProperty(exports, "createAnimationContext", ({ enumerable: true, get: function () { return animation_system_1.createAnimationContext; } }));
Object.defineProperty(exports, "applyAnimationChange", ({ enumerable: true, get: function () { return animation_system_1.applyAnimationChange; } }));
Object.defineProperty(exports, "getEasingFunction", ({ enumerable: true, get: function () { return animation_system_1.getEasingFunction; } }));
// Main event handling JavaScript generator
function generateEventHandlingJavaScript() {
    return "\n    // Reference the external refactored-system.js file\n    // This file contains all the animation and event handling logic\n    console.log('DEBUG: Event handling JavaScript loaded');\n    \n    // Global function for testing event handlers\n    window.handleFigmaEvent = function(eventType, elementId) {\n      console.log('DEBUG: Manual event trigger:', eventType, elementId);\n      const element = document.querySelector(`[data-figma-id=\"${elementId}\"]`);\n      if (element) {\n        if (eventType === 'click') {\n          element.click();\n        } else if (eventType === 'variant-switch') {\n          const variantButton = element.querySelector('[data-variant], [data-variant-property-1]');\n          if (variantButton) {\n            variantButton.click();\n          }\n        }\n      }\n    };\n    \n    // Global timer tracking\n    const activeTimers = new Map();\n    \n    // Function to start timeout reactions for nested components within a parent element\n    function startTimeoutReactionsForNestedComponents(parentElement) {\n      if (!parentElement) return;\n      \n      // Find all nested components with timeout reactions within the parent\n      const nestedComponents = parentElement.querySelectorAll('[data-has-reactions=\"true\"]');\n      \n      nestedComponents.forEach(element => {\n        const elementId = element.getAttribute('data-figma-id');\n        const elementName = element.getAttribute('data-figma-name');\n        const computedStyle = window.getComputedStyle(element);\n        \n        // Only start timers for elements that are actually visible\n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n          \n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId);\n              const actionType = element.getAttribute('data-reaction-action-type');\n              const destinationId = element.getAttribute('data-reaction-destination');\n              const transitionType = element.getAttribute('data-reaction-transition-type');\n              const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n              \n              if (window.handleReaction) {\n                window.handleReaction(element, destinationId, transitionType, transitionDuration);\n              } else {\n                console.error('DEBUG: handleReaction function not found in external script');\n              }\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n          } else if (activeTimers.has(elementId)) {\n            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');\n          }\n        } else {\n          console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');\n        }\n      });\n    }\n    \n    // Function to start timeout reactions for a specific newly active variant\n    function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {\n      if (!newlyActiveElement) return;\n      \n      const elementId = newlyActiveElement.getAttribute('data-figma-id');\n      const elementName = newlyActiveElement.getAttribute('data-figma-name');\n      const parentComponent = newlyActiveElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n      const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n      \n      console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);\n      \n      // Only start timers for variants that are actually visible (not hidden by CSS)\n      const computedStyle = window.getComputedStyle(newlyActiveElement);\n      \n      if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n        const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');\n        const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');\n        const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');\n        const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');\n        const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');\n        \n        // Handle timeout reactions only for active variants that don't have an active timer\n        if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n          console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n          const timeoutId = setTimeout(() => {\n            activeTimers.delete(elementId); // Clear the timer when it completes\n            if (window.handleReaction) {\n              window.handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);\n            } else {\n              console.error('DEBUG: handleReaction function not found in external script');\n            }\n          }, (trigger.timeout || 0) * 1000);\n          activeTimers.set(elementId, timeoutId);\n        } else if (activeTimers.has(elementId)) {\n          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');\n        }\n        \n        // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant\n        startTimeoutReactionsForNestedComponents(newlyActiveElement);\n      } else {\n        console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n      }\n    }\n    \n    // Function to start timeout reactions for the initial visible variant\n    function startTimeoutReactionsForInitialVariant() {\n      // Find the first visible variant that should start the flow\n      const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"]');\n      console.log('DEBUG: Found', componentSets.length, 'component sets');\n      \n      // Also check for any elements with reactions\n      const allReactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n      console.log('DEBUG: Found', allReactionElements.length, 'total elements with reactions');\n      \n      // Log details about reaction elements\n      allReactionElements.forEach((element, index) => {\n        const elementId = element.getAttribute('data-figma-id');\n        const elementName = element.getAttribute('data-figma-name');\n        const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n        const computedStyle = window.getComputedStyle(element);\n        \n        console.log('DEBUG: Reaction element', index + 1, ':', {\n          id: elementId,\n          name: elementName,\n          trigger: trigger,\n          display: computedStyle.display,\n          visibility: computedStyle.visibility,\n          isActive: element.classList.contains('variant-active'),\n          isHidden: element.classList.contains('variant-hidden')\n        });\n      });\n      \n      componentSets.forEach(componentSet => {\n        const componentSetName = componentSet.getAttribute('data-figma-name');\n        const activeVariants = componentSet.querySelectorAll('.variant-active[data-has-reactions=\"true\"]');\n        console.log('DEBUG: Component set', componentSetName, 'has', activeVariants.length, 'active variants with reactions');\n        \n        // Only start timers for the first active variant in each component set\n        if (activeVariants.length > 0) {\n          const firstActiveVariant = activeVariants[0];\n          const elementId = firstActiveVariant.getAttribute('data-figma-id');\n          const elementName = firstActiveVariant.getAttribute('data-figma-name');\n          const computedStyle = window.getComputedStyle(firstActiveVariant);\n          \n          console.log('DEBUG: Processing initial variant:', elementId, 'name:', elementName, 'in component set:', componentSetName);\n          \n          // Only start timer if the variant is actually visible\n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(firstActiveVariant.getAttribute('data-reaction-trigger') || '{}');\n            \n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting initial timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);\n              \n              const timeoutId = setTimeout(() => {\n                console.log('DEBUG: Timeout triggered for element:', elementId, 'name:', elementName);\n                activeTimers.delete(elementId);\n                const actionType = firstActiveVariant.getAttribute('data-reaction-action-type');\n                const destinationId = firstActiveVariant.getAttribute('data-reaction-destination');\n                const transitionType = firstActiveVariant.getAttribute('data-reaction-transition-type');\n                const transitionDuration = firstActiveVariant.getAttribute('data-reaction-transition-duration');\n                \n                console.log('DEBUG: Calling handleReaction with:', {\n                  destinationId: destinationId,\n                  transitionType: transitionType,\n                  transitionDuration: transitionDuration\n                });\n                \n                // Call the handleReaction function from the external refactored-system.js\n                if (window.handleReaction) {\n                  window.handleReaction(firstActiveVariant, destinationId, transitionType, transitionDuration);\n                } else {\n                  console.error('DEBUG: handleReaction function not found in external script');\n                }\n              }, (trigger.timeout || 0) * 1000);\n              \n              activeTimers.set(elementId, timeoutId);\n              console.log('DEBUG: Created timeout timer for element:', elementId, 'timeout ID:', timeoutId, 'duration:', (trigger.timeout || 0) * 1000, 'ms');\n            } else {\n              console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n            }\n            \n            // CRITICAL FIX: Also start timeout reactions for any nested components within this initial variant\n            startTimeoutReactionsForNestedComponents(firstActiveVariant);\n          } else {\n            console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n          }\n        }\n      });\n      \n      // Also check for any non-variant elements with reactions\n      const nonVariantReactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]:not([data-figma-type=\"COMPONENT\"])');\n      nonVariantReactionElements.forEach(element => {\n        const elementId = element.getAttribute('data-figma-id');\n        const elementName = element.getAttribute('data-figma-name');\n        const computedStyle = window.getComputedStyle(element);\n        \n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n          \n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for initial non-variant element:', elementId, 'name:', elementName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId);\n              const actionType = element.getAttribute('data-reaction-action-type');\n              const destinationId = element.getAttribute('data-reaction-destination');\n              const transitionType = element.getAttribute('data-reaction-transition-type');\n              const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n              \n              if (window.handleReaction) {\n                window.handleReaction(element, destinationId, transitionType, transitionDuration);\n              } else {\n                console.error('DEBUG: handleReaction function not found in external script');\n              }\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n            \n            // CRITICAL FIX: Also start timeout reactions for any nested components within this element\n            startTimeoutReactionsForNestedComponents(element);\n          } else {\n            console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n          }\n        } else {\n          console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- not visible');\n        }\n      });\n    }\n    \n    document.addEventListener('DOMContentLoaded', function() {\n      console.log('DEBUG: DOMContentLoaded event fired');\n      console.log('DEBUG: Using external refactored-system.js file');\n      console.log('DEBUG: Starting component set initialization...');\n      \n      // Initialize component sets\n      const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"]');\n      console.log('DEBUG: Found', componentSets.length, 'component sets');\n      console.log('DEBUG: Component sets found:', Array.from(componentSets).map(cs => cs.getAttribute('data-figma-name')));\n      \n      componentSets.forEach(componentSet => {\n        const componentSetId = componentSet.getAttribute('data-figma-id');\n        const componentSetName = componentSet.getAttribute('data-figma-name');\n        const componentSetType = componentSet.getAttribute('data-figma-type');\n        const parentType = componentSet.parentElement ? componentSet.parentElement.getAttribute('data-figma-type') : 'NONE';\n        const parentId = componentSet.parentElement ? componentSet.parentElement.getAttribute('data-figma-id') : 'NONE';\n        \n        console.log('Initializing component set/instance with', componentSet.children.length, 'variants:', {\n          componentSetId: componentSetId,\n          componentSetName: componentSetName,\n          componentSetType: componentSetType,\n          parentType: parentType,\n          parentId: parentId\n        });\n        \n        // Get all variants (COMPONENT elements)\n        const variants = Array.from(componentSet.children).filter(child => \n          child.getAttribute('data-figma-type') === 'COMPONENT'\n        );\n        \n        if (variants.length > 0) {\n          // Set first variant as active\n          const firstVariant = variants[0];\n          const firstVariantId = firstVariant.getAttribute('data-figma-id');\n          console.log('Set first variant as active (with reactions):', firstVariantId, 'in component set:', componentSetId);\n          firstVariant.classList.add('variant-active');\n          firstVariant.classList.remove('variant-hidden');\n          \n          // Hide all other variants\n          variants.slice(1).forEach(variant => {\n            const variantId = variant.getAttribute('data-figma-id');\n            console.log('Set variant as hidden:', variantId, 'in component set:', componentSetId);\n            variant.classList.add('variant-hidden');\n            variant.classList.remove('variant-active');\n          });\n        }\n      });\n      \n      // Start timeout reactions after a short delay\n      setTimeout(() => {\n        console.log('DEBUG: Starting initial timeout reactions');\n        startTimeoutReactionsForInitialVariant();\n      }, 100);\n    });\n  ";
}
// Generate script tag that references the external file
function generateExternalScriptReference() {
    return "<script src=\"refactored-system.js\"></script>";
}


/***/ }),

/***/ 275:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateReactionAttributes = generateReactionAttributes;
exports.generateVariantAttributes = generateVariantAttributes;
var utils_1 = __webpack_require__(489);
// Event attribute generation
function generateReactionAttributes(node) {
    var attributes = {};
    if ((0, utils_1.safeHasProperty)(node, 'reactions') && node.reactions && node.reactions.length > 0) {
        var reactions = node.reactions;
        var firstReaction = reactions[0];
        if (firstReaction) {
            attributes['data-has-reactions'] = 'true';
            attributes['data-reaction-count'] = String(reactions.length);
            if (firstReaction.trigger) {
                attributes['data-reaction-trigger'] = (0, utils_1.escapeHtmlAttribute)(JSON.stringify(firstReaction.trigger));
            }
            // Check both action and actions fields
            var actionToUse = null;
            if (firstReaction.action) {
                actionToUse = firstReaction.action;
            }
            else if (firstReaction.actions && firstReaction.actions.length > 0) {
                actionToUse = firstReaction.actions[0];
            }
            if (actionToUse && actionToUse.type) {
                attributes['data-reaction-action-type'] = actionToUse.type;
                if (actionToUse.destinationId) {
                    attributes['data-reaction-destination'] = actionToUse.destinationId;
                }
                // Extract transition data from the action
                if (actionToUse.transition && actionToUse.transition.type) {
                    // Use the easing type from the transition if available, otherwise use the transition type
                    var transitionType = actionToUse.transition.type;
                    if (actionToUse.transition.easing && actionToUse.transition.easing.type) {
                        var easingType = actionToUse.transition.easing.type;
                        // Preserve the original easing type instead of mapping to BOUNCY
                        transitionType = easingType;
                    }
                    attributes['data-reaction-transition-type'] = transitionType;
                    if (actionToUse.transition.duration) {
                        attributes['data-reaction-transition-duration'] = String(actionToUse.transition.duration);
                    }
                }
            }
        }
    }
    return attributes;
}
function generateVariantAttributes(node, parentNode) {
    var attributes = {};
    if ((0, utils_1.safeHasProperty)(node, 'variantProperties') && node.variantProperties) {
        var variantProps = node.variantProperties;
        Object.entries(variantProps).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            var cleanKey = key.toLowerCase().replace(/\s+/g, '-');
            attributes["data-variant-".concat(cleanKey)] = (0, utils_1.escapeHtmlAttribute)((0, utils_1.safeToString)(value));
        });
        // Add data-target attribute to point to the immediate parent component set
        // This allows variant buttons to know which component set to target for switching
        // For nested components, this will point to their immediate parent, not the top-level
        if (parentNode && (parentNode.type === 'COMPONENT_SET' || parentNode.type === 'COMPONENT')) {
            attributes['data-target'] = parentNode.id;
        }
    }
    return attributes;
}


/***/ }),

/***/ 286:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TranslationCondition = exports.AnimationType = void 0;
exports.getAnimationType = getAnimationType;
exports.getTranslationCondition = getTranslationCondition;
exports.detectAnimationChanges = detectAnimationChanges;
exports.createAnimationContext = createAnimationContext;
exports.applyAnimationChange = applyAnimationChange;
exports.getEasingFunction = getEasingFunction;
// Animation types as defined by the user
var AnimationType;
(function (AnimationType) {
    AnimationType["SIMPLE"] = "SIMPLE";
    AnimationType["SIZE"] = "SIZE";
    AnimationType["TRANSFORM"] = "TRANSFORM"; // translate, rotation, scale - affects parent/children layout
})(AnimationType || (exports.AnimationType = AnimationType = {}));
// Translation conditions as defined by the user
var TranslationCondition;
(function (TranslationCondition) {
    TranslationCondition["ABSOLUTE"] = "ABSOLUTE";
    TranslationCondition["RELATIVE_PADDING"] = "RELATIVE_PADDING";
    TranslationCondition["RELATIVE_ALIGNMENT"] = "RELATIVE_ALIGNMENT"; // change alignment between variants
})(TranslationCondition || (exports.TranslationCondition = TranslationCondition = {}));
/**
 * Determines the animation type for a given property
 */
function getAnimationType(property) {
    // Simple properties that don't affect layout
    var simpleProperties = [
        'opacity', 'color', 'backgroundColor', 'cornerRadius', 'borderRadius',
        'fontSize', 'fontWeight', 'textAlign', 'letterSpacing', 'lineHeight'
    ];
    // Size properties that affect layout
    var sizeProperties = [
        'width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'
    ];
    // Transform properties that have intimate relationships with parent/children
    var transformProperties = [
        'translateX', 'translateY', 'translateZ', 'rotation', 'scale', 'transform'
    ];
    if (simpleProperties.includes(property)) {
        return AnimationType.SIMPLE;
    }
    else if (sizeProperties.includes(property)) {
        return AnimationType.SIZE;
    }
    else if (transformProperties.includes(property)) {
        return AnimationType.TRANSFORM;
    }
    // Default to simple for unknown properties
    return AnimationType.SIMPLE;
}
/**
 * Determines the translation condition for an element
 */
function getTranslationCondition(element, node, parentNode) {
    // Check if element has ignore auto-layout enabled
    var ignoreAutoLayout = node.layoutPositioning === 'ABSOLUTE';
    // Check if parent has auto-layout
    var parentHasAutoLayout = parentNode &&
        parentNode.type === 'FRAME' &&
        parentNode.layoutMode &&
        parentNode.layoutMode !== 'NONE';
    // Condition 1: Absolute positioning
    if (ignoreAutoLayout || !parentHasAutoLayout) {
        return TranslationCondition.ABSOLUTE;
    }
    // Condition 2: Relative by padding (if parent has auto-layout and padding changes)
    if (parentHasAutoLayout) {
        // Check if padding values differ between variants
        // This would be detected during change detection
        return TranslationCondition.RELATIVE_PADDING;
    }
    // Condition 3: Relative by alignment (if parent has auto-layout and alignment changes)
    if (parentHasAutoLayout) {
        // Check if alignment values differ between variants
        // This would be detected during change detection
        return TranslationCondition.RELATIVE_ALIGNMENT;
    }
    // Default to absolute
    return TranslationCondition.ABSOLUTE;
}
/**
 * Detects animation changes between source and target elements
 */
function detectAnimationChanges(sourceElement, targetElement, sourceNode, targetNode, parentNode) {
    var changes = [];
    // Get computed styles for comparison
    var sourceStyle = window.getComputedStyle(sourceElement);
    var targetStyle = window.getComputedStyle(targetElement);
    // Check simple properties
    var simpleProperties = ['opacity', 'backgroundColor', 'color'];
    simpleProperties.forEach(function (property) {
        var sourceValue = sourceStyle[property];
        var targetValue = targetStyle[property];
        if (sourceValue !== targetValue) {
            changes.push({
                type: AnimationType.SIMPLE,
                property: property,
                sourceValue: sourceValue,
                targetValue: targetValue,
                changed: true
            });
        }
    });
    // Check size properties
    var sizeProperties = ['width', 'height'];
    sizeProperties.forEach(function (property) {
        var sourceValue = parseFloat(sourceStyle[property]) || 0;
        var targetValue = parseFloat(targetStyle[property]) || 0;
        if (Math.abs(sourceValue - targetValue) > 1) {
            changes.push({
                type: AnimationType.SIZE,
                property: property,
                sourceValue: sourceValue,
                targetValue: targetValue,
                changed: true
            });
        }
    });
    // Check transform properties (translation)
    var translationCondition = getTranslationCondition(sourceElement, sourceNode, parentNode);
    // Check position changes based on translation condition
    if (translationCondition === TranslationCondition.ABSOLUTE) {
        // For absolute positioning, check left/top changes
        var sourceLeft = parseFloat(sourceStyle.left) || 0;
        var targetLeft = parseFloat(targetStyle.left) || 0;
        var sourceTop = parseFloat(sourceStyle.top) || 0;
        var targetTop = parseFloat(targetStyle.top) || 0;
        if (Math.abs(sourceLeft - targetLeft) > 1) {
            changes.push({
                type: AnimationType.TRANSFORM,
                property: 'translateX',
                sourceValue: sourceLeft,
                targetValue: targetLeft,
                changed: true,
                translationCondition: translationCondition
            });
        }
        if (Math.abs(sourceTop - targetTop) > 1) {
            changes.push({
                type: AnimationType.TRANSFORM,
                property: 'translateY',
                sourceValue: sourceTop,
                targetValue: targetTop,
                changed: true,
                translationCondition: translationCondition
            });
        }
    }
    else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {
        // For relative padding, check if parent padding changes
        var sourceParent = sourceElement.parentElement;
        var targetParent = targetElement.parentElement;
        if (sourceParent && targetParent) {
            var sourceParentStyle_1 = window.getComputedStyle(sourceParent);
            var targetParentStyle_1 = window.getComputedStyle(targetParent);
            var paddingProperties = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'];
            paddingProperties.forEach(function (property) {
                var sourceValue = parseFloat(sourceParentStyle_1[property]) || 0;
                var targetValue = parseFloat(targetParentStyle_1[property]) || 0;
                if (Math.abs(sourceValue - targetValue) > 1) {
                    changes.push({
                        type: AnimationType.TRANSFORM,
                        property: "parent_".concat(property),
                        sourceValue: sourceValue,
                        targetValue: targetValue,
                        changed: true,
                        translationCondition: translationCondition
                    });
                }
            });
        }
    }
    else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {
        // For relative alignment, check if parent alignment changes
        var sourceParent = sourceElement.parentElement;
        var targetParent = targetElement.parentElement;
        if (sourceParent && targetParent) {
            var sourceParentStyle_2 = window.getComputedStyle(sourceParent);
            var targetParentStyle_2 = window.getComputedStyle(targetParent);
            // Check both parent and element alignment properties
            var alignmentProperties = ['justifyContent', 'alignItems', 'textAlign', 'verticalAlign'];
            // Check parent alignment changes
            alignmentProperties.forEach(function (property) {
                var sourceValue = sourceParentStyle_2[property];
                var targetValue = targetParentStyle_2[property];
                // console.log(`DEBUG: Checking parent ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });
                if (sourceValue !== targetValue) {
                    changes.push({
                        type: AnimationType.TRANSFORM,
                        property: 'parent_' + property,
                        sourceValue: sourceValue,
                        targetValue: targetValue,
                        changed: true,
                        translationCondition: translationCondition
                    });
                }
            });
            // Check element's own alignment properties
            alignmentProperties.forEach(function (property) {
                var sourceValue = sourceStyle[property];
                var targetValue = targetStyle[property];
                // console.log(`DEBUG: Checking element ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });
                if (sourceValue !== targetValue) {
                    changes.push({
                        type: AnimationType.TRANSFORM,
                        property: property,
                        sourceValue: sourceValue,
                        targetValue: targetValue,
                        changed: true,
                        translationCondition: translationCondition
                    });
                }
            });
            // Check for flexbox-specific properties
            var flexProperties = ['flexDirection', 'flexWrap', 'alignContent', 'justifyItems'];
            flexProperties.forEach(function (property) {
                var sourceValue = sourceParentStyle_2[property];
                var targetValue = targetParentStyle_2[property];
                // console.log(`DEBUG: Checking flex ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });
                if (sourceValue !== targetValue) {
                    changes.push({
                        type: AnimationType.TRANSFORM,
                        property: 'parent_' + property,
                        sourceValue: sourceValue,
                        targetValue: targetValue,
                        changed: true,
                        translationCondition: translationCondition
                    });
                }
            });
            // Check for position changes that might be due to alignment
            // Even if alignment values are the same, the computed position might differ
            var sourceRect = sourceElement.getBoundingClientRect();
            var targetRect = targetElement.getBoundingClientRect();
            var sourceParentRect = sourceParent.getBoundingClientRect();
            var targetParentRect = targetParent.getBoundingClientRect();
            // Calculate relative positions within their containers
            var sourceRelativeX = sourceRect.left - sourceParentRect.left;
            var targetRelativeX = targetRect.left - targetParentRect.left;
            var sourceRelativeY = sourceRect.top - sourceParentRect.top;
            var targetRelativeY = targetRect.top - targetParentRect.top;
            // If there's a significant position difference, it might be due to alignment
            if (Math.abs(sourceRelativeX - targetRelativeX) > 1) {
                changes.push({
                    type: AnimationType.TRANSFORM,
                    property: 'alignTranslateX',
                    sourceValue: sourceRelativeX,
                    targetValue: targetRelativeX,
                    changed: true,
                    translationCondition: translationCondition
                });
            }
            if (Math.abs(sourceRelativeY - targetRelativeY) > 1) {
                changes.push({
                    type: AnimationType.TRANSFORM,
                    property: 'alignTranslateY',
                    sourceValue: sourceRelativeY,
                    targetValue: targetRelativeY,
                    changed: true,
                    translationCondition: translationCondition
                });
            }
        }
    }
    return changes;
}
/**
 * Creates animation context for an element
 */
function createAnimationContext(element, node, parentNode) {
    return {
        element: element,
        node: node,
        parentNode: parentNode,
        changes: []
    };
}
/**
 * Applies animation changes to an element based on its type and condition
 */
function applyAnimationChange(element, change, duration, easing) {
    var type = change.type, property = change.property, targetValue = change.targetValue, translationCondition = change.translationCondition;
    // Set up transition
    var transitionProperty = getTransitionProperty(property, type, translationCondition);
    element.style.transition = "".concat(transitionProperty, " ").concat(duration, "s ").concat(easing);
    // Apply the change based on type and condition
    switch (type) {
        case AnimationType.SIMPLE:
            applySimpleAnimation(element, property, targetValue);
            break;
        case AnimationType.SIZE:
            applySizeAnimation(element, property, targetValue);
            break;
        case AnimationType.TRANSFORM:
            applyTransformAnimation(element, property, targetValue, translationCondition);
            break;
    }
}
/**
 * Gets the appropriate CSS transition property for an animation
 */
function getTransitionProperty(property, type, translationCondition) {
    switch (type) {
        case AnimationType.SIMPLE:
            return property;
        case AnimationType.SIZE:
            return property;
        case AnimationType.TRANSFORM:
            if (translationCondition === TranslationCondition.ABSOLUTE) {
                return property === 'translateX' ? 'left' : 'top';
            }
            else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {
                return property.replace('parent_', '');
            }
            else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {
                return property.replace('parent_', '');
            }
            return 'transform';
    }
}
/**
 * Applies simple animations (opacity, color, etc.)
 */
function applySimpleAnimation(element, property, targetValue) {
    element.style[property] = targetValue;
}
/**
 * Applies size animations (width, height)
 */
function applySizeAnimation(element, property, targetValue) {
    element.style[property] = "".concat(targetValue, "px");
}
/**
 * Applies transform animations based on translation condition
 */
function applyTransformAnimation(element, property, targetValue, translationCondition) {
    switch (translationCondition) {
        case TranslationCondition.ABSOLUTE:
            // Use direct positioning
            if (property === 'translateX') {
                element.style.left = "".concat(targetValue, "px");
            }
            else if (property === 'translateY') {
                element.style.top = "".concat(targetValue, "px");
            }
            break;
        case TranslationCondition.RELATIVE_PADDING:
            // Apply padding to parent
            if (element.parentElement) {
                var paddingProperty = property.replace('parent_', '');
                element.parentElement.style[paddingProperty] = "".concat(targetValue, "px");
            }
            break;
        case TranslationCondition.RELATIVE_ALIGNMENT:
            // Apply alignment to parent
            if (element.parentElement) {
                var alignmentProperty = property.replace('parent_', '');
                element.parentElement.style[alignmentProperty] = targetValue;
            }
            break;
        default:
            // Fallback to transform
            if (property === 'translateX') {
                element.style.transform = "translateX(".concat(targetValue, "px)");
            }
            else if (property === 'translateY') {
                element.style.transform = "translateY(".concat(targetValue, "px)");
            }
            break;
    }
}
/**
 * Maps Figma animation types to CSS easing functions
 */
function getEasingFunction(animationType) {
    switch (animationType) {
        case 'EASE_IN_AND_OUT_BACK':
            return 'ease-in-out'; // Use standard ease-in-out to eliminate back effect
        case 'EASE_IN_AND_OUT':
            return 'ease-in-out';
        case 'EASE_IN':
            return 'ease-in';
        case 'EASE_OUT':
            return 'ease-out';
        case 'LINEAR':
            return 'linear';
        case 'BOUNCY':
            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)'; // Bouncy curve
        case 'GENTLE':
            return 'ease-in-out';
        case 'SMART_ANIMATE':
            return 'ease-in-out';
        default:
            return 'ease-out';
    }
}


/***/ }),

/***/ 332:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReactionHandler = createReactionHandler;
exports.createTimeoutHandler = createTimeoutHandler;
// Reaction handling and timeout management
function createReactionHandler() {
    return "\n      // Handle reactions - click, press, and drag\n      const reactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n      reactionElements.forEach(element => {\n        const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n        const actionType = element.getAttribute('data-reaction-action-type');\n        const destinationId = element.getAttribute('data-reaction-destination');\n        const transitionType = element.getAttribute('data-reaction-transition-type');\n        const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n        \n        // Handle click, press, and drag reactions\n        element.addEventListener('click', function() {\n          console.log('DEBUG: Click event triggered on element:', {\n            id: this.getAttribute('data-figma-id'),\n            name: this.getAttribute('data-figma-name'),\n            type: this.getAttribute('data-figma-type'),\n            trigger: trigger,\n            actionType: actionType,\n            destinationId: destinationId,\n            transitionType: transitionType,\n            transitionDuration: transitionDuration\n          });\n          \n          if (trigger.type === 'ON_CLICK' || trigger.type === 'ON_PRESS') {\n            console.log('DEBUG: Processing click reaction for element:', this.getAttribute('data-figma-id'));\n            handleReaction(this, destinationId, transitionType, transitionDuration);\n          }\n        });\n        \n        // Handle drag reactions\n        element.addEventListener('mousedown', function() {\n          if (trigger.type === 'ON_DRAG') {\n            handleReaction(this, destinationId, transitionType, transitionDuration);\n          }\n        });\n      });\n  ";
}
function createTimeoutHandler() {
    return "\n      // Track which variants have active timers (for preventing duplicate timers during the same activation)\n      const activeTimers = new Map(); // elementId -> timeoutId\n      \n      // Function to start timeout reactions for active variants\n      function startTimeoutReactionsForActiveVariants() {\n        // Look for both variant-active elements with reactions AND any elements with reactions that don't have variant properties\n        const activeVariants = document.querySelectorAll('.variant-active[data-has-reactions=\"true\"]');\n        const reactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n        \n        console.log('DEBUG: Found', activeVariants.length, 'active variants with reactions');\n        console.log('DEBUG: Found', reactionElements.length, 'total elements with reactions');\n        \n        // Process active variants first\n        activeVariants.forEach(element => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          const parentComponent = element.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n          \n          console.log('DEBUG: Processing variant:', elementId, 'name:', elementName, 'parent:', parentName);\n          \n          // Only start timers for variants that are actually visible (not hidden by CSS)\n          const computedStyle = window.getComputedStyle(element);\n          \n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n            const actionType = element.getAttribute('data-reaction-action-type');\n            const destinationId = element.getAttribute('data-reaction-destination');\n            const transitionType = element.getAttribute('data-reaction-transition-type');\n            const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n            \n            // Handle timeout reactions only for active variants that don't have an active timer\n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId); // Clear the timer when it completes\n                handleReaction(element, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n          }\n        });\n        \n        // Also process any reaction elements that don't have variant properties (like 6461:693)\n        reactionElements.forEach(element => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          \n          // Skip if this element was already processed as a variant\n          if (element.classList.contains('variant-active')) {\n            return;\n          }\n          \n          // Skip if this element has variant properties (it will be handled by variant logic)\n          if (element.hasAttribute('data-variant-property-1')) {\n            return;\n          }\n          \n          const parentComponent = element.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n          \n          console.log('DEBUG: Processing non-variant reaction element:', elementId, 'name:', elementName, 'parent:', parentName);\n          \n          // Only start timers for elements that are actually visible (not hidden by CSS)\n          const computedStyle = window.getComputedStyle(element);\n          \n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n            const actionType = element.getAttribute('data-reaction-action-type');\n            const destinationId = element.getAttribute('data-reaction-destination');\n            const transitionType = element.getAttribute('data-reaction-transition-type');\n            const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n            \n            // Handle timeout reactions only for elements that don't have an active timer\n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId); // Clear the timer when it completes\n                handleReaction(element, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n          }\n        });\n      }\n      \n      // Function to start timeout reactions for nested components when their parent becomes visible\n      function startTimeoutReactionsForNestedComponents(parentElement) {\n        if (!parentElement) return;\n        \n        // Find all nested components with timeout reactions within the parent\n        const nestedComponents = parentElement.querySelectorAll('[data-has-reactions=\"true\"][data-reaction-trigger*=\"AFTER_TIMEOUT\"]');\n        \n        nestedComponents.forEach(component => {\n          const elementId = component.getAttribute('data-figma-id');\n          const elementName = component.getAttribute('data-figma-name');\n          const parentComponent = component.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n          \n          console.log('DEBUG: Processing nested component:', elementId, 'name:', elementName, 'parent:', parentName);\n          \n          // Only start timers for nested components that are actually visible\n          const computedStyle = window.getComputedStyle(component);\n          \n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(component.getAttribute('data-reaction-trigger') || '{}');\n            \n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId);\n                const actionType = component.getAttribute('data-reaction-action-type');\n                const destinationId = component.getAttribute('data-reaction-destination');\n                const transitionType = component.getAttribute('data-reaction-transition-type');\n                const transitionDuration = component.getAttribute('data-reaction-transition-duration');\n                handleReaction(component, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');\n          }\n        });\n      }\n      \n      // Function to start timeout reactions for a specific newly active variant\n      function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {\n        if (!newlyActiveElement) return;\n        \n        const elementId = newlyActiveElement.getAttribute('data-figma-id');\n        const elementName = newlyActiveElement.getAttribute('data-figma-name');\n        const parentComponent = newlyActiveElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n        const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n        \n        console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);\n        \n        // Only start timers for variants that are actually visible (not hidden by CSS)\n        const computedStyle = window.getComputedStyle(newlyActiveElement);\n        \n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');\n          const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');\n          const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');\n          const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');\n          const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');\n          \n          // Handle timeout reactions only for active variants that don't have an active timer\n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId); // Clear the timer when it completes\n              handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n          } else if (activeTimers.has(elementId)) {\n            console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');\n          }\n          \n          // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant\n          startTimeoutReactionsForNestedComponents(newlyActiveElement);\n        } else {\n          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n        }\n      }\n      \n      // CRITICAL FIX: Only start timeout reactions for the initial visible variant\n      // Instead of starting timers for all variant-active elements immediately,\n      // we wait for the first variant transition or user interaction\n      function startTimeoutReactionsForInitialVariant() {\n        // Find the first visible variant that should start the flow\n        // This is typically the first variant in a component set that's marked as active\n        const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"]');\n        console.log('DEBUG: Found', componentSets.length, 'component sets');\n        \n        // Also check for any elements with reactions\n        const allReactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n        console.log('DEBUG: Found', allReactionElements.length, 'total elements with reactions');\n        \n        // Log details about reaction elements\n        allReactionElements.forEach((element, index) => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n          const computedStyle = window.getComputedStyle(element);\n          \n          console.log('DEBUG: Reaction element', index + 1, ':', {\n            id: elementId,\n            name: elementName,\n            trigger: trigger,\n            display: computedStyle.display,\n            visibility: computedStyle.visibility,\n            isActive: element.classList.contains('variant-active'),\n            isHidden: element.classList.contains('variant-hidden')\n          });\n        });\n        \n        componentSets.forEach(componentSet => {\n          const componentSetName = componentSet.getAttribute('data-figma-name');\n          const activeVariants = componentSet.querySelectorAll('.variant-active[data-has-reactions=\"true\"]');\n          console.log('DEBUG: Component set', componentSetName, 'has', activeVariants.length, 'active variants with reactions');\n          \n          // Only start timers for the first active variant in each component set\n          if (activeVariants.length > 0) {\n            const firstActiveVariant = activeVariants[0];\n            const elementId = firstActiveVariant.getAttribute('data-figma-id');\n            const elementName = firstActiveVariant.getAttribute('data-figma-name');\n            const computedStyle = window.getComputedStyle(firstActiveVariant);\n            \n            console.log('DEBUG: Processing initial variant:', elementId, 'name:', elementName, 'in component set:', componentSetName);\n            \n            // Only start timer if the variant is actually visible\n            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n              const trigger = JSON.parse(firstActiveVariant.getAttribute('data-reaction-trigger') || '{}');\n              \n              // Skip nested components that should only start when their parent becomes visible\n              // Allow independent components to start their timers on page load\n              // Check if this component set is nested within another component set\n              const parentComponentSet = componentSet.closest('[data-figma-type=\"COMPONENT_SET\"]');\n              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;\n              \n              if (isNestedComponent) {\n                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');\n                return;\n              }\n              \n              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n                console.log('DEBUG: Starting initial timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);\n                const timeoutId = setTimeout(() => {\n                  console.log('DEBUG: Timeout triggered for element:', elementId, 'name:', elementName);\n                  activeTimers.delete(elementId);\n                  const actionType = firstActiveVariant.getAttribute('data-reaction-action-type');\n                  const destinationId = firstActiveVariant.getAttribute('data-reaction-destination');\n                  const transitionType = firstActiveVariant.getAttribute('data-reaction-transition-type');\n                  const transitionDuration = firstActiveVariant.getAttribute('data-reaction-transition-duration');\n                  console.log('DEBUG: Calling handleReaction with:', {\n                    destinationId: destinationId,\n                    transitionType: transitionType,\n                    transitionDuration: transitionDuration\n                  });\n                  handleReaction(firstActiveVariant, destinationId, transitionType, transitionDuration);\n                }, (trigger.timeout || 0) * 1000);\n                activeTimers.set(elementId, timeoutId);\n                console.log('DEBUG: Created timeout timer for element:', elementId, 'timeout ID:', timeoutId, 'duration:', (trigger.timeout || 0) * 1000, 'ms');\n                \n                // CRITICAL FIX: Also start timeout reactions for any nested components within this initial variant\n                startTimeoutReactionsForNestedComponents(firstActiveVariant);\n              } else {\n                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n              }\n            } else {\n              console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n            }\n          }\n          \n          // CRITICAL FIX: Also check for non-variant reaction elements in this component set\n          const reactionElements = componentSet.querySelectorAll('[data-has-reactions=\"true\"]');\n          reactionElements.forEach(element => {\n            const elementId = element.getAttribute('data-figma-id');\n            const elementName = element.getAttribute('data-figma-name');\n            \n            // Skip if this element was already processed as a variant\n            if (element.classList.contains('variant-active')) {\n              return;\n            }\n            \n            // Skip if this element has variant properties (it will be handled by variant logic)\n            if (element.hasAttribute('data-variant-property-1')) {\n              return;\n            }\n            \n            const computedStyle = window.getComputedStyle(element);\n            \n            console.log('DEBUG: Processing initial non-variant reaction element:', elementId, 'name:', elementName, 'in component set:', componentSetName);\n            \n            // Only start timer if the element is actually visible\n            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n              const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n              \n              // Skip nested components that should only start when their parent becomes visible\n              const parentComponentSet = componentSet.closest('[data-figma-type=\"COMPONENT_SET\"]');\n              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;\n              \n              if (isNestedComponent) {\n                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');\n                return;\n              }\n              \n              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n                console.log('DEBUG: Starting initial timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);\n                const timeoutId = setTimeout(() => {\n                  activeTimers.delete(elementId);\n                  const actionType = element.getAttribute('data-reaction-action-type');\n                  const destinationId = element.getAttribute('data-reaction-destination');\n                  const transitionType = element.getAttribute('data-reaction-transition-type');\n                  const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n                  handleReaction(element, destinationId, transitionType, transitionDuration);\n                }, (trigger.timeout || 0) * 1000);\n                activeTimers.set(elementId, timeoutId);\n                \n                // Also start timeout reactions for any nested components within this element\n                startTimeoutReactionsForNestedComponents(element);\n              } else {\n                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n              }\n            } else {\n              console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n            }\n          });\n        });\n      }\n      \n      // Start timeout reactions for the initial visible variant after a short delay\n      // to ensure CSS classes and visibility are properly applied\n      console.log('DEBUG: Setting up initial timeout reactions');\n      setTimeout(() => {\n        console.log('DEBUG: Starting initial timeout reactions');\n        startTimeoutReactionsForInitialVariant();\n      }, 100);\n  ";
}


/***/ }),

/***/ 489:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.safeHasProperty = safeHasProperty;
exports.safeToString = safeToString;
exports.safeAttributeValue = safeAttributeValue;
exports.escapeHtmlAttribute = escapeHtmlAttribute;
// Utility functions for HTML generation
function safeHasProperty(obj, prop) {
    return obj && typeof obj === 'object' && prop in obj;
}
function safeToString(value) {
    if (value === null || value === undefined)
        return '';
    if (typeof value === 'symbol')
        return value.toString();
    return String(value);
}
// Helper function to safely convert any value to string for HTML attributes, handling symbols
function safeAttributeValue(value) {
    if (value === null || value === undefined)
        return '';
    if (typeof value === 'symbol')
        return value.toString();
    return String(value);
}
function escapeHtmlAttribute(value) {
    return value
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}


/***/ }),

/***/ 821:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createModularSmartAnimateHandler = createModularSmartAnimateHandler;
/**
 * Creates a modular smart animate handler that uses the new animation system
 */
function createModularSmartAnimateHandler() {
    return "\n      // Global transition lock to prevent multiple simultaneous transitions\n      let isTransitionInProgress = false;\n      let currentTransitionPromise = null;\n      \n      // Animation types\n      const AnimationType = {\n        SIMPLE: 'SIMPLE',\n        SIZE: 'SIZE', \n        TRANSFORM: 'TRANSFORM'\n      };\n      \n      // Translation conditions\n      const TranslationCondition = {\n        ABSOLUTE: 'ABSOLUTE',\n        RELATIVE_PADDING: 'RELATIVE_PADDING',\n        RELATIVE_ALIGNMENT: 'RELATIVE_ALIGNMENT'\n      };\n      \n      // Helper function to determine animation type for a property\n      function getAnimationType(property) {\n        const simpleProperties = [\n          'opacity', 'color', 'backgroundColor', 'cornerRadius', 'borderRadius',\n          'fontSize', 'fontWeight', 'textAlign', 'letterSpacing', 'lineHeight'\n        ];\n        \n        const sizeProperties = [\n          'width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'\n        ];\n        \n        const transformProperties = [\n          'translateX', 'translateY', 'translateZ', 'rotation', 'scale', 'transform'\n        ];\n        \n        if (simpleProperties.includes(property)) {\n          return AnimationType.SIMPLE;\n        } else if (sizeProperties.includes(property)) {\n          return AnimationType.SIZE;\n        } else if (transformProperties.includes(property)) {\n          return AnimationType.TRANSFORM;\n        }\n        \n        return AnimationType.SIMPLE;\n      }\n      \n      // Helper function to determine translation condition\n      function getTranslationCondition(element, node, parentNode) {\n        const ignoreAutoLayout = node.layoutPositioning === 'ABSOLUTE';\n        \n        const parentHasAutoLayout = parentNode && \n                                   parentNode.type === 'FRAME' && \n                                   parentNode.layoutMode && \n                                   parentNode.layoutMode !== 'NONE';\n        \n        if (ignoreAutoLayout || !parentHasAutoLayout) {\n          return TranslationCondition.ABSOLUTE;\n        }\n        \n        if (parentHasAutoLayout) {\n          // For now, default to padding-based relative positioning\n          // This could be enhanced to detect which type of relative positioning is needed\n          return TranslationCondition.RELATIVE_PADDING;\n        }\n        \n        return TranslationCondition.ABSOLUTE;\n      }\n      \n      // Helper function to detect animation changes\n      function detectAnimationChanges(sourceElement, targetElement, sourceNode, targetNode, parentNode) {\n        const changes = [];\n        \n        const sourceStyle = window.getComputedStyle(sourceElement);\n        const targetStyle = window.getComputedStyle(targetElement);\n        \n        // Check simple properties\n        const simpleProperties = ['opacity', 'backgroundColor', 'color'];\n        simpleProperties.forEach(property => {\n          const sourceValue = sourceStyle[property];\n          const targetValue = targetStyle[property];\n          \n          if (sourceValue !== targetValue) {\n            changes.push({\n              type: AnimationType.SIMPLE,\n              property,\n              sourceValue,\n              targetValue,\n              changed: true\n            });\n          }\n        });\n        \n        // Check size properties\n        const sizeProperties = ['width', 'height'];\n        sizeProperties.forEach(property => {\n          const sourceValue = parseFloat(sourceStyle[property]) || 0;\n          const targetValue = parseFloat(targetStyle[property]) || 0;\n          \n          if (Math.abs(sourceValue - targetValue) > 1) {\n            changes.push({\n              type: AnimationType.SIZE,\n              property,\n              sourceValue,\n              targetValue,\n              changed: true\n            });\n          }\n        });\n        \n        // Check transform properties based on translation condition\n        const translationCondition = getTranslationCondition(sourceElement, sourceNode, parentNode);\n        \n        console.log('DEBUG: Translation condition detected:', translationCondition);\n        \n        if (translationCondition === TranslationCondition.ABSOLUTE) {\n          // Check left/top changes for absolute positioning\n          const sourceLeft = parseFloat(sourceStyle.left) || 0;\n          const targetLeft = parseFloat(targetStyle.left) || 0;\n          const sourceTop = parseFloat(sourceStyle.top) || 0;\n          const targetTop = parseFloat(targetStyle.top) || 0;\n          \n          if (Math.abs(sourceLeft - targetLeft) > 1) {\n            changes.push({\n              type: AnimationType.TRANSFORM,\n              property: 'translateX',\n              sourceValue: sourceLeft,\n              targetValue: targetLeft,\n              changed: true,\n              translationCondition\n            });\n          }\n          \n          if (Math.abs(sourceTop - targetTop) > 1) {\n            changes.push({\n              type: AnimationType.TRANSFORM,\n              property: 'translateY',\n              sourceValue: sourceTop,\n              targetValue: targetTop,\n              changed: true,\n              translationCondition\n            });\n          }\n        } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n          // Check parent padding changes\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          \n          if (sourceParent && targetParent) {\n            const sourceParentStyle = window.getComputedStyle(sourceParent);\n            const targetParentStyle = window.getComputedStyle(targetParent);\n            \n            const paddingProperties = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'];\n            paddingProperties.forEach(property => {\n              const sourceValue = parseFloat(sourceParentStyle[property]) || 0;\n              const targetValue = parseFloat(targetParentStyle[property]) || 0;\n              \n              if (Math.abs(sourceValue - targetValue) > 1) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: `parent_${property}`,\n                  sourceValue,\n                  targetValue,\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n          }\n        } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n          // Check parent alignment changes - ENHANCED FOR JUSTIFYCONTENT\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          \n          if (sourceParent && targetParent) {\n            const sourceParentStyle = window.getComputedStyle(sourceParent);\n            const targetParentStyle = window.getComputedStyle(targetParent);\n            \n            // Check alignment properties with detailed logging\n            const alignmentProperties = ['justifyContent', 'alignItems', 'textAlign', 'verticalAlign'];\n            \n            console.log('DEBUG: Checking alignment properties for RELATIVE_ALIGNMENT');\n            \n            alignmentProperties.forEach(property => {\n              const sourceValue = sourceParentStyle[property];\n              const targetValue = targetParentStyle[property];\n              \n              console.log(`DEBUG: Parent ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });\n              \n              if (sourceValue !== targetValue) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: `parent_${property}`,\n                  sourceValue: sourceValue || '',\n                  targetValue: targetValue || '',\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n            \n            // Check element's own alignment properties\n            alignmentProperties.forEach(property => {\n              const sourceValue = sourceStyle[property];\n              const targetValue = targetStyle[property];\n              \n              console.log(`DEBUG: Element ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });\n              \n              if (sourceValue !== targetValue) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: property,\n                  sourceValue: sourceValue || '',\n                  targetValue: targetValue || '',\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n            \n            // Check for flexbox-specific properties\n            const flexProperties = ['flexDirection', 'flexWrap', 'alignContent', 'justifyItems'];\n            flexProperties.forEach(property => {\n              const sourceValue = sourceParentStyle[property];\n              const targetValue = targetParentStyle[property];\n              \n              console.log(`DEBUG: Flex ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });\n              \n              if (sourceValue !== targetValue) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: `parent_${property}`,\n                  sourceValue: sourceValue || '',\n                  targetValue: targetValue || '',\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n            \n            // Check for position changes that might be due to alignment\n            // Even if alignment values are the same, the computed position might differ\n            const sourceRect = sourceElement.getBoundingClientRect();\n            const targetRect = targetElement.getBoundingClientRect();\n            const sourceParentRect = sourceParent.getBoundingClientRect();\n            const targetParentRect = targetParent.getBoundingClientRect();\n            \n            // Calculate relative positions within their containers\n            const sourceRelativeX = sourceRect.left - sourceParentRect.left;\n            const targetRelativeX = targetRect.left - targetParentRect.left;\n            const sourceRelativeY = sourceRect.top - sourceParentRect.top;\n            const targetRelativeY = targetRect.top - targetParentRect.top;\n            \n            console.log('DEBUG: Relative position analysis:', {\n              sourceRelativeX,\n              targetRelativeX,\n              sourceRelativeY,\n              targetRelativeY,\n              xDifference: Math.abs(sourceRelativeX - targetRelativeX),\n              yDifference: Math.abs(sourceRelativeY - targetRelativeY)\n            });\n            \n            // If there's a significant position difference, it might be due to alignment\n            if (Math.abs(sourceRelativeX - targetRelativeX) > 1) {\n              changes.push({\n                type: AnimationType.TRANSFORM,\n                property: 'alignTranslateX',\n                sourceValue: sourceRelativeX,\n                targetValue: targetRelativeX,\n                changed: true,\n                translationCondition\n              });\n            }\n            \n            if (Math.abs(sourceRelativeY - targetRelativeY) > 1) {\n              changes.push({\n                type: AnimationType.TRANSFORM,\n                property: 'alignTranslateY',\n                sourceValue: sourceRelativeY,\n                targetValue: targetRelativeY,\n                changed: true,\n                translationCondition\n              });\n            }\n          }\n        }\n        \n        console.log('DEBUG: Total changes detected:', changes.length, changes);\n        return changes;\n      }\n      \n      // Helper function to apply animation changes\n      function applyAnimationChange(element, change, duration, easing) {\n        const { type, property, targetValue, translationCondition, destination } = change;\n        \n        console.log('DEBUG: Applying animation change:', { type, property, targetValue, translationCondition });\n        \n        // Get transition property\n        let transitionProperty = property;\n        if (type === AnimationType.TRANSFORM) {\n          if (translationCondition === TranslationCondition.ABSOLUTE) {\n            transitionProperty = property === 'translateX' ? 'left' : 'top';\n          } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n            transitionProperty = property.replace('parent_', '');\n          } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n            if (property === 'alignTranslateX' || property === 'alignTranslateY') {\n              transitionProperty = property === 'alignTranslateX' ? 'left' : 'top';\n            } else if (property.startsWith('parent_')) {\n              // For alignment changes, animate the element's position instead of the parent's alignment\n              if (property === 'parent_justifyContent') {\n                // Use the target element's actual position from the destination variant\n                const sourceElementName = element.getAttribute('data-figma-name');\n                const targetElement = destination.querySelector(`[data-figma-name=\"${sourceElementName}\"]`);\n                \n                if (targetElement) {\n                  const targetRect = targetElement.getBoundingClientRect();\n                  const parent = element.parentElement;\n                  const parentRect = parent.getBoundingClientRect();\n                  \n                  // Calculate the target position relative to the parent\n                  const targetLeft = targetRect.left - parentRect.left;\n                  \n                  console.log('DEBUG: Calculating justifyContent animation using target position:', {\n                    currentLeft: element.getBoundingClientRect().left - parentRect.left,\n                    targetLeft: targetLeft,\n                    targetElementId: targetElement.getAttribute('data-figma-id'),\n                    targetElementName: sourceElementName,\n                    justifyContent: targetValue\n                  });\n                  \n                  // Set transition for left position\n                  element.style.transition = `left ${duration}s ${easing}`;\n                  element.style.left = `${targetLeft}px`;\n                  \n                  console.log('DEBUG: Applied justifyContent animation via target position:', {\n                    property: 'left',\n                    transitionProperty: 'left',\n                    targetValue: `${targetLeft}px`\n                  });\n                  \n                  return; // Skip the default handling\n                } else {\n                  console.log('DEBUG: Target element not found in destination by name:', sourceElementName);\n                }\n              } else if (property === 'parent_alignItems') {\n                // Use the target element's actual position from the destination variant\n                const sourceElementName = element.getAttribute('data-figma-name');\n                const targetElement = destination.querySelector(`[data-figma-name=\"${sourceElementName}\"]`);\n                \n                if (targetElement) {\n                  const targetRect = targetElement.getBoundingClientRect();\n                  const parent = element.parentElement;\n                  const parentRect = parent.getBoundingClientRect();\n                  \n                  // Calculate the target position relative to the parent\n                  const targetTop = targetRect.top - parentRect.top;\n                  \n                  console.log('DEBUG: Calculating alignItems animation using target position:', {\n                    currentTop: element.getBoundingClientRect().top - parentRect.top,\n                    targetTop: targetTop,\n                    targetElementId: targetElement.getAttribute('data-figma-id'),\n                    targetElementName: sourceElementName,\n                    alignItems: targetValue\n                  });\n                  \n                  // Set transition for top position\n                  element.style.transition = `top ${duration}s ${easing}`;\n                  element.style.top = `${targetTop}px`;\n                  \n                  console.log('DEBUG: Applied alignItems animation via target position:', {\n                    property: 'top',\n                    transitionProperty: 'top',\n                    targetValue: `${targetTop}px`\n                  });\n                  \n                  return; // Skip the default handling\n                } else {\n                  console.log('DEBUG: Target element not found in destination by name:', sourceElementName);\n                }\n              }\n              transitionProperty = property.replace('parent_', '');\n            } else {\n              transitionProperty = property;\n            }\n          }\n        }\n        \n        // Set up transition\n        element.style.transition = `${transitionProperty} ${duration}s ${easing}`;\n        \n        // Apply the change based on type and condition\n        switch (type) {\n          case AnimationType.SIMPLE:\n            element.style[property] = targetValue;\n            break;\n            \n          case AnimationType.SIZE:\n            element.style[property] = `${targetValue}px`;\n            break;\n            \n          case AnimationType.TRANSFORM:\n            if (translationCondition === TranslationCondition.ABSOLUTE) {\n              if (property === 'translateX') {\n                // For additive position changes, add the difference to current position\n                const currentLeft = parseFloat(element.style.left) || 0;\n                const newLeft = currentLeft + targetValue;\n                element.style.left = `${newLeft}px`;\n                \n                console.log('DEBUG: Applying additive translateX animation:', {\n                  currentLeft: currentLeft,\n                  targetValue: targetValue,\n                  newLeft: newLeft,\n                  elementName: element.getAttribute('data-figma-name')\n                });\n              } else if (property === 'translateY') {\n                // For additive position changes, add the difference to current position\n                const currentTop = parseFloat(element.style.top) || 0;\n                const newTop = currentTop + targetValue;\n                element.style.top = `${newTop}px`;\n                \n                console.log('DEBUG: Applying additive translateY animation:', {\n                  currentTop: currentTop,\n                  targetValue: targetValue,\n                  newTop: newTop,\n                  elementName: element.getAttribute('data-figma-name')\n                });\n              }\n            } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n              if (element.parentElement) {\n                const paddingProperty = property.replace('parent_', '');\n                element.parentElement.style[paddingProperty] = `${targetValue}px`;\n              }\n            } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n              if (property === 'alignTranslateX') {\n                element.style.left = `${targetValue}px`;\n              } else if (property === 'alignTranslateY') {\n                element.style.top = `${targetValue}px`;\n              } else if (property.startsWith('parent_')) {\n                if (element.parentElement) {\n                  const alignmentProperty = property.replace('parent_', '');\n                  element.parentElement.style[alignmentProperty] = targetValue;\n                }\n              } else {\n                // Direct property change on the element\n                element.style[property] = targetValue;\n              }\n            }\n            break;\n        }\n        \n        console.log('DEBUG: Applied change:', { property, transitionProperty, targetValue });\n      }\n      \n      // Helper function to get easing function\n      function getEasingFunction(animationType) {\n        switch (animationType) {\n          case 'EASE_IN_AND_OUT_BACK':\n            return 'ease-in-out';\n          case 'EASE_IN_AND_OUT':\n            return 'ease-in-out';\n          case 'EASE_IN':\n            return 'ease-in';\n          case 'EASE_OUT':\n            return 'ease-out';\n          case 'LINEAR':\n            return 'linear';\n          case 'BOUNCY':\n            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';\n          case 'GENTLE':\n            return 'ease-in-out';\n          case 'SMART_ANIMATE':\n            return 'ease-in-out';\n          default:\n            return 'ease-out';\n        }\n      }\n      \n      // Helper function to create element copy\n      function createElementCopy(sourceElement) {\n        console.log('DEBUG: createElementCopy function called');\n        console.log('DEBUG: Creating element copy for:', sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id'));\n        \n        const copy = sourceElement.cloneNode(true);\n        copy.setAttribute('data-figma-id', sourceElement.getAttribute('data-figma-id') + '-copy');\n        copy.setAttribute('data-is-animation-copy', 'true');\n        \n        // Make an exact copy - don't manipulate positions\n        console.log('DEBUG: Making exact copy of source variant');\n        \n        // Debug: Log the computed positions of the source element before copying\n        const sourceElements = sourceElement.querySelectorAll('[data-figma-id]');\n        console.log('DEBUG: Source element computed positions before copying:');\n        sourceElements.forEach((element, index) => {\n          const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n          const rect = element.getBoundingClientRect();\n          const parent = element.parentElement;\n          const parentRect = parent ? parent.getBoundingClientRect() : { left: 0, top: 0 };\n          const relativeLeft = rect.left - parentRect.left;\n          const relativeTop = rect.top - parentRect.top;\n          \n          console.log('  Source element', index + 1, '(', elementName, '):', {\n            absoluteLeft: rect.left,\n            absoluteTop: rect.top,\n            relativeLeft: relativeLeft,\n            relativeTop: relativeTop,\n            computedLeft: window.getComputedStyle(element).left,\n            computedTop: window.getComputedStyle(element).top\n          });\n        });\n        \n        // The copy is already an exact clone, no position manipulation needed\n        \n        // Position the copy absolutely over the source element\n        const sourceRect = sourceElement.getBoundingClientRect();\n        const parentRect = sourceElement.parentElement.getBoundingClientRect();\n        \n        copy.style.position = 'absolute';\n        copy.style.top = (sourceRect.top - parentRect.top) + 'px';\n        copy.style.left = (sourceRect.left - parentRect.left) + 'px';\n        copy.style.transform = 'none';\n        copy.style.margin = '0';\n        copy.style.padding = '0';\n        \n        // Set high z-index\n        const allElements = document.querySelectorAll('*');\n        let maxZIndex = 0;\n        allElements.forEach(el => {\n          const zIndex = parseInt(window.getComputedStyle(el).zIndex) || 0;\n          if (zIndex > maxZIndex) maxZIndex = zIndex;\n        });\n        \n        const copyZIndex = maxZIndex + 1000;\n        copy.style.zIndex = copyZIndex.toString();\n        copy.style.pointerEvents = 'none';\n        copy.style.transform = 'translateZ(0)';\n        copy.style.willChange = 'transform, left, top';\n        \n        // Ensure the copy container doesn't clip its children\n        copy.style.overflow = 'visible';\n        \n        // Ensure the copy and all its children are fully visible\n        copy.style.opacity = '1';\n        copy.style.visibility = 'visible';\n        copy.style.display = 'flex';\n\n        // Ensure all nested elements in the copy are also visible\n        const copyChildren = copy.querySelectorAll('*');\n        copyChildren.forEach(child => {\n          child.style.opacity = '1';\n          child.style.visibility = 'visible';\n          child.style.overflow = 'visible';\n          if (child.style.display === 'none') {\n            child.style.display = 'flex';\n          }\n        });\n\n        // Debug: Log the initial visibility properties of all nodes in the copy\n        console.log('DEBUG: Copy element visibility properties:');\n        const nodesWithFigmaId = copy.querySelectorAll('[data-figma-id]');\n        console.log('DEBUG: Found', nodesWithFigmaId.length, 'nodes with data-figma-id in copy');\n        \n        nodesWithFigmaId.forEach((node, index) => {\n          const figmaName = node.getAttribute('data-figma-name') || 'Unknown';\n          console.log('  Node', index + 1, '(' + figmaName + '):');\n          console.log('    opacity:', window.getComputedStyle(node).opacity);\n          console.log('    display:', window.getComputedStyle(node).display);\n          console.log('    visibility:', window.getComputedStyle(node).visibility);\n          console.log('    position:', window.getComputedStyle(node).position);\n          console.log('    left:', window.getComputedStyle(node).left);\n          console.log('    top:', window.getComputedStyle(node).top);\n        });\n        \n        // Log the opacity and display properties of each node in the copy\n        console.log('DEBUG: Copy element visibility properties:');\n        const copyNodesForVisibility = copy.querySelectorAll('[data-figma-id]');\n        console.log('DEBUG: Found', copyNodesForVisibility.length, 'nodes with data-figma-id in copy');\n        copyNodesForVisibility.forEach((node, index) => {\n          const nodeName = node.getAttribute('data-figma-name') || node.getAttribute('data-figma-id');\n          const computedStyle = window.getComputedStyle(node);\n          const opacity = computedStyle.opacity;\n          const display = computedStyle.display;\n          const visibility = computedStyle.visibility;\n          const position = computedStyle.position;\n          const left = computedStyle.left;\n          const top = computedStyle.top;\n          \n          console.log('  Node ' + (index + 1) + ' (' + nodeName + '):');\n          console.log('    opacity: ' + opacity);\n          console.log('    display: ' + display);\n          console.log('    visibility: ' + visibility);\n          console.log('    position: ' + position);\n          console.log('    left: ' + left);\n          console.log('    top: ' + top);\n        });\n        \n        console.log('DEBUG: Copy creation completed');\n        return copy;\n      }\n      \n      // Helper function to update copy content to match destination\n      function updateCopyContentToMatchDestination(copy, destination) {\n        console.log('DEBUG: Updating copy content to match destination');\n        \n        // Get all elements in both copy and destination\n        const copyElements = copy.querySelectorAll('[data-figma-id]');\n        const destinationElements = destination.querySelectorAll('[data-figma-id]');\n        \n        // Create a map of destination elements by name\n        const destinationElementMap = new Map();\n        destinationElements.forEach(element => {\n          const name = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n          if (name) {\n            destinationElementMap.set(name, element);\n          }\n        });\n        \n        // Update each copy element's content to match destination\n        copyElements.forEach(copyElement => {\n          const copyElementName = copyElement.getAttribute('data-figma-name') || copyElement.getAttribute('data-figma-id');\n          const destinationElement = destinationElementMap.get(copyElementName);\n          \n          console.log('DEBUG: Checking content for', copyElementName);\n          console.log('  Copy textContent:', copyElement.textContent);\n          console.log('  Copy innerHTML:', copyElement.innerHTML.substring(0, 200));\n          if (destinationElement) {\n            console.log('  Destination textContent:', destinationElement.textContent);\n            console.log('  Destination innerHTML:', destinationElement.innerHTML.substring(0, 200));\n          }\n          \n          if (destinationElement) {\n            // Update text content\n            if (destinationElement.textContent !== copyElement.textContent) {\n              const oldText = copyElement.textContent;\n              copyElement.textContent = destinationElement.textContent;\n              console.log('DEBUG: Updated text content for', copyElementName, 'from', oldText, 'to', destinationElement.textContent);\n            }\n            \n            // Update innerHTML for more complex content, but preserve positioning\n            if (destinationElement.innerHTML !== copyElement.innerHTML) {\n              const oldHTML = copyElement.innerHTML;\n              \n              // CRITICAL FIX: Preserve the positioning of ALL nested elements before updating content\n              const allNestedElements = copyElement.querySelectorAll('[data-figma-id]');\n              const originalPositions = new Map();\n              \n              allNestedElements.forEach(nestedElement => {\n                const nestedElementName = nestedElement.getAttribute('data-figma-name') || nestedElement.getAttribute('data-figma-id');\n                const computedStyle = window.getComputedStyle(nestedElement);\n                originalPositions.set(nestedElementName, {\n                  position: computedStyle.position,\n                  left: computedStyle.left,\n                  top: computedStyle.top,\n                  transform: computedStyle.transform\n                });\n              });\n              \n              // Also preserve the copy element itself\n              const copyComputedStyle = window.getComputedStyle(copyElement);\n              originalPositions.set(copyElementName, {\n                position: copyComputedStyle.position,\n                left: copyComputedStyle.left,\n                top: copyComputedStyle.top,\n                transform: copyComputedStyle.transform\n              });\n              \n              // Update the innerHTML\n              copyElement.innerHTML = destinationElement.innerHTML;\n              \n              // CRITICAL FIX: Restore the positioning of ALL elements after content update\n              originalPositions.forEach((positionData, elementName) => {\n                const elementToRestore = elementName === copyElementName ? \n                  copyElement : \n                  copyElement.querySelector('[data-figma-name=\"' + elementName + '\"]') ||\n                  copyElement.querySelector('[data-figma-id=\"' + elementName + '\"]');\n                \n                if (elementToRestore) {\n                  elementToRestore.style.position = positionData.position;\n                  elementToRestore.style.left = positionData.left;\n                  elementToRestore.style.top = positionData.top;\n                  elementToRestore.style.transform = positionData.transform;\n                  \n                  console.log('DEBUG: Restored positioning for', elementName, ':', positionData);\n                }\n              });\n              \n              console.log('DEBUG: Updated innerHTML for', copyElementName, 'from', oldHTML.substring(0, 100), 'to', destinationElement.innerHTML.substring(0, 100));\n            }\n            \n            // Update specific attributes that might contain content\n            const contentAttributes = ['data-content', 'data-text', 'title', 'alt'];\n            contentAttributes.forEach(attr => {\n              const destValue = destinationElement.getAttribute(attr);\n              const copyValue = copyElement.getAttribute(attr);\n              if (destValue !== copyValue && destValue !== null) {\n                copyElement.setAttribute(attr, destValue);\n                console.log('DEBUG: Updated attribute', attr, 'for', copyElementName, 'to', destValue);\n              }\n            });\n          }\n        });\n        \n        // Log the visibility properties after content update\n        console.log('DEBUG: Copy element visibility properties after content update:');\n        const copyNodesAfterUpdate = copy.querySelectorAll('[data-figma-id]');\n        copyNodesAfterUpdate.forEach((node, index) => {\n          const nodeName = node.getAttribute('data-figma-name') || node.getAttribute('data-figma-id');\n          const computedStyle = window.getComputedStyle(node);\n          const opacity = computedStyle.opacity;\n          const display = computedStyle.display;\n          const visibility = computedStyle.visibility;\n          const position = computedStyle.position;\n          const left = computedStyle.left;\n          const top = computedStyle.top;\n          \n          console.log('  Node ' + (index + 1) + ' (' + nodeName + '):');\n          console.log('    opacity: ' + opacity);\n          console.log('    display: ' + display);\n          console.log('    visibility: ' + visibility);\n          console.log('    position: ' + position);\n          console.log('    left: ' + left);\n          console.log('    top: ' + top);\n        });\n\n        // Ensure all elements in the copy are visible after content update\n        const allCopyElements = copy.querySelectorAll('*');\n        allCopyElements.forEach(element => {\n          element.style.opacity = '1';\n          element.style.visibility = 'visible';\n          element.style.overflow = 'visible';\n          if (element.style.display === 'none') {\n            element.style.display = 'flex';\n          }\n        });\n      }\n      \n      // Helper function to animate copy to destination\n      function animateCopyToDestination(copy, destination, originalSourceElement, transitionType, transitionDuration) {\n        return new Promise((resolve) => {\n          // Update copy content to match destination content\n          updateCopyContentToMatchDestination(copy, destination);\n          \n          // Find elements with property changes\n          const elementsToAnimate = findElementsWithPropertyChanges(destination, copy, originalSourceElement);\n          \n          const easingFunction = getEasingFunction(transitionType);\n          const duration = parseFloat(transitionDuration || '0.3');\n          \n          if (elementsToAnimate.length > 0) {\n            console.log('DEBUG: Animating copy with', elementsToAnimate.length, 'elements using modular system');\n            \n            // Setup animation for each element using the changes already detected\n            elementsToAnimate.forEach(({ element, sourceElement, changes }) => {\n              console.log('DEBUG: Processing element with changes:', changes);\n              \n              // Convert the detected changes to animation changes\n              const animationChanges = [];\n              \n              // Handle position changes\n              if (changes.positionX && changes.positionX.changed) {\n                animationChanges.push({\n                  type: AnimationType.TRANSFORM,\n                  property: 'translateX',\n                  sourceValue: changes.positionX.sourceValue,\n                  targetValue: changes.positionX.targetValue,\n                  changed: true,\n                  translationCondition: TranslationCondition.ABSOLUTE\n                });\n              }\n              \n              if (changes.positionY && changes.positionY.changed) {\n                animationChanges.push({\n                  type: AnimationType.TRANSFORM,\n                  property: 'translateY',\n                  sourceValue: changes.positionY.sourceValue,\n                  targetValue: changes.positionY.targetValue,\n                  changed: true,\n                  translationCondition: TranslationCondition.ABSOLUTE\n                });\n              }\n              \n              // Handle color changes\n              if (changes.backgroundColor && changes.backgroundColor.changed) {\n                animationChanges.push({\n                  type: AnimationType.SIMPLE,\n                  property: 'backgroundColor',\n                  sourceValue: changes.backgroundColor.sourceValue,\n                  targetValue: changes.backgroundColor.targetValue,\n                  changed: true\n                });\n              }\n              \n              if (changes.color && changes.color.changed) {\n                animationChanges.push({\n                  type: AnimationType.SIMPLE,\n                  property: 'color',\n                  sourceValue: changes.color.sourceValue,\n                  targetValue: changes.color.targetValue,\n                  changed: true\n                });\n              }\n              \n              // Handle alignment changes\n              if (changes.justifyContent && changes.justifyContent.changed) {\n                // Calculate the position difference that the alignment change creates\n                const parent = element.parentElement;\n                if (parent) {\n                  const parentRect = parent.getBoundingClientRect();\n                  const elementRect = element.getBoundingClientRect();\n                  const elementWidth = elementRect.width;\n                  \n                  // Calculate current position relative to parent\n                  const currentLeft = elementRect.left - parentRect.left;\n                  \n                  // Calculate target position based on alignment change\n                  let targetLeft = currentLeft;\n                  if (changes.justifyContent.targetValue === 'flex-end') {\n                    targetLeft = parentRect.width - elementWidth;\n                  } else if (changes.justifyContent.targetValue === 'center') {\n                    targetLeft = (parentRect.width - elementWidth) / 2;\n                  } else if (changes.justifyContent.targetValue === 'flex-start') {\n                    targetLeft = 0;\n                  }\n                  \n                  // Only animate if there's actually a position difference\n                  if (Math.abs(currentLeft - targetLeft) > 1) {\n                    console.log('DEBUG: Calculating justifyContent position animation:', {\n                      currentLeft: currentLeft,\n                      targetLeft: targetLeft,\n                      justifyContent: changes.justifyContent.targetValue,\n                      parentWidth: parentRect.width,\n                      elementWidth: elementWidth\n                    });\n                    \n                    // Animate the position, NOT the alignment\n                    element.style.transition = `left ${duration}s ${easingFunction}`;\n                    element.style.left = `${targetLeft}px`;\n                    \n                    console.log('DEBUG: Applied justifyContent position animation:', {\n                      property: 'left',\n                      transitionProperty: 'left',\n                      targetValue: `${targetLeft}px`\n                    });\n                  } else {\n                    console.log('DEBUG: JustifyContent change detected but no position difference - skipping animation');\n                  }\n                  \n                  // Don't add to animationChanges array since we're handling it directly\n                  return;\n                }\n              }\n              \n              if (changes.alignItems && changes.alignItems.changed) {\n                // Calculate the position difference that the alignment change creates\n                const parent = element.parentElement;\n                if (parent) {\n                  const parentRect = parent.getBoundingClientRect();\n                  const elementRect = element.getBoundingClientRect();\n                  const elementHeight = elementRect.height;\n                  \n                  // Calculate current position relative to parent\n                  const currentTop = elementRect.top - parentRect.top;\n                  \n                  // Calculate target position based on alignment change\n                  let targetTop = currentTop;\n                  if (changes.alignItems.targetValue === 'flex-end') {\n                    targetTop = parentRect.height - elementHeight;\n                  } else if (changes.alignItems.targetValue === 'center') {\n                    targetTop = (parentRect.height - elementHeight) / 2;\n                  } else if (changes.alignItems.targetValue === 'flex-start') {\n                    targetTop = 0;\n                  }\n                  \n                  // Only animate if there's actually a position difference\n                  if (Math.abs(currentTop - targetTop) > 1) {\n                    console.log('DEBUG: Calculating alignItems position animation:', {\n                      currentTop: currentTop,\n                      targetTop: targetTop,\n                      alignItems: changes.alignItems.targetValue,\n                      parentHeight: parentRect.height,\n                      elementHeight: elementHeight\n                    });\n                    \n                    // Animate the position, NOT the alignment\n                    element.style.transition = `top ${duration}s ${easingFunction}`;\n                    element.style.top = `${targetTop}px`;\n                    \n                    console.log('DEBUG: Applied alignItems position animation:', {\n                      property: 'top',\n                      transitionProperty: 'top',\n                      targetValue: `${targetTop}px`\n                    });\n                  } else {\n                    console.log('DEBUG: AlignItems change detected but no position difference - skipping animation');\n                  }\n                  \n                  // Don't add to animationChanges array since we're handling it directly\n                  return;\n                }\n              }\n              \n              // Note: justifyContent and alignItems changes are handled directly above\n              // and only applied if there's an actual position difference\n              \n              console.log('DEBUG: Converted to animation changes:', animationChanges);\n              \n                          // Apply each change\n            animationChanges.forEach(change => {\n              applyAnimationChange(element, change, duration, easingFunction);\n            });\n          });\n          \n          // Force reflow\n          copy.offsetHeight;\n          \n\n          \n\n            \n\n            \n            // Monitor animation progress using transition end events\n            let completedAnimations = 0;\n            const totalAnimations = elementsToAnimate.length;\n            \n            console.log('DEBUG: Setting up animation monitoring for', totalAnimations, 'elements');\n            \n            // Track which elements have actually been animated and their transition properties\n            const animatedElementsSet = new Set();\n            const transitionProperties = new Map(); // Track which properties are being transitioned\n            \n            // Also track which elements have been processed to avoid double-counting\n            const processedElements = new Set();\n            \n            // Track if animation has completed to stop sub-frame tracking\n            let animationCompleted = false;\n            \n            // Set up transition properties for monitoring\n            elementsToAnimate.forEach(({ element, changes }, index) => {\n              const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n              const elementProperties = [];\n              \n              if (changes.positionX && changes.positionX.changed) {\n                elementProperties.push('left', 'top');\n              }\n              if (changes.positionY && changes.positionY.changed) {\n                elementProperties.push('left', 'top');\n              }\n              if (changes.backgroundColor && changes.backgroundColor.changed) {\n                elementProperties.push('background-color');\n              }\n              if (changes.color && changes.color.changed) {\n                elementProperties.push('color');\n              }\n              if (changes.justifyContent && changes.justifyContent.changed) {\n                elementProperties.push('left');\n              }\n              if (changes.alignItems && changes.alignItems.changed) {\n                elementProperties.push('top');\n              }\n              \n              // Remove duplicates and set the properties\n              const uniqueProperties = [...new Set(elementProperties)];\n              transitionProperties.set(element, uniqueProperties);\n            });\n            \n            const onTransitionEnd = (event) => {\n              const targetElement = event.target;\n              const propertyName = event.propertyName;\n              \n              console.log('\uD83C\uDFAF TRANSITION END EVENT:', {\n                targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'),\n                propertyName: propertyName,\n                timestamp: Date.now()\n              });\n              \n              // Find which element this transition belongs to\n              const animatedElement = elementsToAnimate.find(({ element }) => \n                targetElement === element || element.contains(targetElement)\n              );\n              \n              if (animatedElement) {\n                const elementKey = animatedElement.element;\n                const expectedProperties = transitionProperties.get(elementKey) || [];\n                \n                // Check if this is a property we're expecting to transition\n                if (expectedProperties.includes(propertyName)) {\n                  // Remove this property from the expected list\n                  const updatedProperties = expectedProperties.filter(p => p !== propertyName);\n                  transitionProperties.set(elementKey, updatedProperties);\n                  \n                  // If all properties for this element have completed, mark the element as done\n                                  if (updatedProperties.length === 0 && !animatedElementsSet.has(elementKey)) {\n                  animatedElementsSet.add(elementKey);\n                  completedAnimations++;\n                  \n                  if (completedAnimations >= totalAnimations) {\n                    console.log('\uD83C\uDFAF All animations completed via transition end');\n                    animationCompleted = true;\n                    copy.removeEventListener('transitionend', onTransitionEnd);\n                    copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                    childElements.forEach(child => {\n                      child.removeEventListener('transitionend', onTransitionEnd);\n                    });\n                    clearTimeout(fallbackTimeout);\n                    clearInterval(intervalId);\n                    clearInterval(subFrameInterval);\n                    resolve();\n                  }\n                }\n                }\n              } else {\n                // Check if this is a child element that might be part of an animated element\n                const parentAnimatedElement = elementsToAnimate.find(({ element }) => \n                  element.contains(targetElement)\n                );\n                \n                if (parentAnimatedElement && !processedElements.has(targetElement)) {\n                  processedElements.add(targetElement);\n                  \n                  // For child elements, we'll use a simpler approach - just count unique elements\n                  const elementKey = parentAnimatedElement.element;\n                  if (!animatedElementsSet.has(elementKey)) {\n                    animatedElementsSet.add(elementKey);\n                    completedAnimations++;\n                    \n                    if (completedAnimations >= totalAnimations) {\n                      console.log('\uD83C\uDFAF All animations completed via child transition');\n                      animationCompleted = true;\n                      copy.removeEventListener('transitionend', onTransitionEnd);\n                      copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                      childElements.forEach(child => {\n                        child.removeEventListener('transitionend', onTransitionEnd);\n                      });\n                      clearTimeout(fallbackTimeout);\n                      clearInterval(intervalId);\n                      clearInterval(subFrameInterval);\n                      resolve();\n                    }\n                  }\n                }\n              }\n            };\n            \n            // Add a more aggressive monitoring approach - check if animations are actually complete\n            const checkAnimationProgress = () => {\n              let actuallyCompleted = 0;\n              elementsToAnimate.forEach(({ element, changes }) => {\n                const computedStyle = window.getComputedStyle(element);\n                const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n                \n                // Log current position every frame for debugging\n                const currentLeft = parseFloat(computedStyle.left) || 0;\n                const currentTop = parseFloat(computedStyle.top) || 0;\n                const currentTransform = computedStyle.transform;\n                \n                console.log('\uD83C\uDFAF FRAME POSITION:', {\n                  elementName: elementName,\n                  currentLeft: currentLeft,\n                  currentTop: currentTop,\n                  transform: currentTransform,\n                  transition: computedStyle.transition,\n                  timestamp: Date.now()\n                });\n                \n                // Check if the element has reached its target position\n                let isComplete = false;\n                \n                if (changes.positionY && changes.positionY.changed) {\n                  const targetTop = changes.positionY.targetValue;\n                  const difference = Math.abs(currentTop - targetTop);\n                  \n                  if (difference < 5) { // Allow for small rounding differences\n                    isComplete = true;\n                  }\n                }\n                \n                if (changes.positionX && changes.positionX.changed) {\n                  const targetLeft = changes.positionX.targetValue;\n                  const difference = Math.abs(currentLeft - targetLeft);\n                  \n                  if (difference < 5) { // Allow for small rounding differences\n                    isComplete = true;\n                  }\n                }\n                \n                if (isComplete && !animatedElementsSet.has(element)) {\n                  console.log('\uD83C\uDFAF POSITION CHECK COMPLETED:', {\n                    elementName: elementName,\n                    currentLeft: currentLeft,\n                    currentTop: currentTop,\n                    targetLeft: changes.positionX?.targetValue || 0,\n                    targetTop: changes.positionY?.targetValue || 0,\n                    timestamp: Date.now()\n                  });\n                  animatedElementsSet.add(element);\n                  actuallyCompleted++;\n                }\n              });\n              \n              if (actuallyCompleted > 0) {\n                completedAnimations += actuallyCompleted;\n                \n                if (completedAnimations >= totalAnimations) {\n                  console.log('\uD83C\uDFAF All animations completed via position check');\n                  animationCompleted = true;\n                  copy.removeEventListener('transitionend', onTransitionEnd);\n                  copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                  childElements.forEach(child => {\n                    child.removeEventListener('transitionend', onTransitionEnd);\n                  });\n                  clearInterval(intervalId);\n                  clearInterval(subFrameInterval);\n                  resolve();\n                }\n              }\n            };\n            \n            // Log animation start details\n            console.log('\uD83C\uDFAC ANIMATION START:', {\n              totalElements: elementsToAnimate.length,\n              transitionType: transitionType,\n              transitionDuration: transitionDuration,\n              easingFunction: getEasingFunction(transitionType),\n              elements: elementsToAnimate.map(({ element, changes }) => ({\n                elementName: element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id'),\n                initialLeft: parseFloat(window.getComputedStyle(element).left) || 0,\n                initialTop: parseFloat(window.getComputedStyle(element).top) || 0,\n                targetLeft: changes.positionX?.targetValue || 0,\n                targetTop: changes.positionY?.targetValue || 0,\n                hasPositionX: changes.positionX?.changed || false,\n                hasPositionY: changes.positionY?.changed || false\n              }))\n            });\n            \n            // Add detailed sub-frame position tracking\n            let subFrameCount = 0;\n            const subFrameStartTime = Date.now();\n            \n            const detailedPositionTracker = () => {\n              // Stop tracking if animation has completed\n              if (animationCompleted) {\n                return;\n              }\n              \n              subFrameCount++;\n              const currentTime = Date.now();\n              const elapsed = currentTime - subFrameStartTime;\n              \n              elementsToAnimate.forEach(({ element, changes }) => {\n                const computedStyle = window.getComputedStyle(element);\n                const currentLeft = parseFloat(computedStyle.left) || 0;\n                const currentTop = parseFloat(computedStyle.top) || 0;\n                const targetLeft = changes.positionX?.targetValue || 0;\n                const targetTop = changes.positionY?.targetValue || 0;\n                \n                console.log('\uD83C\uDFAF SUB-FRAME ' + subFrameCount + ' (' + elapsed + 'ms):', {\n                  elementName: element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id'),\n                  currentLeft: currentLeft.toFixed(4),\n                  currentTop: currentTop.toFixed(4),\n                  targetLeft: targetLeft.toFixed(4),\n                  targetTop: targetTop.toFixed(4),\n                  leftDifference: (currentLeft - targetLeft).toFixed(4),\n                  topDifference: (currentTop - targetTop).toFixed(4),\n                  leftMovement: (currentLeft - (parseFloat(window.getComputedStyle(element).left) || 0)).toFixed(4),\n                  transition: computedStyle.transition,\n                  transform: computedStyle.transform,\n                  timestamp: currentTime\n                });\n              });\n            };\n            \n            // Track positions every 16ms (60fps) for detailed analysis\n            const subFrameInterval = setInterval(detailedPositionTracker, 16);\n            \n            // Stop detailed tracking after animation duration + buffer\n            setTimeout(() => {\n              clearInterval(subFrameInterval);\n              console.log('\uD83C\uDFAF SUB-FRAME TRACKING COMPLETED');\n              \n                      // CRITICAL FIX: Stop all animation monitoring when the animation should be complete\n        // This prevents the monitoring from continuing to track the destination variant\n        if (!animationCompleted) {\n          console.log('\uD83C\uDFAF FORCING ANIMATION COMPLETION - stopping all monitoring');\n          animationCompleted = true;\n          copy.removeEventListener('transitionend', onTransitionEnd);\n          copy.removeEventListener('transitionend', onCopyTransitionEnd);\n          childElements.forEach(child => {\n            child.removeEventListener('transitionend', onTransitionEnd);\n          });\n          clearTimeout(fallbackTimeout);\n          clearInterval(intervalId);\n          clearInterval(subFrameInterval);\n          \n          // CRITICAL FIX: Ensure the copy has the final position before resolving\n          elementsToAnimate.forEach(({ element, changes }) => {\n            const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n            const computedStyle = window.getComputedStyle(element);\n            console.log('\uD83C\uDFAF FINAL POSITION BEFORE RESOLVE:', {\n              elementName: elementName,\n              finalLeft: computedStyle.left,\n              finalTop: computedStyle.top,\n              targetLeft: changes.positionX?.targetValue || 0,\n              targetTop: changes.positionY?.targetValue || 0\n            });\n          });\n          \n          resolve();\n        }\n            }, parseFloat(transitionDuration || '0.3') * 1000 + 500);\n            \n            // Add frame counter for tracking\n            let frameCount = 0;\n            const originalCheckAnimationProgress = checkAnimationProgress;\n            const enhancedCheckAnimationProgress = () => {\n              frameCount++;\n              console.log('\uD83C\uDFAF FRAME ' + frameCount + ':');\n              originalCheckAnimationProgress();\n            };\n            \n            // Set up periodic position checking with enhanced logging\n            const progressCheckInterval = setInterval(enhancedCheckAnimationProgress, 100); // Check every 100ms\n            \n            // Store the interval ID so we can clear it later\n            const intervalId = progressCheckInterval;\n            \n            // Also listen for transitions on the copy element itself\n            const onCopyTransitionEnd = (event) => {\n              const propertyName = event.propertyName;\n              \n              // Since the copy itself isn't animated, we need to find which child element this transition belongs to\n              // The transition end event on the copy usually means one of its animated children has completed\n              const animatedElement = elementsToAnimate.find(({ element }) => \n                copy.contains(element)\n              );\n              \n              if (animatedElement) {\n                const elementKey = animatedElement.element;\n                const expectedProperties = transitionProperties.get(elementKey) || [];\n                \n                // Check if this is a property we're expecting to transition\n                if (expectedProperties.includes(propertyName)) {\n                  // Remove this property from the expected list\n                  const updatedProperties = expectedProperties.filter(p => p !== propertyName);\n                  transitionProperties.set(elementKey, updatedProperties);\n                  \n                  // If all properties for this element have completed, mark the element as done\n                  if (updatedProperties.length === 0 && !animatedElements.has(elementKey)) {\n                    animatedElements.add(elementKey);\n                    completedAnimations++;\n                    \n                    if (completedAnimations >= totalAnimations) {\n                      console.log('\uD83C\uDFAF All animations completed via property completion');\n                      animationCompleted = true;\n                      copy.removeEventListener('transitionend', onTransitionEnd);\n                      copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                      childElements.forEach(child => {\n                        child.removeEventListener('transitionend', onTransitionEnd);\n                      });\n                      clearTimeout(fallbackTimeout);\n                      clearInterval(intervalId);\n                      clearInterval(subFrameInterval);\n                      resolve();\n                    }\n                  }\n                }\n              }\n            };\n            \n            // Add transition end listener to the copy element and all its children\n            copy.addEventListener('transitionend', onTransitionEnd);\n            copy.addEventListener('transitionend', onCopyTransitionEnd);\n            \n            // Also listen for transitions on child elements that might be animated\n            const childElements = copy.querySelectorAll('*');\n            childElements.forEach(child => {\n              child.addEventListener('transitionend', onTransitionEnd);\n            });\n            \n            // Fallback timeout in case transition events don't fire\n            const fallbackTimeout = setTimeout(() => {\n              // Check if animations are actually complete by examining the computed styles\n              let actuallyCompleted = 0;\n              elementsToAnimate.forEach(({ element, changes }) => {\n                const computedStyle = window.getComputedStyle(element);\n                \n                // If transition is 'none' or empty, animation is likely complete\n                if (!computedStyle.transition || computedStyle.transition === 'none' || computedStyle.transition === 'all 0s ease 0s') {\n                  actuallyCompleted++;\n                }\n              });\n              \n              console.log('\uD83C\uDFAF All animations completed via fallback timeout');\n              animationCompleted = true;\n              copy.removeEventListener('transitionend', onTransitionEnd);\n              copy.removeEventListener('transitionend', onCopyTransitionEnd);\n              childElements.forEach(child => {\n                child.removeEventListener('transitionend', onTransitionEnd);\n              });\n              clearInterval(intervalId);\n              clearInterval(subFrameInterval);\n              resolve();\n            }, parseFloat(transitionDuration || '0.3') * 1000 + 2000); // Add 2s buffer for more reliability\n          } else {\n            resolve();\n          }\n        });\n      }\n      \n      // Helper function to get node data from element (placeholder)\n      function getNodeDataFromElement(element) {\n        // This would need to be implemented to extract Figma node data from DOM elements\n        // For now, return a basic structure\n        return {\n          type: element.getAttribute('data-figma-type') || 'UNKNOWN',\n          layoutPositioning: element.getAttribute('data-layout-positioning') || 'AUTO',\n          layoutMode: element.getAttribute('data-layout-mode') || 'NONE'\n        };\n      }\n      \n      // Helper function to find elements with property changes\n      function findElementsWithPropertyChanges(targetVariant, currentVariant, originalSourceVariant) {\n        if (!currentVariant) {\n          return [];\n        }\n        \n        const targetElements = targetVariant.querySelectorAll('[data-figma-id]');\n        const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');\n        const sourceElementMap = new Map();\n        const elementsToAnimate = [];\n\n        // Build source element map by name\n        sourceElements.forEach(function(sourceElement) {\n          const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');\n          if (sourceName) {\n            sourceElementMap.set(sourceName, sourceElement);\n          }\n        });\n\n        // Analyze each target element for property changes\n        targetElements.forEach(function(element, index) {\n          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n          const sourceElement = sourceElementMap.get(targetName);\n          \n          if (sourceElement) {\n            const changes = detectPropertyChanges(element, sourceElement, originalSourceVariant);\n            \n            if (changes.hasChanges) {\n              elementsToAnimate.push({\n                element: sourceElement,  // Use SOURCE element (from copy) instead of target\n                sourceElement: sourceElement,\n                changes: changes\n              });\n            }\n          }\n        });\n        \n        return elementsToAnimate;\n      }\n\n      // Helper function to detect property changes between elements\n      function detectPropertyChanges(targetElement, sourceElement, originalSourceVariant) {\n        const changes = {\n          hasChanges: false,\n          positionX: { changed: false, sourceValue: null, targetValue: null },\n          positionY: { changed: false, sourceValue: null, targetValue: null },\n          backgroundColor: { changed: false, sourceValue: null, targetValue: null },\n          color: { changed: false, sourceValue: null, targetValue: null },\n          justifyContent: { changed: false, sourceValue: null, targetValue: null },\n          alignItems: { changed: false, sourceValue: null, targetValue: null }\n        };\n\n        try {\n          const sourceStyle = window.getComputedStyle(sourceElement);\n          const targetStyle = window.getComputedStyle(targetElement);\n          \n          // STEP 1: Check if the node has position changes using bounding rectangles (accounts for flexbox alignment)\n          const targetRect = targetElement.getBoundingClientRect();\n          \n          // Get parent rectangles for relative positioning\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          const targetParentRect = targetParent ? targetParent.getBoundingClientRect() : { left: 0, top: 0 };\n          \n          // For the source element (copy), use computed styles since it's positioned absolutely\n          // For the target element, use bounding rect for accurate positioning\n          // Calculate the position differences between source and target\n          // Use the original source element's position, not the copy's position\n          const originalSourceElement = originalSourceVariant.querySelector('[data-figma-name=\"' + sourceElement.getAttribute('data-figma-name') + '\"]');\n          const originalSourceStyle = originalSourceElement ? window.getComputedStyle(originalSourceElement) : sourceStyle;\n          const originalSourceRect = originalSourceElement ? originalSourceElement.getBoundingClientRect() : sourceElement.getBoundingClientRect();\n          const originalSourceParent = originalSourceElement ? originalSourceElement.parentElement : sourceElement.parentElement;\n          const originalSourceParentRect = originalSourceParent ? originalSourceParent.getBoundingClientRect() : sourceParentRect;\n          \n          // Calculate positions based on element centers, not top-left corners\n          const sourceCenterX = originalSourceRect.left + originalSourceRect.width / 2 - originalSourceParentRect.left;\n          const sourceCenterY = originalSourceRect.top + originalSourceRect.height / 2 - originalSourceParentRect.top;\n          const targetCenterX = targetRect.left + targetRect.width / 2 - targetParentRect.left;\n          const targetCenterY = targetRect.top + targetRect.height / 2 - targetParentRect.top;\n          \n          // Convert center positions back to top-left positions for the element\n          const sourceLeft = sourceCenterX - originalSourceRect.width / 2;\n          const sourceTop = sourceCenterY - originalSourceRect.height / 2;\n          const targetLeft = targetCenterX - targetRect.width / 2;\n          const targetTop = targetCenterY - targetRect.height / 2;\n          \n          // STEP 2: Check if the node has ignore auto layout enabled\n          const ignoreAutoLayout = sourceElement.getAttribute('data-layout-positioning') === 'ABSOLUTE';\n          \n          // STEP 3: Check if the node's parent has auto layout\n          const parentHasAutoLayout = sourceParent && targetParent && \n            sourceParent.getAttribute('data-layout-mode') && \n            sourceParent.getAttribute('data-layout-mode') !== 'NONE';\n          \n\n          \n          // Determine if this node should be animated based on the 3-point logic\n          let shouldAnimatePosition = false;\n          let animationType = 'ABSOLUTE';\n          \n          if (Math.abs(sourceLeft - targetLeft) > 1 || Math.abs(sourceTop - targetTop) > 1) {\n            // Node has position changes\n            if (ignoreAutoLayout) {\n              // Node ignores auto layout - animate absolutely\n              shouldAnimatePosition = true;\n              animationType = 'ABSOLUTE';\n              console.log('DEBUG: Node has position changes and ignores auto layout - animating absolutely');\n            } else if (!parentHasAutoLayout) {\n              // Node's parent doesn't have auto layout - animate absolutely\n              shouldAnimatePosition = true;\n              animationType = 'ABSOLUTE';\n              console.log('DEBUG: Node has position changes and parent has no auto layout - animating absolutely');\n            } else {\n              // Node has position changes and parent has auto layout - ANIMATE the node\n              // The node moves due to parent's alignment changes, so we animate it smoothly\n              shouldAnimatePosition = true;\n              animationType = 'ABSOLUTE';\n              console.log('DEBUG: Node has position changes and parent has auto layout - ANIMATING (node moves due to parent alignment)');\n            }\n          } else {\n            // No position changes - no animation needed\n            shouldAnimatePosition = false;\n            console.log('DEBUG: No position changes detected - no animation needed');\n          }\n          \n          // Apply position changes if animation is needed\n          if (shouldAnimatePosition) {\n            if (Math.abs(sourceLeft - targetLeft) > 1) {\n              changes.positionX.changed = true;\n              changes.positionX.sourceValue = 0; // Start from 0 (additive animation)\n              changes.positionX.targetValue = targetLeft - sourceLeft; // Add the difference to current position\n              changes.hasChanges = true;\n              \n              // Debug the position calculation\n              console.log('DEBUG: Additive position calculation for X:', {\n                sourceLeft: sourceLeft,\n                targetLeft: targetLeft,\n                difference: targetLeft - sourceLeft,\n                elementName: sourceElement.getAttribute('data-figma-name')\n              });\n            }\n            \n            if (Math.abs(sourceTop - targetTop) > 1) {\n              changes.positionY.changed = true;\n              changes.positionY.sourceValue = 0; // Start from 0 (additive animation)\n              changes.positionY.targetValue = targetTop - sourceTop; // Add the difference to current position\n              changes.hasChanges = true;\n              \n              // Debug the position calculation\n              console.log('DEBUG: Additive position calculation for Y:', {\n                sourceTop: sourceTop,\n                targetTop: targetTop,\n                difference: targetTop - sourceTop,\n                elementName: sourceElement.getAttribute('data-figma-name')\n              });\n            }\n          }\n\n          // Check style changes (non-position)\n          const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';\n          const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';\n          \n          if (sourceBg !== targetBg) {\n            changes.backgroundColor.changed = true;\n            changes.backgroundColor.sourceValue = sourceBg;\n            changes.backgroundColor.targetValue = targetBg;\n            changes.hasChanges = true;\n          }\n          \n          if (sourceStyle.color !== targetStyle.color) {\n            changes.color.changed = true;\n            changes.color.sourceValue = sourceStyle.color;\n            changes.color.targetValue = targetStyle.color;\n            changes.hasChanges = true;\n          }\n          \n          // Only mark alignment changes as requiring animation if there's an actual position difference\n          if (sourceStyle.justifyContent !== targetStyle.justifyContent) {\n            changes.justifyContent.changed = true;\n            changes.justifyContent.sourceValue = sourceStyle.justifyContent;\n            changes.justifyContent.targetValue = targetStyle.justifyContent;\n            \n            // Only set hasChanges if there's an actual position difference to animate\n            if (shouldAnimatePosition) {\n              changes.hasChanges = true;\n            }\n          }\n          \n          if (sourceStyle.alignItems !== targetStyle.alignItems) {\n            changes.alignItems.changed = true;\n            changes.alignItems.sourceValue = sourceStyle.alignItems;\n            changes.alignItems.targetValue = targetStyle.alignItems;\n            \n            // Only set hasChanges if there's an actual position difference to animate\n            if (shouldAnimatePosition) {\n              changes.hasChanges = true;\n            }\n          }\n        } catch (error) {\n          console.error('Error detecting property changes:', error);\n        }\n\n        return changes;\n      }\n      \n      // Helper function to handle animated variant switching\n      async function handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration) {\n        console.log('DEBUG: Starting modular animated variant switch');\n        console.log('DEBUG: About to create element copy');\n        \n        // Create a copy of the source variant\n        const sourceCopy = createElementCopy(sourceElement);\n        console.log('DEBUG: Element copy created successfully');\n        \n        // Insert the copy into the DOM\n        const sourceParent = sourceElement.parentElement;\n        sourceParent.appendChild(sourceCopy);\n        console.log('DEBUG: Copy inserted into DOM');\n        \n        // Log the copy's position and visibility after insertion\n        const copyRect = sourceCopy.getBoundingClientRect();\n        const copyStyle = window.getComputedStyle(sourceCopy);\n        console.log('DEBUG: Copy after insertion:');\n        console.log('  position: ' + copyStyle.position);\n        console.log('  top: ' + copyStyle.top);\n        console.log('  left: ' + copyStyle.left);\n        console.log('  z-index: ' + copyStyle.zIndex);\n        console.log('  opacity: ' + copyStyle.opacity);\n        console.log('  visibility: ' + copyStyle.visibility);\n        console.log('  display: ' + copyStyle.display);\n        console.log('  bounding rect: ' + copyRect);\n        \n        // Hide the original source element and all other variants\n        sourceElement.style.opacity = '0';\n        sourceElement.style.visibility = 'hidden';\n        \n        allVariants.forEach(variant => {\n          if (variant !== sourceElement) {\n            variant.style.opacity = '0';\n            variant.style.visibility = 'hidden';\n          }\n        });\n        \n        // Prepare the destination variant but keep it hidden for now\n        destination.classList.add('variant-active');\n        destination.classList.remove('variant-hidden');\n        destination.style.visibility = 'hidden';\n        destination.style.opacity = '0';\n        \n        // DON'T pre-position the destination variant - let the copy do all the animation work\n        // The destination variant should remain in its natural position\n        \n        // Force reflow\n        destination.offsetHeight;\n        \n        // Animate the copy to match the destination\n        await animateCopyToDestination(sourceCopy, destination, sourceElement, transitionType, transitionDuration);\n        \n        // Animation complete - simply remove the copy and show the destination variant\n        console.log('DEBUG: Animation completed, removing copy and showing destination variant');\n        sourceCopy.remove();\n        \n        // Hide the original source element permanently\n        sourceElement.style.opacity = '0';\n        sourceElement.style.visibility = 'hidden';\n        sourceElement.classList.add('variant-hidden');\n        sourceElement.classList.remove('variant-active');\n        \n        // Simply show the destination variant - don't touch its positioning\n        console.log('DEBUG: Showing destination variant');\n        destination.style.visibility = 'visible';\n        destination.style.opacity = '1';\n        destination.style.display = 'flex';\n        destination.classList.add('variant-active');\n        destination.classList.remove('variant-hidden');\n        \n        // Hide all other variants\n        allVariants.forEach(variant => {\n          if (variant !== destination) {\n            variant.classList.add('variant-hidden');\n            variant.classList.remove('variant-active');\n            // Don't reset positions for hidden variants - let them keep their natural positions\n            if (!variant.style.position || variant.style.position === 'static') {\n              variant.style.position = 'relative';\n            }\n            variant.style.opacity = '0';\n            variant.style.visibility = 'hidden';\n          }\n        });\n        \n        // Force a reflow to ensure the position changes are applied before starting reactions\n        destination.offsetHeight;\n        \n        // Start timeout reactions\n        startTimeoutReactionsForNewlyActiveVariant(destination);\n        startTimeoutReactionsForNestedComponents(destination);\n      }\n      \n      // Helper function to perform instant variant switch\n      function performInstantVariantSwitch(allVariants, destination) {\n        // Hide all variants\n        allVariants.forEach(variant => {\n          variant.classList.add('variant-hidden');\n          variant.classList.remove('variant-active');\n          // Don't reset positions for hidden variants - let them keep their natural positions\n          if (!variant.style.position || variant.style.position === 'static') {\n            variant.style.position = 'relative';\n          }\n        });\n        \n        // Show destination variant\n        destination.classList.add('variant-active');\n        destination.classList.remove('variant-hidden');\n        // Don't reset position for destination - let it keep its natural position\n        if (!destination.style.position || destination.style.position === 'static') {\n          destination.style.position = 'relative';\n        }\n        \n        // Start timeout reactions\n        startTimeoutReactionsForNewlyActiveVariant(destination);\n        startTimeoutReactionsForNestedComponents(destination);\n      }\n      \n      // Main reaction handler function\n      function handleReaction(sourceElement, destinationId, transitionType, transitionDuration) {\n        // Prevent multiple simultaneous transitions\n        if (isTransitionInProgress) {\n          return;\n        }\n        \n        // Set transition lock\n        isTransitionInProgress = true;\n        \n        // Safety timeout\n        const safetyTimeout = setTimeout(() => {\n          if (isTransitionInProgress) {\n            console.log('WARNING: Transition lock stuck, forcing release');\n            isTransitionInProgress = false;\n            currentTransitionPromise = null;\n          }\n        }, 10000); // Increased to 10 seconds\n        \n        if (destinationId) {\n          const destination = document.querySelector(`[data-figma-id=\"${destinationId}\"]`);\n          \n          if (!destination) {\n            console.error('Destination element not found:', destinationId);\n            clearTimeout(safetyTimeout);\n            isTransitionInProgress = false;\n            return;\n          }\n          \n          // Check if this is a variant switch within a component set\n          const sourceComponentSet = sourceElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const destinationComponentSet = destination.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          \n          if (sourceComponentSet && destinationComponentSet && sourceComponentSet === destinationComponentSet) {\n            // This is a variant switch\n            const componentSet = sourceComponentSet;\n            const allVariants = Array.from(componentSet.children).filter(child => \n              child.getAttribute('data-figma-type') === 'COMPONENT'\n            );\n            \n            const isAnimated = transitionType === 'SMART_ANIMATE' || \n                              transitionType === 'BOUNCY' || \n                              transitionType === 'EASE_IN_AND_OUT' || \n                              transitionType === 'EASE_IN_AND_OUT_BACK' || \n                              transitionType === 'EASE_IN' || \n                              transitionType === 'EASE_OUT' || \n                              transitionType === 'LINEAR' || \n                              transitionType === 'GENTLE';\n            \n            if (isAnimated) {\n              currentTransitionPromise = handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration)\n                .then(() => {\n                  clearTimeout(safetyTimeout);\n                  isTransitionInProgress = false;\n                  currentTransitionPromise = null;\n                })\n                .catch((error) => {\n                  console.error('Modular animation error:', error);\n                  clearTimeout(safetyTimeout);\n                  isTransitionInProgress = false;\n                  currentTransitionPromise = null;\n                });\n            } else {\n              performInstantVariantSwitch(allVariants, destination);\n              clearTimeout(safetyTimeout);\n              isTransitionInProgress = false;\n              currentTransitionPromise = null;\n            }\n          } else {\n            // This is a regular transition (not variant switching)\n            if (transitionType === 'DISSOLVE') {\n              sourceElement.style.opacity = '0';\n              setTimeout(() => {\n                sourceElement.style.opacity = '1';\n                destination.classList.add('variant-active');\n                destination.classList.remove('variant-hidden');\n                destination.style.opacity = '1';\n                \n                startTimeoutReactionsForNewlyActiveVariant(destination);\n                startTimeoutReactionsForNestedComponents(destination);\n                \n                clearTimeout(safetyTimeout);\n                isTransitionInProgress = false;\n                currentTransitionPromise = null;\n              }, parseFloat(transitionDuration || '300'));\n            } else {\n              sourceElement.style.opacity = '1';\n              destination.classList.add('variant-active');\n              destination.classList.remove('variant-hidden');\n              destination.style.opacity = '1';\n              \n              startTimeoutReactionsForNewlyActiveVariant(destination);\n              startTimeoutReactionsForNestedComponents(destination);\n              \n              clearTimeout(safetyTimeout);\n              isTransitionInProgress = false;\n              currentTransitionPromise = null;\n            }\n          }\n        } else {\n          // Handle case where destinationId is null (final variant - no further transitions)\n          clearTimeout(safetyTimeout);\n          isTransitionInProgress = false;\n          currentTransitionPromise = null;\n        }\n      }\n      \n      // Global timer tracking\n      const activeTimers = new Map();\n      \n      // Function to start timeout reactions for nested components within a parent element\n      function startTimeoutReactionsForNestedComponents(parentElement) {\n        if (!parentElement) return;\n        \n        // Find all nested components with timeout reactions within the parent\n        const nestedComponents = parentElement.querySelectorAll('[data-has-reactions=\"true\"]');\n        \n        nestedComponents.forEach(element => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          const computedStyle = window.getComputedStyle(element);\n          \n          // Only start timers for elements that are actually visible\n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n            \n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId);\n                const actionType = element.getAttribute('data-reaction-action-type');\n                const destinationId = element.getAttribute('data-reaction-destination');\n                const transitionType = element.getAttribute('data-reaction-transition-type');\n                const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n                \n                handleReaction(element, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');\n          }\n        });\n      }\n      \n      // Function to start timeout reactions for a specific newly active variant\n      function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {\n        if (!newlyActiveElement) return;\n        \n        const elementId = newlyActiveElement.getAttribute('data-figma-id');\n        const elementName = newlyActiveElement.getAttribute('data-figma-name');\n        const parentComponent = newlyActiveElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n        const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n        \n        console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);\n        \n        // Only start timers for variants that are actually visible (not hidden by CSS)\n        const computedStyle = window.getComputedStyle(newlyActiveElement);\n        \n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');\n          const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');\n          const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');\n          const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');\n          const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');\n          \n          // Handle timeout reactions only for active variants that don't have an active timer\n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId); // Clear the timer when it completes\n              handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n          } else if (activeTimers.has(elementId)) {\n            console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');\n          }\n          \n          // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant\n          startTimeoutReactionsForNestedComponents(newlyActiveElement);\n        } else {\n          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n        }\n      }\n      \n      // Make function globally available\n      window.handleReaction = handleReaction;\n    ";
}


/***/ }),

/***/ 925:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// Browser-only entry point for the refactored system
// This file only includes code that runs in the browser, not in the Figma plugin
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Import all the event handling and animation modules
__exportStar(__webpack_require__(995), exports);
__exportStar(__webpack_require__(286), exports);
__exportStar(__webpack_require__(821), exports);
__exportStar(__webpack_require__(120), exports);
__exportStar(__webpack_require__(332), exports);
__exportStar(__webpack_require__(82), exports);
__exportStar(__webpack_require__(44), exports);
__exportStar(__webpack_require__(275), exports);
// Import the modular transition handler function
var modular_transition_handler_1 = __webpack_require__(821);
// Store the function for later execution
var modularTransitionHandlerCode = null;
// Function to execute the modular transition handler when needed
function executeModularTransitionHandler() {
    if (!modularTransitionHandlerCode) {
        modularTransitionHandlerCode = (0, modular_transition_handler_1.createModularSmartAnimateHandler)();
    }
    try {
        eval(modularTransitionHandlerCode);
        console.log('DEBUG: Modular transition handler executed successfully');
        return true;
    }
    catch (error) {
        console.error('DEBUG: Error executing modular transition handler:', error);
        return false;
    }
}
// Initialize the system when loaded in browser
if (typeof window !== 'undefined') {
    console.log('DEBUG: Refactored system loaded in browser');
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeSystem);
    }
    else {
        initializeSystem();
    }
}
function initializeSystem() {
    console.log('DEBUG: Initializing refactored system');
    // Execute the modular transition handler to expose handleReaction
    if (executeModularTransitionHandler()) {
        console.log('DEBUG: Modular transition handler executed successfully');
    }
    else {
        console.error('DEBUG: Failed to execute modular transition handler');
    }
    // Check if the function is available
    setTimeout(function () {
        if (window.handleReaction) {
            console.log('DEBUG: handleReaction function is available globally');
        }
        else {
            console.error('DEBUG: handleReaction function not found - the modular transition handler may not be properly loaded');
        }
    }, 100);
    console.log('DEBUG: Refactored system functions available');
}


/***/ }),

/***/ 995:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateEventHandlingJavaScript = exports.generateVariantAttributes = exports.generateReactionAttributes = void 0;
// Re-export from the new modular events structure
var index_1 = __webpack_require__(172);
Object.defineProperty(exports, "generateReactionAttributes", ({ enumerable: true, get: function () { return index_1.generateReactionAttributes; } }));
Object.defineProperty(exports, "generateVariantAttributes", ({ enumerable: true, get: function () { return index_1.generateVariantAttributes; } }));
Object.defineProperty(exports, "generateEventHandlingJavaScript", ({ enumerable: true, get: function () { return index_1.generateEventHandlingJavaScript; } }));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(925);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});