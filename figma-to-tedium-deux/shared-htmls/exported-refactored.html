<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    
    /* iOS-compatible font declarations - using consistent font-family names */
    
    /* TrueType fonts - "CircularXX TT" family with font-weight and font-style variations */
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Thin.ttf") format("truetype");
      font-weight: 100;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-ThinItalic.ttf") format("truetype");
      font-weight: 100;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Light.ttf") format("truetype");
      font-weight: 300;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-LightItalic.ttf") format("truetype");
      font-weight: 300;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Regular.ttf") format("truetype");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Italic.ttf") format("truetype");
      font-weight: 400;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Book.ttf") format("truetype");
      font-weight: 450;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-BookItalic.ttf") format("truetype");
      font-weight: 450;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Medium.ttf") format("truetype");
      font-weight: 500;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-MediumItalic.ttf") format("truetype");
      font-weight: 500;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Bold.ttf") format("truetype");
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-BoldItalic.ttf") format("truetype");
      font-weight: 700;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Black.ttf") format("truetype");
      font-weight: 900;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-BlackItalic.ttf") format("truetype");
      font-weight: 900;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-ExtraBlack.ttf") format("truetype");
      font-weight: 950;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-ExtraBlackItalic.ttf") format("truetype");
      font-weight: 950;
      font-style: italic;
      font-display: swap;
    }
  
    html, body { box-sizing: border-box; margin: 0; padding: 0; width: 100vw; height: 100vh; overflow: hidden; }
    p { margin: 0; }
    /* Component set sizing - only apply 100% if not explicitly set to fixed dimensions */
    /* This ensures components without explicit dimensions fill their container */
    [data-figma-id]:not([style*="width:"]):not([style*="height:"]) { width: 100%; height: 100%; }
    /* Variant visibility classes */
    .variant-active {
      display: flex !important;
    }
    .variant-hidden {
      display: none !important;
    }
    /* Let JavaScript handle component visibility instead of CSS rules */
    /* This allows the variant handler to properly manage which components are visible */
    /* Components will be shown/hidden by the JavaScript variant switching logic */
    /* Dissolve transition overrides */
    .dissolve-source, .dissolve-target {
      display: block !important;
    }
    .dissolve-source {
      opacity: 1;
    }
    .dissolve-target {
      opacity: 0;
    }
    /* Smart animate transition overrides */
    .smart-animate-source, .smart-animate-target {
      display: block !important;
    }
    .smart-animate-source {
      opacity: 1;
    }
    .smart-animate-target {
      opacity: 1;
    }
    /* iOS font loading optimization */
    * {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
  </style>
</head>
<body>
<div data-figma-id="5533:3027" data-figma-name="glydcar/control-panel/button-volume" data-figma-type="INSTANCE" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="10" data-sizing-horizontal="HUG" data-sizing-vertical="HUG" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="0.9995673894882202" data-layout-positioning="AUTO" data-figma-x="7742" data-figma-y="3703" style="position: relative; top: 0px; left: 0px; display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 10px; box-sizing: border-box; width: fit-content; height: fit-content; border-radius: 0px"><div data-figma-id="5355:2813" data-figma-name="glydcar/control-panel/button-volume" data-figma-type="COMPONENT_SET" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="20" data-sizing-horizontal="FILL" data-sizing-vertical="FILL" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="5" data-stroke-weight="1" data-clips-content="true" data-layout-positioning="AUTO" data-figma-x="8332" data-figma-y="3686" style="position: relative; top: 0px; left: 0px; display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 20px; box-sizing: border-box; width: 100%; height: 100%; overflow: hidden"><div data-figma-id="5355:2812" data-figma-name="Property 1=default" data-figma-type="COMPONENT" data-variant-property-1="default" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="10" data-sizing-horizontal="HUG" data-sizing-vertical="HUG" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="0.9995673894882202" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="position: relative; top: 0px; left: 0px; display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 10px; box-sizing: border-box; width: fit-content; height: fit-content; border-radius: 0px"><div data-figma-id="6411:5667" data-figma-name="Frame 1299" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="SPACE_BETWEEN" data-counter-axis="CENTER" data-item-spacing="16" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="1000" data-stroke-weight="1" data-clips-content="true" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="background-color: rgba(31, 31, 30, 1); display: flex; flex-direction: column; justify-content: space-between; align-items: center; gap: 0px; box-sizing: border-box; width: 174.9199981689453px; height: 174.9199981689453px; position: relative; left: 0px; top: 0px; overflow: hidden; border-radius: 1000px"><div data-figma-id="6411:5668" data-figma-name="Frame 1300" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FILL" data-sizing-vertical="FILL" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" data-has-reactions="true" data-reaction-count="1" data-reaction-trigger="{&quot;type&quot;:&quot;ON_CLICK&quot;}" data-reaction-action-type="NODE" data-reaction-destination="5355:2814" data-reaction-transition-type="EASE_OUT" data-reaction-transition-duration="0.6000000238418579" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 100%; height: 100%; position: relative; left: 0px; top: 0px; border-radius: 0px"><svg width="31.650623321533203" height="13.045567512512207" viewBox="0 0 31.650623321533203 13.045567512512207" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="chevron-up">
    <path d="M 15.82565689086914 0 L 31.650623321533203 10.550668716430664 L 29.98712730407715 13.045567512512207 L 15.824966430664062 3.6038966178894043 L 1.6641868352890015 13.045567512512207 L 0 10.54997730255127 L 15.82565689086914 0 Z" 
            fill="rgba(255, 255, 255, 0.75)" 
            stroke="none" 
            stroke-width="2.998702049255371"
            fill-rule="nonzero" />
</g></svg></div>
<div data-figma-id="6411:8627" data-figma-name="Frame 1306" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FILL" data-sizing-vertical="HUG" data-padding-left="0" data-padding-right="0" data-padding-top="12" data-padding-bottom="12" data-opacity="1" data-corner-radius="0" data-stroke-weight="1" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="50.459999084472656" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 100%; height: fit-content; position: relative; left: 0px; top: 0px; padding-top: 12px; padding-bottom: 12px; border-radius: 0px"><p data-figma-id="6411:5670" data-figma-name="Vol" data-figma-type="TEXT" data-sizing-horizontal="FILL" data-sizing-vertical="HUG" data-font-size="21.990480422973633" data-font-weight="400" data-text-align="CENTER" data-letter-spacing="4" data-line-height="114.99999761581421" data-opacity="1" data-stroke-weight="0.11006838828325272" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="12" style="color: rgba(255, 255, 255, 0.5); box-sizing: border-box; width: 100%; height: fit-content; position: relative; left: 0px; top: 0px; font-size: 21.990480422973633px; font-family: CircularXX TT, sans-serif; font-weight: 400; text-align: center; letter-spacing: 4%; line-height: 114.99999761581421%">Vol</p>
<p data-figma-id="6411:8379" data-figma-name="3" data-figma-type="TEXT" data-sizing-horizontal="HUG" data-sizing-vertical="HUG" data-font-size="21.990480422973633" data-font-weight="400" data-text-align="CENTER" data-letter-spacing="4" data-line-height="114.99999761581421" data-opacity="1" data-stroke-weight="0.11006838828325272" data-layout-positioning="AUTO" data-figma-x="80.95999908447266" data-figma-y="37" style="color: rgba(255, 255, 255, 0.75); box-sizing: border-box; width: fit-content; height: fit-content; position: relative; left: 0px; top: 0px; font-size: 21.990480422973633px; font-family: CircularXX TT, sans-serif; font-weight: 400; text-align: center; letter-spacing: 4%; line-height: 114.99999761581421%">3</p></div>
<div data-figma-id="6411:5671" data-figma-name="Frame 1301" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="10" data-sizing-horizontal="FILL" data-sizing-vertical="FILL" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="124.45999908447266" data-has-reactions="true" data-reaction-count="1" data-reaction-trigger="{&quot;type&quot;:&quot;ON_CLICK&quot;}" data-reaction-action-type="NODE" data-reaction-destination="5355:2833" data-reaction-transition-type="EASE_OUT" data-reaction-transition-duration="0.6000000238418579" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 10px; box-sizing: border-box; width: 100%; height: 100%; position: relative; left: 0px; top: 0px; border-radius: 0px"><svg width="31.650623321533203" height="13.045567512512207" viewBox="0 0 31.650623321533203 13.045567512512207" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="chevron-down">
    <path d="M 15.82565689086914 13.045567512512207 L 31.650623321533203 2.494899272918701 L 29.98712730407715 0 L 15.824966430664062 9.441670417785645 L 1.6641868352890015 0 L 0 2.4955897331237793 L 15.82565689086914 13.045567512512207 Z" 
            fill="rgba(255, 255, 255, 0.75)" 
            stroke="none" 
            stroke-width="2.998702049255371"
            fill-rule="nonzero" />
</g></svg></div></div></div>
<div data-figma-id="5355:2814" data-figma-name="Property 1=up" data-figma-type="COMPONENT" data-variant-property-1="up" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="10" data-sizing-horizontal="HUG" data-sizing-vertical="HUG" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="0.9995673894882202" data-layout-positioning="AUTO" data-figma-x="194.9199981689453" data-figma-y="0" data-has-reactions="true" data-reaction-count="1" data-reaction-trigger="{&quot;type&quot;:&quot;AFTER_TIMEOUT&quot;,&quot;timeout&quot;:0.8}" data-reaction-action-type="NODE" data-reaction-destination="5355:2812" data-reaction-transition-type="EASE_OUT" data-reaction-transition-duration="0.30000001192092896" style="position: relative; top: 0px; left: 0px; display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 10px; box-sizing: border-box; width: fit-content; height: fit-content; border-radius: 0px"><div data-figma-id="6411:5643" data-figma-name="Frame 1299" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="SPACE_BETWEEN" data-counter-axis="CENTER" data-item-spacing="16" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="1000" data-stroke-weight="1" data-clips-content="true" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="background-color: rgba(31, 31, 30, 1); display: flex; flex-direction: column; justify-content: space-between; align-items: center; gap: 0px; box-sizing: border-box; width: 174.9199981689453px; height: 174.9199981689453px; position: relative; left: 0px; top: 0px; overflow: hidden; border-radius: 1000px"><div data-figma-id="6411:5653" data-figma-name="Frame 1300" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FILL" data-sizing-vertical="FILL" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="background-color: rgba(255, 255, 255, 1); display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 100%; height: 100%; position: relative; left: 0px; top: 0px; border-radius: 0px"><svg width="31.650623321533203" height="13.045567512512207" viewBox="0 0 31.650623321533203 13.045567512512207" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="chevron-up">
    <path d="M 15.82565689086914 0 L 31.650623321533203 10.550668716430664 L 29.98712730407715 13.045567512512207 L 15.824966430664062 3.6038966178894043 L 1.6641868352890015 13.045567512512207 L 0 10.54997730255127 L 15.82565689086914 0 Z" 
            fill="rgba(0, 0, 0, 0.75)" 
            stroke="none" 
            stroke-width="2.998702049255371"
            fill-rule="nonzero" />
</g></svg></div>
<div data-figma-id="6411:8915" data-figma-name="Frame 1306" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FILL" data-sizing-vertical="HUG" data-padding-left="0" data-padding-right="0" data-padding-top="12" data-padding-bottom="12" data-opacity="1" data-corner-radius="0" data-stroke-weight="1" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="50.459999084472656" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 100%; height: fit-content; position: relative; left: 0px; top: 0px; padding-top: 12px; padding-bottom: 12px; border-radius: 0px"><p data-figma-id="6411:8916" data-figma-name="Vol" data-figma-type="TEXT" data-sizing-horizontal="FILL" data-sizing-vertical="HUG" data-font-size="21.990480422973633" data-font-weight="400" data-text-align="CENTER" data-letter-spacing="4" data-line-height="114.99999761581421" data-opacity="1" data-stroke-weight="0.11006838828325272" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="12" style="color: rgba(255, 255, 255, 0.5); box-sizing: border-box; width: 100%; height: fit-content; position: relative; left: 0px; top: 0px; font-size: 21.990480422973633px; font-family: CircularXX TT, sans-serif; font-weight: 400; text-align: center; letter-spacing: 4%; line-height: 114.99999761581421%">Vol</p>
<p data-figma-id="6411:8917" data-figma-name="3" data-figma-type="TEXT" data-sizing-horizontal="HUG" data-sizing-vertical="HUG" data-font-size="21.990480422973633" data-font-weight="400" data-text-align="CENTER" data-letter-spacing="4" data-line-height="114.99999761581421" data-opacity="1" data-stroke-weight="0.11006838828325272" data-layout-positioning="AUTO" data-figma-x="80.95999908447266" data-figma-y="37" style="color: rgba(255, 255, 255, 0.75); box-sizing: border-box; width: fit-content; height: fit-content; position: relative; left: 0px; top: 0px; font-size: 21.990480422973633px; font-family: CircularXX TT, sans-serif; font-weight: 400; text-align: center; letter-spacing: 4%; line-height: 114.99999761581421%">3</p></div>
<div data-figma-id="6411:5654" data-figma-name="Frame 1301" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="10" data-sizing-horizontal="FILL" data-sizing-vertical="FILL" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="124.45999908447266" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 10px; box-sizing: border-box; width: 100%; height: 100%; position: relative; left: 0px; top: 0px; border-radius: 0px"><svg width="31.650623321533203" height="13.045567512512207" viewBox="0 0 31.650623321533203 13.045567512512207" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="chevron-down">
    <path d="M 15.82565689086914 13.045567512512207 L 31.650623321533203 2.494899272918701 L 29.98712730407715 0 L 15.824966430664062 9.441670417785645 L 1.6641868352890015 0 L 0 2.4955897331237793 L 15.82565689086914 13.045567512512207 Z" 
            fill="rgba(255, 255, 255, 0.75)" 
            stroke="none" 
            stroke-width="2.998702049255371"
            fill-rule="nonzero" />
</g></svg></div></div></div>
<div data-figma-id="5355:2833" data-figma-name="Property 1=down" data-figma-type="COMPONENT" data-variant-property-1="down" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="10" data-sizing-horizontal="HUG" data-sizing-vertical="HUG" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="0.9995673894882202" data-layout-positioning="AUTO" data-figma-x="389.8399963378906" data-figma-y="0" data-has-reactions="true" data-reaction-count="1" data-reaction-trigger="{&quot;type&quot;:&quot;AFTER_TIMEOUT&quot;,&quot;timeout&quot;:0.8}" data-reaction-action-type="NODE" data-reaction-destination="5355:2812" data-reaction-transition-type="EASE_OUT" data-reaction-transition-duration="0.6000000238418579" style="position: relative; top: 0px; left: 0px; display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 10px; box-sizing: border-box; width: fit-content; height: fit-content; border-radius: 0px"><div data-figma-id="6411:5660" data-figma-name="Frame 1299" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="SPACE_BETWEEN" data-counter-axis="CENTER" data-item-spacing="16" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="1000" data-stroke-weight="1" data-clips-content="true" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="background-color: rgba(31, 31, 30, 1); display: flex; flex-direction: column; justify-content: space-between; align-items: center; gap: 0px; box-sizing: border-box; width: 174.9199981689453px; height: 174.9199981689453px; position: relative; left: 0px; top: 0px; overflow: hidden; border-radius: 1000px"><div data-figma-id="6411:5661" data-figma-name="Frame 1300" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FILL" data-sizing-vertical="FILL" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 100%; height: 100%; position: relative; left: 0px; top: 0px; border-radius: 0px"><svg width="31.650623321533203" height="13.045567512512207" viewBox="0 0 31.650623321533203 13.045567512512207" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="chevron-up">
    <path d="M 15.82565689086914 0 L 31.650623321533203 10.550668716430664 L 29.98712730407715 13.045567512512207 L 15.824966430664062 3.6038966178894043 L 1.6641868352890015 13.045567512512207 L 0 10.54997730255127 L 15.82565689086914 0 Z" 
            fill="rgba(255, 255, 255, 0.75)" 
            stroke="none" 
            stroke-width="2.998702049255371"
            fill-rule="nonzero" />
</g></svg></div>
<div data-figma-id="6411:8919" data-figma-name="Frame 1306" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FILL" data-sizing-vertical="HUG" data-padding-left="0" data-padding-right="0" data-padding-top="12" data-padding-bottom="12" data-opacity="1" data-corner-radius="0" data-stroke-weight="1" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="50.459999084472656" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 100%; height: fit-content; position: relative; left: 0px; top: 0px; padding-top: 12px; padding-bottom: 12px; border-radius: 0px"><p data-figma-id="6411:8920" data-figma-name="Vol" data-figma-type="TEXT" data-sizing-horizontal="FILL" data-sizing-vertical="HUG" data-font-size="21.990480422973633" data-font-weight="400" data-text-align="CENTER" data-letter-spacing="4" data-line-height="114.99999761581421" data-opacity="1" data-stroke-weight="0.11006838828325272" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="12" style="color: rgba(255, 255, 255, 0.5); box-sizing: border-box; width: 100%; height: fit-content; position: relative; left: 0px; top: 0px; font-size: 21.990480422973633px; font-family: CircularXX TT, sans-serif; font-weight: 400; text-align: center; letter-spacing: 4%; line-height: 114.99999761581421%">Vol</p>
<p data-figma-id="6411:8921" data-figma-name="3" data-figma-type="TEXT" data-sizing-horizontal="HUG" data-sizing-vertical="HUG" data-font-size="21.990480422973633" data-font-weight="400" data-text-align="CENTER" data-letter-spacing="4" data-line-height="114.99999761581421" data-opacity="1" data-stroke-weight="0.11006838828325272" data-layout-positioning="AUTO" data-figma-x="80.95999908447266" data-figma-y="37" style="color: rgba(255, 255, 255, 0.75); box-sizing: border-box; width: fit-content; height: fit-content; position: relative; left: 0px; top: 0px; font-size: 21.990480422973633px; font-family: CircularXX TT, sans-serif; font-weight: 400; text-align: center; letter-spacing: 4%; line-height: 114.99999761581421%">3</p></div>
<div data-figma-id="6411:5664" data-figma-name="Frame 1301" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="10" data-sizing-horizontal="FILL" data-sizing-vertical="FILL" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="124.45999908447266" style="background-color: rgba(255, 255, 255, 1); display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 10px; box-sizing: border-box; width: 100%; height: 100%; position: relative; left: 0px; top: 0px; border-radius: 0px"><svg width="31.650623321533203" height="13.045567512512207" viewBox="0 0 31.650623321533203 13.045567512512207" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="chevron-down">
    <path d="M 15.82565689086914 13.045567512512207 L 31.650623321533203 2.494899272918701 L 29.98712730407715 0 L 15.824966430664062 9.441670417785645 L 1.6641868352890015 0 L 0 2.4955897331237793 L 15.82565689086914 13.045567512512207 Z" 
            fill="rgba(0, 0, 0, 0.75)" 
            stroke="none" 
            stroke-width="2.998702049255371"
            fill-rule="nonzero" />
</g></svg></div></div></div></div></div>
<script>

    // Event handling for interactive elements
    console.log('DEBUG: Event handling JavaScript loaded');
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DEBUG: DOMContentLoaded event fired');
      
      // Handle variant switching - instant switching only, no animation
      // This is a simple slideshow-like system that switches between variants instantly
      const variantButtons = document.querySelectorAll('[data-variant], [data-variant-property-1]');
      variantButtons.forEach(button => {
        button.addEventListener('click', function() {
          console.log('DEBUG: Variant switch clicked');
          
          const variant = this.getAttribute('data-variant') || this.getAttribute('data-variant-property-1');
          const targetId = this.getAttribute('data-target');
          
          if (targetId) {
            const target = document.querySelector(`[data-figma-id="${targetId}"]`);
            if (target) {
              console.log('Variant switch:', { variant, targetId, targetName: target.getAttribute('data-figma-name') });
              
              // Find the specific component set that contains this button
              let componentSet = target;
              let buttonElement = this;
              
              // Walk up the DOM tree to find the immediate component set parent
              while (buttonElement && buttonElement.parentElement) {
                buttonElement = buttonElement.parentElement;
                if (buttonElement.getAttribute('data-figma-type') === 'COMPONENT_SET') {
                  componentSet = buttonElement;
                  console.log('Found component set for switching:', {
                    id: componentSet.getAttribute('data-figma-id'),
                    name: componentSet.getAttribute('data-figma-name')
                  });
                  break;
                }
              }
              
              // Get all variants within this specific component set instance
              const allVariants = Array.from(componentSet.children).filter(child => 
                child.getAttribute('data-figma-type') === 'COMPONENT' &&
                (child.getAttribute('data-variant') || child.getAttribute('data-variant-property-1'))
              );
              
              console.log('Found', allVariants.length, 'variants in component set:', componentSet.getAttribute('data-figma-id'));
              
              // INSTANT VARIANT SWITCHING - Hide all variants
              allVariants.forEach(variant => {
                variant.classList.add('variant-hidden');
                variant.classList.remove('variant-active');
                // Ensure all variants maintain their original positioning (relative with 0px)
                variant.style.position = 'relative';
                variant.style.top = '0px';
                variant.style.left = '0px';
                console.log('Hidden variant:', variant.getAttribute('data-figma-id'));
              });
              
              // Show selected variant instantly
              const selectedVariant = allVariants.find(v => 
                v.getAttribute('data-variant') === variant || 
                v.getAttribute('data-variant-property-1') === variant
              );
              
              if (selectedVariant) {
                selectedVariant.classList.add('variant-active');
                selectedVariant.classList.remove('variant-hidden');
                // Ensure selected variant maintains its original positioning
                selectedVariant.style.position = 'relative';
                selectedVariant.style.top = '0px';
                selectedVariant.style.left = '0px';
                console.log('Switched to variant:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));
                
                // Start timeout reactions for the newly active variant
                startTimeoutReactionsForNewlyActiveVariant(selectedVariant);
                startTimeoutReactionsForNestedComponents(selectedVariant);
              } else {
                console.log('Selected variant not found:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));
              }
            }
          }
        });
      });
  
      
      // Handle reactions - click, press, and drag
      const reactionElements = document.querySelectorAll('[data-has-reactions="true"]');
      reactionElements.forEach(element => {
        const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
        const actionType = element.getAttribute('data-reaction-action-type');
        const destinationId = element.getAttribute('data-reaction-destination');
        const transitionType = element.getAttribute('data-reaction-transition-type');
        const transitionDuration = element.getAttribute('data-reaction-transition-duration');
        
        // Handle click, press, and drag reactions
        element.addEventListener('click', function() {
          console.log('DEBUG: Click event triggered on element:', {
            id: this.getAttribute('data-figma-id'),
            name: this.getAttribute('data-figma-name'),
            type: this.getAttribute('data-figma-type'),
            trigger: trigger,
            actionType: actionType,
            destinationId: destinationId,
            transitionType: transitionType,
            transitionDuration: transitionDuration
          });
          
          if (trigger.type === 'ON_CLICK' || trigger.type === 'ON_PRESS') {
            console.log('DEBUG: Processing click reaction for element:', this.getAttribute('data-figma-id'));
            handleReaction(this, destinationId, transitionType, transitionDuration);
          }
        });
        
        // Handle drag reactions
        element.addEventListener('mousedown', function() {
          if (trigger.type === 'ON_DRAG') {
            handleReaction(this, destinationId, transitionType, transitionDuration);
          }
        });
      });
  
      
      // Track which variants have active timers (for preventing duplicate timers during the same activation)
      const activeTimers = new Map(); // elementId -> timeoutId
      
      // Function to start timeout reactions for active variants
      function startTimeoutReactionsForActiveVariants() {
        // Look for both variant-active elements with reactions AND any elements with reactions that don't have variant properties
        const activeVariants = document.querySelectorAll('.variant-active[data-has-reactions="true"]');
        const reactionElements = document.querySelectorAll('[data-has-reactions="true"]');
        
        console.log('DEBUG: Found', activeVariants.length, 'active variants with reactions');
        console.log('DEBUG: Found', reactionElements.length, 'total elements with reactions');
        
        // Process active variants first
        activeVariants.forEach(element => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          const parentComponent = element.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing variant:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for variants that are actually visible (not hidden by CSS)
          const computedStyle = window.getComputedStyle(element);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
            const actionType = element.getAttribute('data-reaction-action-type');
            const destinationId = element.getAttribute('data-reaction-destination');
            const transitionType = element.getAttribute('data-reaction-transition-type');
            const transitionDuration = element.getAttribute('data-reaction-transition-duration');
            
            // Handle timeout reactions only for active variants that don't have an active timer
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId); // Clear the timer when it completes
                handleReaction(element, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
          }
        });
        
        // Also process any reaction elements that don't have variant properties (like 6461:693)
        reactionElements.forEach(element => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          
          // Skip if this element was already processed as a variant
          if (element.classList.contains('variant-active')) {
            return;
          }
          
          // Skip if this element has variant properties (it will be handled by variant logic)
          if (element.hasAttribute('data-variant-property-1')) {
            return;
          }
          
          const parentComponent = element.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing non-variant reaction element:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for elements that are actually visible (not hidden by CSS)
          const computedStyle = window.getComputedStyle(element);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
            const actionType = element.getAttribute('data-reaction-action-type');
            const destinationId = element.getAttribute('data-reaction-destination');
            const transitionType = element.getAttribute('data-reaction-transition-type');
            const transitionDuration = element.getAttribute('data-reaction-transition-duration');
            
            // Handle timeout reactions only for elements that don't have an active timer
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId); // Clear the timer when it completes
                handleReaction(element, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
          }
        });
      }
      
      // Function to start timeout reactions for nested components when their parent becomes visible
      function startTimeoutReactionsForNestedComponents(parentElement) {
        if (!parentElement) return;
        
        // Find all nested components with timeout reactions within the parent
        const nestedComponents = parentElement.querySelectorAll('[data-has-reactions="true"][data-reaction-trigger*="AFTER_TIMEOUT"]');
        
        nestedComponents.forEach(component => {
          const elementId = component.getAttribute('data-figma-id');
          const elementName = component.getAttribute('data-figma-name');
          const parentComponent = component.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing nested component:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for nested components that are actually visible
          const computedStyle = window.getComputedStyle(component);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(component.getAttribute('data-reaction-trigger') || '{}');
            
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId);
                const actionType = component.getAttribute('data-reaction-action-type');
                const destinationId = component.getAttribute('data-reaction-destination');
                const transitionType = component.getAttribute('data-reaction-transition-type');
                const transitionDuration = component.getAttribute('data-reaction-transition-duration');
                handleReaction(component, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');
          }
        });
      }
      
      // Function to start timeout reactions for a specific newly active variant
      function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {
        if (!newlyActiveElement) return;
        
        const elementId = newlyActiveElement.getAttribute('data-figma-id');
        const elementName = newlyActiveElement.getAttribute('data-figma-name');
        const parentComponent = newlyActiveElement.closest('[data-figma-type="COMPONENT_SET"]');
        const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
        
        console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);
        
        // Only start timers for variants that are actually visible (not hidden by CSS)
        const computedStyle = window.getComputedStyle(newlyActiveElement);
        
        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
          const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');
          const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');
          const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');
          const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');
          const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');
          
          // Handle timeout reactions only for active variants that don't have an active timer
          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
            console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
            const timeoutId = setTimeout(() => {
              activeTimers.delete(elementId); // Clear the timer when it completes
              handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);
            }, (trigger.timeout || 0) * 1000);
            activeTimers.set(elementId, timeoutId);
          } else if (activeTimers.has(elementId)) {
            console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');
          }
          
          // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant
          startTimeoutReactionsForNestedComponents(newlyActiveElement);
        } else {
          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
        }
      }
      
      // CRITICAL FIX: Only start timeout reactions for the initial visible variant
      // Instead of starting timers for all variant-active elements immediately,
      // we wait for the first variant transition or user interaction
      function startTimeoutReactionsForInitialVariant() {
        // Find the first visible variant that should start the flow
        // This is typically the first variant in a component set that's marked as active
        const componentSets = document.querySelectorAll('[data-figma-type="COMPONENT_SET"]');
        console.log('DEBUG: Found', componentSets.length, 'component sets');
        
        // Also check for any elements with reactions
        const allReactionElements = document.querySelectorAll('[data-has-reactions="true"]');
        console.log('DEBUG: Found', allReactionElements.length, 'total elements with reactions');
        
        // Log details about reaction elements
        allReactionElements.forEach((element, index) => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
          const computedStyle = window.getComputedStyle(element);
          
          console.log('DEBUG: Reaction element', index + 1, ':', {
            id: elementId,
            name: elementName,
            trigger: trigger,
            display: computedStyle.display,
            visibility: computedStyle.visibility,
            isActive: element.classList.contains('variant-active'),
            isHidden: element.classList.contains('variant-hidden')
          });
        });
        
        componentSets.forEach(componentSet => {
          const componentSetName = componentSet.getAttribute('data-figma-name');
          const activeVariants = componentSet.querySelectorAll('.variant-active[data-has-reactions="true"]');
          console.log('DEBUG: Component set', componentSetName, 'has', activeVariants.length, 'active variants with reactions');
          
          // Only start timers for the first active variant in each component set
          if (activeVariants.length > 0) {
            const firstActiveVariant = activeVariants[0];
            const elementId = firstActiveVariant.getAttribute('data-figma-id');
            const elementName = firstActiveVariant.getAttribute('data-figma-name');
            const computedStyle = window.getComputedStyle(firstActiveVariant);
            
            console.log('DEBUG: Processing initial variant:', elementId, 'name:', elementName, 'in component set:', componentSetName);
            
            // Only start timer if the variant is actually visible
            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
              const trigger = JSON.parse(firstActiveVariant.getAttribute('data-reaction-trigger') || '{}');
              
              // Skip nested components that should only start when their parent becomes visible
              // Allow independent components to start their timers on page load
              // Check if this component set is nested within another component set
              const parentComponentSet = componentSet.closest('[data-figma-type="COMPONENT_SET"]');
              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;
              
              if (isNestedComponent) {
                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');
                return;
              }
              
              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
                console.log('DEBUG: Starting initial timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);
                const timeoutId = setTimeout(() => {
                  console.log('DEBUG: Timeout triggered for element:', elementId, 'name:', elementName);
                  activeTimers.delete(elementId);
                  const actionType = firstActiveVariant.getAttribute('data-reaction-action-type');
                  const destinationId = firstActiveVariant.getAttribute('data-reaction-destination');
                  const transitionType = firstActiveVariant.getAttribute('data-reaction-transition-type');
                  const transitionDuration = firstActiveVariant.getAttribute('data-reaction-transition-duration');
                  console.log('DEBUG: Calling handleReaction with:', {
                    destinationId: destinationId,
                    transitionType: transitionType,
                    transitionDuration: transitionDuration
                  });
                  handleReaction(firstActiveVariant, destinationId, transitionType, transitionDuration);
                }, (trigger.timeout || 0) * 1000);
                activeTimers.set(elementId, timeoutId);
                console.log('DEBUG: Created timeout timer for element:', elementId, 'timeout ID:', timeoutId, 'duration:', (trigger.timeout || 0) * 1000, 'ms');
                
                // CRITICAL FIX: Also start timeout reactions for any nested components within this initial variant
                startTimeoutReactionsForNestedComponents(firstActiveVariant);
              } else {
                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- no timeout trigger or timer already active');
              }
            } else {
              console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
            }
          }
          
          // CRITICAL FIX: Also check for non-variant reaction elements in this component set
          const reactionElements = componentSet.querySelectorAll('[data-has-reactions="true"]');
          reactionElements.forEach(element => {
            const elementId = element.getAttribute('data-figma-id');
            const elementName = element.getAttribute('data-figma-name');
            
            // Skip if this element was already processed as a variant
            if (element.classList.contains('variant-active')) {
              return;
            }
            
            // Skip if this element has variant properties (it will be handled by variant logic)
            if (element.hasAttribute('data-variant-property-1')) {
              return;
            }
            
            const computedStyle = window.getComputedStyle(element);
            
            console.log('DEBUG: Processing initial non-variant reaction element:', elementId, 'name:', elementName, 'in component set:', componentSetName);
            
            // Only start timer if the element is actually visible
            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
              const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
              
              // Skip nested components that should only start when their parent becomes visible
              const parentComponentSet = componentSet.closest('[data-figma-type="COMPONENT_SET"]');
              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;
              
              if (isNestedComponent) {
                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');
                return;
              }
              
              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
                console.log('DEBUG: Starting initial timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);
                const timeoutId = setTimeout(() => {
                  activeTimers.delete(elementId);
                  const actionType = element.getAttribute('data-reaction-action-type');
                  const destinationId = element.getAttribute('data-reaction-destination');
                  const transitionType = element.getAttribute('data-reaction-transition-type');
                  const transitionDuration = element.getAttribute('data-reaction-transition-duration');
                  handleReaction(element, destinationId, transitionType, transitionDuration);
                }, (trigger.timeout || 0) * 1000);
                activeTimers.set(elementId, timeoutId);
                
                // Also start timeout reactions for any nested components within this element
                startTimeoutReactionsForNestedComponents(element);
              } else {
                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- no timeout trigger or timer already active');
              }
            } else {
              console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
            }
          });
        });
      }
      
      // Start timeout reactions for the initial visible variant after a short delay
      // to ensure CSS classes and visibility are properly applied
      console.log('DEBUG: Setting up initial timeout reactions');
      setTimeout(() => {
        console.log('DEBUG: Starting initial timeout reactions');
        startTimeoutReactionsForInitialVariant();
      }, 100);
  
      
      // Helper function to find elements with property changes between variants
      function findElementsWithPropertyChanges(targetVariant, currentVariant) {
        console.log('DEBUG: findElementsWithPropertyChanges called');
        console.log('  Target variant ID:', targetVariant.getAttribute('data-figma-id'), 'Name:', targetVariant.getAttribute('data-figma-name'));
        console.log('  Current variant ID:', currentVariant.getAttribute('data-figma-id'), 'Name:', currentVariant.getAttribute('data-figma-name'));
        
        if (!currentVariant) {
          console.log('DEBUG: No current variant provided, returning empty array');
          return [];
        }
        
        const targetElements = targetVariant.querySelectorAll('[data-figma-id]');
        const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');
        const sourceElementMap = new Map();
        const elementsToAnimate = [];

        console.log('DEBUG: Found', targetElements.length, 'target elements and', sourceElements.length, 'source elements');

        // Build source element map by name
        sourceElements.forEach(function(sourceElement) {
          const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');
          if (sourceName) {
            sourceElementMap.set(sourceName, sourceElement);
            console.log('  Mapped source element:', sourceName, '->', sourceElement.getAttribute('data-figma-id'));
          }
        });

        // Analyze each target element for property changes
        targetElements.forEach(function(element, index) {
          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
          const sourceElement = sourceElementMap.get(targetName);
          
          console.log('DEBUG: Analyzing target element ' + (index + 1) + ':', targetName);
          console.log('  Target element ID:', element.getAttribute('data-figma-id'));
          console.log('  Source element found:', !!sourceElement);
          
          if (sourceElement) {
            console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));
            const changes = detectPropertyChanges(element, sourceElement);
            
            if (changes.hasChanges) {
              elementsToAnimate.push({
                element: sourceElement,  // Use SOURCE element (from copy) instead of target
                sourceElement: sourceElement,
                changes: changes
              });
              console.log('DEBUG: Found element with property changes:', targetName, 'changes:', changes);
            } else {
              console.log('DEBUG: No changes detected for element:', targetName);
            }
          } else {
            console.log('DEBUG: No matching source element found for:', targetName);
          }
        });
        
        console.log('DEBUG: Returning', elementsToAnimate.length, 'elements to animate');
        return elementsToAnimate;
      }

      // Helper function to detect property changes between elements
      function detectPropertyChanges(targetElement, sourceElement) {
        const changes = {
          hasChanges: false,
          positionX: { changed: false, sourceValue: null, targetValue: null },
          positionY: { changed: false, sourceValue: null, targetValue: null },
          backgroundColor: { changed: false, sourceValue: null, targetValue: null },
          color: { changed: false, sourceValue: null, targetValue: null },
          justifyContent: { changed: false, sourceValue: null, targetValue: null },
          alignItems: { changed: false, sourceValue: null, targetValue: null }
        };

        try {
          // Check position changes by comparing the computed styles
          const sourceStyle = window.getComputedStyle(sourceElement);
          const targetStyle = window.getComputedStyle(targetElement);
          
          // Check left position changes - use Figma data attributes for more accurate positioning
          const sourceLeft = parseFloat(sourceStyle.left) || 0;
          const targetLeft = parseFloat(targetStyle.left) || 0;
          
          // Get Figma position data for more accurate target positioning
          const sourceFigmaX = parseFloat(sourceElement.getAttribute('data-figma-x')) || 0;
          const targetFigmaX = parseFloat(targetElement.getAttribute('data-figma-x')) || 0;
          
          // CRITICAL FIX: Check if the source element has a transform applied from a previous animation
          // If so, we need to account for that in the position calculation
          const sourceTransform = sourceStyle.transform;
          let sourceTransformOffset = 0;
          if (sourceTransform && sourceTransform !== 'none') {
            // Extract translateX value from transform matrix
            const matrix = new DOMMatrix(sourceTransform);
            sourceTransformOffset = matrix.m41; // m41 is the translateX value
            console.log('DEBUG: Source element has transform:', sourceTransform, 'translateX offset:', sourceTransformOffset);
          }
          
          // Log detailed information about the elements
          const sourceName = sourceElement.getAttribute('data-figma-name');
          const targetName = targetElement.getAttribute('data-figma-name');
          const sourceId = sourceElement.getAttribute('data-figma-id');
          const targetId = targetElement.getAttribute('data-figma-id');
          
          console.log('DEBUG: Analyzing elements:');
          console.log('  Source:', sourceName, 'ID:', sourceId, 'Left:', sourceLeft, 'FigmaX:', sourceFigmaX);
          console.log('  Target:', targetName, 'ID:', targetId, 'Left:', targetLeft, 'FigmaX:', targetFigmaX);
          
          // Log parent container dimensions
          const sourceContainer = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          const targetContainer = targetElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          
          if (sourceContainer) {
            const sourceContainerRect = sourceContainer.getBoundingClientRect();
            console.log('  Source container dimensions:', sourceContainerRect.width, 'x', sourceContainerRect.height);
          }
          
          if (targetContainer) {
            const targetContainerRect = targetContainer.getBoundingClientRect();
            console.log('  Target container dimensions:', targetContainerRect.width, 'x', targetContainerRect.height);
          }
          
          // Log viewport dimensions
          console.log('  Viewport dimensions:', window.innerWidth, 'x', window.innerHeight);
          
          // Log element dimensions
          const sourceRect = sourceElement.getBoundingClientRect();
          const targetRect = targetElement.getBoundingClientRect();
          console.log('  Source element dimensions:', sourceRect.width, 'x', sourceRect.height);
          console.log('  Target element dimensions:', targetRect.width, 'x', targetRect.height);
          
          // Check if target element is properly rendered
          if (targetRect.width === 0 && targetRect.height === 0) {
            console.log('DEBUG: Target element has zero dimensions, skipping animation');
            return changes;
          }
          
          // CRITICAL FIX: Use current computed position for source if element has been animated
          // This ensures we detect changes from the actual current position, not the original Figma position
          const sourceHasBeenAnimated = sourceElement.style.position === 'absolute' && 
                                       (sourceElement.style.left || sourceElement.style.top);
          
          // Calculate target position by scaling Figma coordinates to actual rendered size
          // Use SOURCE element's parent (copy) for scaling since we're animating the copy
          const sourceContainerForScaling = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          const targetContainerForScaling = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          
          let finalTargetLeft = 0; // Start with 0, will be calculated below
          // Always use computed styles for consistency
          let finalSourceLeft = parseFloat(sourceStyle.left) || 0;
          
          // Add transform offset if present
          finalSourceLeft += sourceTransformOffset;
          
          // CRITICAL FIX: Scale position from component set dimensions to instance dimensions
          // The target element is positioned in the component set (2619.125px) but needs to be scaled to the instance (346px)
          const targetComputedStyle = window.getComputedStyle(targetElement);
          let targetContainerX = targetElement.parentElement;
          
          // Walk up the DOM tree to find the nearest INSTANCE container
          while (targetContainerX && targetContainerX.getAttribute('data-figma-type') !== 'INSTANCE') {
            targetContainerX = targetContainerX.parentElement;
          }
          
          if (targetContainerX) {
            const containerRectX = targetContainerX.getBoundingClientRect();
            const targetElementRectX = targetElement.getBoundingClientRect();
            
            // Get the original Figma X position from the target element
            const figmaX = parseFloat(targetElement.getAttribute('data-figma-x')) || 0;
            
            // Scale factor: instance width / component set width
            // From JSON: component set width = 2619.125px, instance width = 346px
            const componentSetWidth = 2619.125;
            const instanceWidth = containerRectX.width;
            const scaleFactor = instanceWidth / componentSetWidth;
            
            // Scale the Figma X position to fit within the instance
            // Account for the object's width to prevent overflow
            const objectWidth = targetElementRectX.width;
            const scaledPosition = figmaX * scaleFactor;
            
            // Ensure the object doesn't overflow the container
            finalTargetLeft = Math.min(scaledPosition, instanceWidth - objectWidth);
            
            console.log('DEBUG: Position calculation with object size:', {
              figmaX: figmaX,
              scaleFactor: scaleFactor,
              scaledPosition: scaledPosition,
              objectWidth: objectWidth,
              instanceWidth: instanceWidth,
              finalTargetLeft: finalTargetLeft
            });
            
            console.log('DEBUG: Using scaled INSTANCE-relative position calculation:', {
              targetElementLeft: targetElementRectX.left,
              containerLeft: containerRectX.left,
              containerWidth: containerRectX.width,
              figmaX: figmaX,
              componentSetWidth: componentSetWidth,
              scaleFactor: scaleFactor,
              finalTargetLeft: finalTargetLeft,
              targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'),
              containerElement: targetContainerX.tagName + (targetContainerX.className ? '.' + targetContainerX.className : ''),
              containerType: targetContainerX.getAttribute('data-figma-type'),
              containerId: targetContainerX.getAttribute('data-figma-id'),
              targetComputedLeft: targetComputedStyle.left
            });
          } else {
            // Fallback to computed values if no instance found
            finalTargetLeft = parseFloat(targetComputedStyle.left) || 0;
            console.log('DEBUG: Using computed values fallback:', {
              targetComputedLeft: targetComputedStyle.left,
              finalTargetLeft: finalTargetLeft,
              targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id')
            });
          }
          
          console.log('DEBUG: X Position Analysis:');
          console.log('  Source has been animated:', sourceHasBeenAnimated);
          console.log('  Source computed left:', sourceLeft, 'Source Figma X:', sourceFigmaX, 'Transform offset:', sourceTransformOffset, 'Final source left:', finalSourceLeft);
          console.log('  Target computed left:', targetLeft, 'Target Figma X:', targetFigmaX, 'Final target left:', finalTargetLeft);
          
          if (Math.abs(finalSourceLeft - finalTargetLeft) > 1) {
            changes.positionX.changed = true;
            changes.positionX.sourceValue = finalSourceLeft;
            changes.positionX.targetValue = finalTargetLeft;
            changes.hasChanges = true;
            console.log('DEBUG: Position X change detected:', finalSourceLeft, '->', finalTargetLeft, '(scaled from Figma coordinates)');
            console.log('DEBUG: Position X change details:');
            console.log('  Source element rect:', sourceElement.getBoundingClientRect());
            console.log('  Target element rect:', targetElement.getBoundingClientRect());
            console.log('  Source element computed style:', window.getComputedStyle(sourceElement).left);
            console.log('  Target element computed style:', window.getComputedStyle(targetElement).left);
          } else {
            console.log('DEBUG: No X position change detected - difference:', Math.abs(finalSourceLeft - finalTargetLeft));
          }
          
          // Check top position changes - use Figma data attributes for more accurate positioning
          const sourceTop = parseFloat(sourceStyle.top) || 0;
          const targetTop = parseFloat(targetStyle.top) || 0;
          
          // Get Figma position data for more accurate target positioning
          const sourceFigmaY = parseFloat(sourceElement.getAttribute('data-figma-y')) || 0;
          const targetFigmaY = parseFloat(targetElement.getAttribute('data-figma-y')) || 0;
          
          // CRITICAL FIX: Check if the source element has a transform applied from a previous animation
          // If so, we need to account for that in the position calculation
          let sourceTransformYOffset = 0;
          if (sourceTransform && sourceTransform !== 'none') {
            // Extract translateY value from transform matrix
            const matrix = new DOMMatrix(sourceTransform);
            sourceTransformYOffset = matrix.m42; // m42 is the translateY value
            console.log('DEBUG: Source element has transform:', sourceTransform, 'translateY offset:', sourceTransformYOffset);
          }
          
          // Calculate target position by scaling Figma coordinates to actual rendered size
          let finalTargetTop = 0; // Start with 0, will be calculated below
          // Always use computed styles for consistency
          let finalSourceTop = parseFloat(sourceStyle.top) || 0;
          
          // Add transform offset if present
          finalSourceTop += sourceTransformYOffset;
          
          // CRITICAL FIX: Scale position from component set dimensions to instance dimensions
          // The target element is positioned in the component set but needs to be scaled to the instance
          const targetComputedStyleY = window.getComputedStyle(targetElement);
          let targetContainerY = targetElement.parentElement;
          
          // Walk up the DOM tree to find the nearest INSTANCE container
          while (targetContainerY && targetContainerY.getAttribute('data-figma-type') !== 'INSTANCE') {
            targetContainerY = targetContainerY.parentElement;
          }
          
          if (targetContainerY) {
            const containerRectY = targetContainerY.getBoundingClientRect();
            const targetElementRectY = targetElement.getBoundingClientRect();
            
            // Get the original Figma Y position from the target element
            const figmaY = parseFloat(targetElement.getAttribute('data-figma-y')) || 0;
            
            // Scale factor: instance height / component set height
            // From JSON: component set height = 214px, instance height = 84px
            const componentSetHeight = 214;
            const instanceHeight = containerRectY.height;
            const scaleFactorY = instanceHeight / componentSetHeight;
            
            // Scale the Figma Y position to fit within the instance
            // Account for the object's height to prevent overflow
            const objectHeight = targetElementRectY.height;
            const scaledPositionY = figmaY * scaleFactorY;
            
            // Ensure the object doesn't overflow the container
            finalTargetTop = Math.min(scaledPositionY, instanceHeight - objectHeight);
            
            console.log('DEBUG: Y Position calculation with object size:', {
              figmaY: figmaY,
              scaleFactorY: scaleFactorY,
              scaledPositionY: scaledPositionY,
              objectHeight: objectHeight,
              instanceHeight: instanceHeight,
              finalTargetTop: finalTargetTop
            });
            
            console.log('DEBUG: Using scaled INSTANCE-relative position calculation Y:', {
              targetElementTop: targetElementRectY.top,
              containerTop: containerRectY.top,
              containerHeight: containerRectY.height,
              figmaY: figmaY,
              componentSetHeight: componentSetHeight,
              scaleFactorY: scaleFactorY,
              finalTargetTop: finalTargetTop,
              targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'),
              containerElement: targetContainerY.tagName + (targetContainerY.className ? '.' + targetContainerY.className : ''),
              containerType: targetContainerY.getAttribute('data-figma-type'),
              containerId: targetContainerY.getAttribute('data-figma-id'),
              targetComputedTop: targetComputedStyleY.top
            });
          } else {
            // Fallback to computed values if no instance found
            finalTargetTop = parseFloat(targetComputedStyleY.top) || 0;
            console.log('DEBUG: Using computed values fallback Y:', {
              targetComputedTop: targetComputedStyleY.top,
              finalTargetTop: finalTargetTop,
              targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id')
            });
          }
          
          console.log('DEBUG: Y Position Analysis:');
          console.log('  Source computed top:', sourceTop, 'Source Figma Y:', sourceFigmaY, 'Transform offset:', sourceTransformYOffset, 'Final source top:', finalSourceTop);
          console.log('  Target computed top:', targetTop, 'Target Figma Y:', targetFigmaY, 'Final target top:', finalTargetTop);
          
          if (Math.abs(finalSourceTop - finalTargetTop) > 1) {
            changes.positionY.changed = true;
            changes.positionY.sourceValue = finalSourceTop;
            changes.positionY.targetValue = finalTargetTop;
            changes.hasChanges = true;
            console.log('DEBUG: Position Y change detected:', finalSourceTop, '->', finalTargetTop, '(scaled from Figma coordinates)');
          } else {
            console.log('DEBUG: No Y position change detected - difference:', Math.abs(finalSourceTop - finalTargetTop));
          }

          // Check style changes - use more specific comparison
          const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          
          if (sourceBg !== targetBg) {
            changes.backgroundColor.changed = true;
            changes.backgroundColor.sourceValue = sourceBg;
            changes.backgroundColor.targetValue = targetBg;
            changes.hasChanges = true;
            console.log('DEBUG: Background color change detected:', sourceBg, '->', targetBg);
          }
          
          if (sourceStyle.color !== targetStyle.color) {
            changes.color.changed = true;
            changes.color.sourceValue = sourceStyle.color;
            changes.color.targetValue = targetStyle.color;
            changes.hasChanges = true;
            console.log('DEBUG: Color change detected:', sourceStyle.color, '->', targetStyle.color);
          }
          
          if (sourceStyle.justifyContent !== targetStyle.justifyContent) {
            changes.justifyContent.changed = true;
            changes.justifyContent.sourceValue = sourceStyle.justifyContent;
            changes.justifyContent.targetValue = targetStyle.justifyContent;
            changes.hasChanges = true;
          }
          
          if (sourceStyle.alignItems !== targetStyle.alignItems) {
            changes.alignItems.changed = true;
            changes.alignItems.sourceValue = sourceStyle.alignItems;
            changes.alignItems.targetValue = targetStyle.alignItems;
            changes.hasChanges = true;
          }
        } catch (error) {
          console.log('DEBUG: Error detecting property changes:', error);
        }

        return changes;
      }
  
      
      // Global transition lock to prevent multiple simultaneous transitions
      let isTransitionInProgress = false;
      
      // Helper function to map Figma animation types to CSS easing functions
      function getEasingFunction(animationType) {
        switch (animationType) {
          case 'EASE_IN_AND_OUT_BACK':
            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';
          case 'EASE_IN_AND_OUT':
            return 'ease-in-out';
          case 'EASE_IN':
            return 'ease-in';
          case 'EASE_OUT':
            return 'ease-out';
          case 'LINEAR':
            return 'linear';
          case 'BOUNCY':
            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';
          case 'GENTLE':
            return 'ease-in-out'; // Gentle is typically a smooth ease-in-out
          case 'SMART_ANIMATE':
            // SMART_ANIMATE should use the actual easing type from the reaction data
            // For now, default to ease-in-out which is commonly used for smart animate
            return 'ease-in-out';
          default:
            return 'ease-out';
        }
      }
      
      // Helper function to create a deep copy of an element
      function createElementCopy(sourceElement) {
        const copy = sourceElement.cloneNode(true);
        copy.setAttribute('data-figma-id', sourceElement.getAttribute('data-figma-id') + '-copy');
        copy.setAttribute('data-is-animation-copy', 'true');
        
        // Immediately reset all internal elements to their original positions
        const copyElements = copy.querySelectorAll('*');
        copyElements.forEach(element => {
          if (element.hasAttribute('data-figma-id')) {
            // Reset to original Figma positions (0,0) for animation
            element.style.position = 'relative';
            element.style.left = '0px';
            element.style.top = '0px';
            
            // Force remove any existing inline styles that might interfere
            element.style.removeProperty('transform');
            element.style.removeProperty('margin');
            element.style.removeProperty('padding');
            
            // Force the style to be applied by setting it again
            element.style.setProperty('left', '0px', 'important');
            element.style.setProperty('top', '0px', 'important');
            
            console.log('DEBUG: Reset copy element:', element.getAttribute('data-figma-id'), {
              position: element.style.position,
              left: element.style.left,
              top: element.style.top,
              computedLeft: window.getComputedStyle(element).left,
              computedTop: window.getComputedStyle(element).top,
              elementRect: element.getBoundingClientRect()
            });
          }
        });
        
        // Debug: List all elements in the copy with their IDs
        console.log('DEBUG: All elements in copy:', Array.from(copy.querySelectorAll('[data-figma-id]')).map(el => ({
          id: el.getAttribute('data-figma-id'),
          left: el.style.left,
          top: el.style.top
        })));
        
        // Get the source element's computed position
        const sourceRect = sourceElement.getBoundingClientRect();
        const parentRect = sourceElement.parentElement.getBoundingClientRect();
        
        // Position the copy absolutely over the source element
        copy.style.position = 'absolute';
        copy.style.top = (sourceRect.top - parentRect.top) + 'px';
        copy.style.left = (sourceRect.left - parentRect.left) + 'px';
        

        
        // Override any inline styles that might interfere with positioning
        copy.style.transform = 'none'; // Remove any transforms
        copy.style.margin = '0'; // Remove margins
        copy.style.padding = '0'; // Remove padding
        
        // Ensure copy is always on top by finding the highest z-index in the document
        const allElements = document.querySelectorAll('*');
        let maxZIndex = 0;
        allElements.forEach(el => {
          const zIndex = parseInt(window.getComputedStyle(el).zIndex) || 0;
          if (zIndex > maxZIndex) maxZIndex = zIndex;
        });
        
        // Set copy z-index higher than any existing element
        const copyZIndex = maxZIndex + 1000;
        copy.style.zIndex = copyZIndex.toString();
        copy.style.pointerEvents = 'none'; // Prevent interaction with copy
        copy.style.transform = 'translateZ(0)'; // Create new stacking context and enable hardware acceleration
        copy.style.willChange = 'transform, left, top'; // Optimize for animations
        
        console.log('DEBUG: Copy z-index management:', {
          maxZIndexFound: maxZIndex,
          copyZIndex: copyZIndex,
          copyPosition: copy.style.position,
          copyTop: copy.style.top,
          copyLeft: copy.style.left
        });
        
        console.log('DEBUG: Copy positioned at:', {
          sourceTop: sourceRect.top - parentRect.top,
          sourceLeft: sourceRect.left - parentRect.left,
          sourceRect: sourceRect,
          parentRect: parentRect,
          copyPosition: copy.style.position,
          copyTop: copy.style.top,
          copyLeft: copy.style.left
        });
        
        return copy;
      }
      
      // Helper function to animate copy to destination values
      function animateCopyToDestination(copy, destination, transitionType, transitionDuration) {
        return new Promise((resolve) => {
          // Find elements with property changes
          const elementsToAnimate = findElementsWithPropertyChanges(destination, copy);
          
          if (elementsToAnimate.length > 0) {
            console.log('DEBUG: Animating copy with', elementsToAnimate.length, 'elements');
            console.log('DEBUG: Elements to animate:', elementsToAnimate.map(({ element, changes }) => ({
              id: element.getAttribute('data-figma-id'),
              left: element.style.left,
              top: element.style.top,
              hasPositionX: changes.positionX?.changed || false,
              hasPositionY: changes.positionY?.changed || false
            })));
            
            // Setup animation for each element in the copy
            elementsToAnimate.forEach(({ element, sourceElement, changes }) => {
              const easingFunction = getEasingFunction(transitionType);
              const duration = parseFloat(transitionDuration || '0.3');
              
              console.log('DEBUG: Animation setup for element:', element.getAttribute('data-figma-id'), {
                transitionType: transitionType,
                easingFunction: easingFunction,
                duration: duration
              });
              
              // Build transition string
              const transitionProperties = [];
              if (changes.backgroundColor && changes.backgroundColor.changed) {
                transitionProperties.push(`background-color ${duration}s ${easingFunction}`);
              }
              if (changes.color && changes.color.changed) {
                transitionProperties.push(`color ${duration}s ${easingFunction}`);
              }
              if (changes.opacity && changes.opacity.changed) {
                transitionProperties.push(`opacity ${duration}s ${easingFunction}`);
              }
              if (changes.positionX && changes.positionX.changed) {
                transitionProperties.push(`left ${duration}s ${easingFunction}`);
              }
              if (changes.positionY && changes.positionY.changed) {
                transitionProperties.push(`top ${duration}s ${easingFunction}`);
              }
              if (changes.width && changes.width.changed) {
                transitionProperties.push(`width ${duration}s ${easingFunction}`);
              }
              if (changes.height && changes.height.changed) {
                transitionProperties.push(`height ${duration}s ${easingFunction}`);
              }
              
              // Apply transition
              if (transitionProperties.length > 0) {
                element.style.transition = transitionProperties.join(', ');
                console.log('DEBUG: Applied transition to element:', element.getAttribute('data-figma-id'), 'transition:', element.style.transition);
                
                // Verify transition was applied
                setTimeout(() => {
                  const computedTransition = window.getComputedStyle(element).transition;
                  console.log('DEBUG: Verified transition for element:', element.getAttribute('data-figma-id'), 'computed transition:', computedTransition);
                }, 0);
              }
            });
            
            // Force reflow to ensure transitions are applied
            copy.offsetHeight;
            
                    // Apply target values to animate the copy with proper timing
        requestAnimationFrame(() => {
          console.log('DEBUG: Applying target values to copy elements');
          
          // Log initial positions before animation
          elementsToAnimate.forEach(({ element, changes }) => {
            console.log('DEBUG: Initial position of element:', element.getAttribute('data-figma-id'), {
              top: element.style.top,
              left: element.style.left,
              transition: element.style.transition,
              computedTransition: window.getComputedStyle(element).transition
            });
          });
              
              elementsToAnimate.forEach(({ element, changes }) => {
                if (changes.backgroundColor && changes.backgroundColor.changed) {
                  element.style.backgroundColor = changes.backgroundColor.targetValue;
                }
                if (changes.color && changes.color.changed) {
                  element.style.color = changes.color.targetValue;
                }
                if (changes.opacity && changes.opacity.changed) {
                  element.style.opacity = changes.opacity.targetValue;
                }
                if (changes.positionX && changes.positionX.changed) {
                  // Set the target position directly (not relative to current position)
                  const targetLeft = parseFloat(changes.positionX.targetValue);
                  
                  console.log('DEBUG: Before position change - element:', element.getAttribute('data-figma-id'), {
                    currentLeft: element.style.left,
                    currentPosition: element.style.position,
                    targetLeft: targetLeft,
                    elementRect: element.getBoundingClientRect()
                  });
                  
                  element.style.left = targetLeft + 'px';
                  
                  console.log('DEBUG: After position change - element:', element.getAttribute('data-figma-id'), {
                    newLeft: element.style.left,
                    elementRect: element.getBoundingClientRect()
                  });
                  
                  console.log('DEBUG: Applied position change to copy:', element.getAttribute('data-figma-id'), 'from:', element.style.left || '0px', 'to:', targetLeft + 'px', 'target:', targetLeft, 'easing:', getEasingFunction(transitionType));
                }
                if (changes.positionY && changes.positionY.changed) {
                  // Set the target position directly (not relative to current position)
                  const targetTop = parseFloat(changes.positionY.targetValue);
                  
                  element.style.top = targetTop + 'px';
                  console.log('DEBUG: Applied position change to copy:', element.getAttribute('data-figma-id'), 'from:', element.style.top || '0px', 'to:', targetTop + 'px', 'target:', targetTop, 'easing:', getEasingFunction(transitionType));
                }
                if (changes.width && changes.width.changed) {
                  element.style.width = changes.width.targetValue + 'px';
                }
                if (changes.height && changes.height.changed) {
                  element.style.height = changes.height.targetValue + 'px';
                }
              });
            }, 16);
            
            // Monitor animation progress
            const animationDuration = parseFloat(transitionDuration || '0.3') * 1000;
            const checkInterval = 100; // Check every 100ms
            let checkCount = 0;
            
                          const progressCheck = setInterval(() => {
                checkCount++;
                elementsToAnimate.forEach(({ element, changes }) => {
                  const elementRect = element.getBoundingClientRect();
                  console.log('DEBUG: Animation progress check', checkCount, 'for element:', element.getAttribute('data-figma-id'), {
                    top: element.style.top,
                    left: element.style.left,
                    computedTop: getComputedStyle(element).top,
                    computedLeft: getComputedStyle(element).left,
                    boundingRect: elementRect,
                    isVisible: elementRect.width > 0 && elementRect.height > 0,
                    viewportPosition: {
                      x: elementRect.x,
                      y: elementRect.y,
                      right: elementRect.right,
                      bottom: elementRect.bottom
                    }
                  });
                });
              
              if (checkCount * checkInterval >= animationDuration) {
                clearInterval(progressCheck);
                console.log('DEBUG: Animation completed, removing copy');
                resolve();
              }
            }, checkInterval);
          } else {
            // No elements to animate, resolve immediately
            resolve();
          }
        });
      }
      
      // Helper function to perform instant variant switch (no animation)
      function performInstantVariantSwitch(allVariants, destination) {
        console.log('DEBUG: Performing instant variant switch');
        
        // Hide all variants
        allVariants.forEach(variant => {
          variant.classList.add('variant-hidden');
          variant.classList.remove('variant-active');
          // Ensure all variants maintain their original positioning
          variant.style.position = 'relative';
          variant.style.top = '0px';
          variant.style.left = '0px';
        });
        
        // Show destination variant
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        // Ensure destination maintains its original positioning
        destination.style.position = 'relative';
        destination.style.top = '0px';
        destination.style.left = '0px';
        
        // Start timeout reactions
        startTimeoutReactionsForNewlyActiveVariant(destination);
        startTimeoutReactionsForNestedComponents(destination);
      }
      
      // Helper function to handle animated variant switching using copy approach
      async function handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration) {
        console.log('DEBUG: Starting animated variant switch with copy approach');
        console.log('  Transition type:', transitionType, 'Duration:', transitionDuration);
        
        // Create a copy of the source variant
        const sourceCopy = createElementCopy(sourceElement);
        
        // Insert the copy into the DOM (positioned over the source)
        const sourceParent = sourceElement.parentElement;
        sourceParent.appendChild(sourceCopy);
        
        // Hide the original source element and all other variants for testing
        sourceElement.style.opacity = '0';
        sourceElement.style.visibility = 'hidden';
        
        // Hide all other variants too for clean testing
        allVariants.forEach(variant => {
          if (variant !== sourceElement) {
            variant.style.opacity = '0';
            variant.style.visibility = 'hidden';
          }
        });
        
        console.log('DEBUG: Copy created and positioned:', {
          copyId: sourceCopy.getAttribute('data-figma-id'),
          copyPosition: sourceCopy.style.position,
          copyTop: sourceCopy.style.top,
          copyLeft: sourceCopy.style.left,
          copyOpacity: sourceCopy.style.opacity,
          copyZIndex: sourceCopy.style.zIndex,
          copyDisplay: sourceCopy.style.display,
          copyVisibility: sourceCopy.style.visibility,
          copyTransform: sourceCopy.style.transform,
          copyWillChange: sourceCopy.style.willChange
        });
        
        // Log the copy's actual DOM position and visibility
        setTimeout(() => {
          const copyRect = sourceCopy.getBoundingClientRect();
          const copyComputedStyle = window.getComputedStyle(sourceCopy);
          console.log('DEBUG: Copy DOM position and visibility:', {
            copyId: sourceCopy.getAttribute('data-figma-id'),
            boundingRect: copyRect,
            computedPosition: copyComputedStyle.position,
            computedTop: copyComputedStyle.top,
            computedLeft: copyComputedStyle.left,
            computedOpacity: copyComputedStyle.opacity,
            computedZIndex: copyComputedStyle.zIndex,
            computedDisplay: copyComputedStyle.display,
            computedVisibility: copyComputedStyle.visibility,
            computedTransform: copyComputedStyle.transform,
            isVisible: copyRect.width > 0 && copyRect.height > 0 && copyComputedStyle.opacity !== '0',
            parentOverflow: window.getComputedStyle(sourceCopy.parentElement).overflow
          });
        }, 100);
        
        // Show the destination variant (but keep it hidden visually)
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        destination.style.visibility = 'hidden'; // Hidden but active for calculations
        
        // Force reflow to ensure destination is rendered for calculations
        destination.offsetHeight;
        
        // Animate the copy to match the destination
        await animateCopyToDestination(sourceCopy, destination, transitionType, transitionDuration);
        
        // Animation complete - restore normal behavior
        sourceCopy.remove(); // Remove the copy
        
        // Reset source element visibility
        sourceElement.style.opacity = '1';
        sourceElement.style.visibility = 'visible';
        
        console.log('DEBUG: Animation completed - normal behavior restored');
        
        // Properly activate the destination variant
        destination.style.visibility = 'visible';
        destination.style.opacity = '1';
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        
        // Ensure destination has proper positioning
        destination.style.position = 'relative';
        destination.style.top = '0px';
        destination.style.left = '0px';
        
        // Hide all other variants
        allVariants.forEach(variant => {
          if (variant !== destination) {
            variant.classList.add('variant-hidden');
            variant.classList.remove('variant-active');
            variant.style.position = 'relative';
            variant.style.top = '0px';
            variant.style.left = '0px';
            variant.style.opacity = '0';
            variant.style.visibility = 'hidden';
          }
        });
        
        console.log('DEBUG: Normal mode - copy removed, destination variant active and visible');
        
        // Start timeout reactions
        startTimeoutReactionsForNewlyActiveVariant(destination);
        startTimeoutReactionsForNestedComponents(destination);
      }
      
      // Helper function to handle reaction transitions
      function handleReaction(sourceElement, destinationId, transitionType, transitionDuration) {
        console.log('DEBUG: handleReaction called');
        console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));
        console.log('  Destination ID:', destinationId);
        console.log('  Transition type:', transitionType, 'Duration:', transitionDuration);
        
        // Prevent multiple simultaneous transitions
        if (isTransitionInProgress) {
          console.log('DEBUG: Transition already in progress, skipping');
          return;
        }
        
        // Set transition lock
        isTransitionInProgress = true;
        
        // Safety timeout
        const safetyTimeout = setTimeout(() => {
          if (isTransitionInProgress) {
            console.log('WARNING: Transition lock stuck, forcing release');
            isTransitionInProgress = false;
          }
        }, 5000);
        
        if (destinationId) {
          const destination = document.querySelector(`[data-figma-id="${destinationId}"]`);
          
          if (!destination) {
            console.log('ERROR: Destination element not found:', destinationId);
            clearTimeout(safetyTimeout);
            isTransitionInProgress = false;
            return;
          }
          
          // Check if this is a variant switch within a component set
          const sourceComponentSet = sourceElement.closest('[data-figma-type="COMPONENT_SET"]');
          const destinationComponentSet = destination.closest('[data-figma-type="COMPONENT_SET"]');
          
          if (sourceComponentSet && destinationComponentSet && sourceComponentSet === destinationComponentSet) {
            // This is a variant switch
            const componentSet = sourceComponentSet;
            const allVariants = Array.from(componentSet.children).filter(child => 
              child.getAttribute('data-figma-type') === 'COMPONENT'
            );
            
            console.log('DEBUG: Transition type check:', {
              transitionType: transitionType,
              transitionDuration: transitionDuration,
              isAnimated: transitionType === 'SMART_ANIMATE' || transitionType === 'BOUNCY' || 
                         transitionType === 'EASE_IN_AND_OUT' || transitionType === 'EASE_IN' || 
                         transitionType === 'EASE_OUT' || transitionType === 'LINEAR'
            });
            
            if (transitionType === 'SMART_ANIMATE' || transitionType === 'BOUNCY' || 
                transitionType === 'EASE_IN_AND_OUT' || transitionType === 'EASE_IN' || 
                transitionType === 'EASE_OUT' || transitionType === 'LINEAR' || 
                transitionType === 'GENTLE') {
              console.log('DEBUG: Using animated variant switching');
              // Handle animated variant switching with copy approach
              handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration)
                .then(() => {
                  clearTimeout(safetyTimeout);
                  isTransitionInProgress = false;
                })
                .catch((error) => {
                  console.error('Animation error:', error);
                  clearTimeout(safetyTimeout);
                  isTransitionInProgress = false;
                });
            } else {
              console.log('DEBUG: Using instant variant switching - transition type not recognized:', transitionType);
              // Handle instant variant switching
              performInstantVariantSwitch(allVariants, destination);
              clearTimeout(safetyTimeout);
              isTransitionInProgress = false;
            }
          } else {
            // This is a regular transition (not variant switching)
            // Handle different transition types
            if (transitionType === 'DISSOLVE') {
              // Dissolve transition
              sourceElement.style.opacity = '0';
              setTimeout(() => {
                sourceElement.style.opacity = '1';
                destination.classList.add('variant-active');
                destination.classList.remove('variant-hidden');
                destination.style.opacity = '1';
                
                startTimeoutReactionsForNewlyActiveVariant(destination);
                startTimeoutReactionsForNestedComponents(destination);
                
                clearTimeout(safetyTimeout);
                isTransitionInProgress = false;
              }, parseFloat(transitionDuration || '300'));
            } else {
              // Default transition - simple show/hide
              sourceElement.style.opacity = '1';
              destination.classList.add('variant-active');
              destination.classList.remove('variant-hidden');
              destination.style.opacity = '1';
              
              startTimeoutReactionsForNewlyActiveVariant(destination);
              startTimeoutReactionsForNestedComponents(destination);
              
              clearTimeout(safetyTimeout);
              isTransitionInProgress = false;
            }
          }
        } else {
          // No destination ID provided
          clearTimeout(safetyTimeout);
          isTransitionInProgress = false;
        }
      }
      
      // Make function globally available
      window.handleReaction = handleReaction;
    
      
      // Initialize component set variants - handle both single and multiple variants
      // Handle both COMPONENT_SET and COMPONENT elements that contain variants
      // With the new 1:1 structure, this will handle nested component sets correctly
      const componentSets = document.querySelectorAll('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
      componentSets.forEach(componentSet => {
        // Find all COMPONENT children - these are the variants
        // Some may have explicit variant attributes, others are variants by hierarchy
        const variants = componentSet.querySelectorAll('[data-figma-type="COMPONENT"]');
        
        // Handle both single and multiple variants
        if (variants.length >= 1) {
          console.log('Initializing component set/instance with', variants.length, 'variants:', {
            componentSetId: componentSet.getAttribute('data-figma-id'),
            componentSetName: componentSet.getAttribute('data-figma-name'),
            componentSetType: componentSet.getAttribute('data-figma-type'),
            parentType: componentSet.parentElement?.getAttribute('data-figma-type'),
            parentId: componentSet.parentElement?.getAttribute('data-figma-id'),
            variantIds: Array.from(variants).map(v => v.getAttribute('data-figma-id'))
          });
          
          // Reset opacity for all variants to ensure clean initial state
          variants.forEach(variant => {
            variant.style.opacity = '1'; // Ensure all variants start with opacity 1
          });
          
          // For single components, just make them visible
          if (variants.length === 1) {
            const singleVariant = variants[0];
            singleVariant.classList.add('variant-active');
            singleVariant.classList.remove('variant-hidden');
            console.log('Set single variant as active:', singleVariant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
          } else {
            // For multiple variants, the FIRST variant should be active initially (where reactions are)
            // This ensures the animation starts from the variant with reactions
            variants.forEach((variant, index) => {
              if (index === 0) {
                variant.classList.add('variant-active');
                variant.classList.remove('variant-hidden');
                console.log('Set first variant as active (with reactions):', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
              } else {
                variant.classList.add('variant-hidden');
                variant.classList.remove('variant-active');
                console.log('Set variant as hidden:', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
              }
            });
          }
        }
      });
  
      console.log('DEBUG: All event handlers initialized');
    });
    
    // Also run immediately if DOM is already loaded
    if (document.readyState === 'loading') {
      console.log('DEBUG: DOM still loading, waiting for DOMContentLoaded');
    } else {
      console.log('DEBUG: DOM already loaded, running handlers immediately');
      
      // Handle variant switching - instant switching only, no animation
      // This is a simple slideshow-like system that switches between variants instantly
      const variantButtons = document.querySelectorAll('[data-variant], [data-variant-property-1]');
      variantButtons.forEach(button => {
        button.addEventListener('click', function() {
          console.log('DEBUG: Variant switch clicked');
          
          const variant = this.getAttribute('data-variant') || this.getAttribute('data-variant-property-1');
          const targetId = this.getAttribute('data-target');
          
          if (targetId) {
            const target = document.querySelector(`[data-figma-id="${targetId}"]`);
            if (target) {
              console.log('Variant switch:', { variant, targetId, targetName: target.getAttribute('data-figma-name') });
              
              // Find the specific component set that contains this button
              let componentSet = target;
              let buttonElement = this;
              
              // Walk up the DOM tree to find the immediate component set parent
              while (buttonElement && buttonElement.parentElement) {
                buttonElement = buttonElement.parentElement;
                if (buttonElement.getAttribute('data-figma-type') === 'COMPONENT_SET') {
                  componentSet = buttonElement;
                  console.log('Found component set for switching:', {
                    id: componentSet.getAttribute('data-figma-id'),
                    name: componentSet.getAttribute('data-figma-name')
                  });
                  break;
                }
              }
              
              // Get all variants within this specific component set instance
              const allVariants = Array.from(componentSet.children).filter(child => 
                child.getAttribute('data-figma-type') === 'COMPONENT' &&
                (child.getAttribute('data-variant') || child.getAttribute('data-variant-property-1'))
              );
              
              console.log('Found', allVariants.length, 'variants in component set:', componentSet.getAttribute('data-figma-id'));
              
              // INSTANT VARIANT SWITCHING - Hide all variants
              allVariants.forEach(variant => {
                variant.classList.add('variant-hidden');
                variant.classList.remove('variant-active');
                // Ensure all variants maintain their original positioning (relative with 0px)
                variant.style.position = 'relative';
                variant.style.top = '0px';
                variant.style.left = '0px';
                console.log('Hidden variant:', variant.getAttribute('data-figma-id'));
              });
              
              // Show selected variant instantly
              const selectedVariant = allVariants.find(v => 
                v.getAttribute('data-variant') === variant || 
                v.getAttribute('data-variant-property-1') === variant
              );
              
              if (selectedVariant) {
                selectedVariant.classList.add('variant-active');
                selectedVariant.classList.remove('variant-hidden');
                // Ensure selected variant maintains its original positioning
                selectedVariant.style.position = 'relative';
                selectedVariant.style.top = '0px';
                selectedVariant.style.left = '0px';
                console.log('Switched to variant:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));
                
                // Start timeout reactions for the newly active variant
                startTimeoutReactionsForNewlyActiveVariant(selectedVariant);
                startTimeoutReactionsForNestedComponents(selectedVariant);
              } else {
                console.log('Selected variant not found:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));
              }
            }
          }
        });
      });
  
      
      // Handle reactions - click, press, and drag
      const reactionElements = document.querySelectorAll('[data-has-reactions="true"]');
      reactionElements.forEach(element => {
        const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
        const actionType = element.getAttribute('data-reaction-action-type');
        const destinationId = element.getAttribute('data-reaction-destination');
        const transitionType = element.getAttribute('data-reaction-transition-type');
        const transitionDuration = element.getAttribute('data-reaction-transition-duration');
        
        // Handle click, press, and drag reactions
        element.addEventListener('click', function() {
          console.log('DEBUG: Click event triggered on element:', {
            id: this.getAttribute('data-figma-id'),
            name: this.getAttribute('data-figma-name'),
            type: this.getAttribute('data-figma-type'),
            trigger: trigger,
            actionType: actionType,
            destinationId: destinationId,
            transitionType: transitionType,
            transitionDuration: transitionDuration
          });
          
          if (trigger.type === 'ON_CLICK' || trigger.type === 'ON_PRESS') {
            console.log('DEBUG: Processing click reaction for element:', this.getAttribute('data-figma-id'));
            handleReaction(this, destinationId, transitionType, transitionDuration);
          }
        });
        
        // Handle drag reactions
        element.addEventListener('mousedown', function() {
          if (trigger.type === 'ON_DRAG') {
            handleReaction(this, destinationId, transitionType, transitionDuration);
          }
        });
      });
  
      
      // Track which variants have active timers (for preventing duplicate timers during the same activation)
      const activeTimers = new Map(); // elementId -> timeoutId
      
      // Function to start timeout reactions for active variants
      function startTimeoutReactionsForActiveVariants() {
        // Look for both variant-active elements with reactions AND any elements with reactions that don't have variant properties
        const activeVariants = document.querySelectorAll('.variant-active[data-has-reactions="true"]');
        const reactionElements = document.querySelectorAll('[data-has-reactions="true"]');
        
        console.log('DEBUG: Found', activeVariants.length, 'active variants with reactions');
        console.log('DEBUG: Found', reactionElements.length, 'total elements with reactions');
        
        // Process active variants first
        activeVariants.forEach(element => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          const parentComponent = element.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing variant:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for variants that are actually visible (not hidden by CSS)
          const computedStyle = window.getComputedStyle(element);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
            const actionType = element.getAttribute('data-reaction-action-type');
            const destinationId = element.getAttribute('data-reaction-destination');
            const transitionType = element.getAttribute('data-reaction-transition-type');
            const transitionDuration = element.getAttribute('data-reaction-transition-duration');
            
            // Handle timeout reactions only for active variants that don't have an active timer
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId); // Clear the timer when it completes
                handleReaction(element, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
          }
        });
        
        // Also process any reaction elements that don't have variant properties (like 6461:693)
        reactionElements.forEach(element => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          
          // Skip if this element was already processed as a variant
          if (element.classList.contains('variant-active')) {
            return;
          }
          
          // Skip if this element has variant properties (it will be handled by variant logic)
          if (element.hasAttribute('data-variant-property-1')) {
            return;
          }
          
          const parentComponent = element.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing non-variant reaction element:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for elements that are actually visible (not hidden by CSS)
          const computedStyle = window.getComputedStyle(element);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
            const actionType = element.getAttribute('data-reaction-action-type');
            const destinationId = element.getAttribute('data-reaction-destination');
            const transitionType = element.getAttribute('data-reaction-transition-type');
            const transitionDuration = element.getAttribute('data-reaction-transition-duration');
            
            // Handle timeout reactions only for elements that don't have an active timer
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId); // Clear the timer when it completes
                handleReaction(element, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
          }
        });
      }
      
      // Function to start timeout reactions for nested components when their parent becomes visible
      function startTimeoutReactionsForNestedComponents(parentElement) {
        if (!parentElement) return;
        
        // Find all nested components with timeout reactions within the parent
        const nestedComponents = parentElement.querySelectorAll('[data-has-reactions="true"][data-reaction-trigger*="AFTER_TIMEOUT"]');
        
        nestedComponents.forEach(component => {
          const elementId = component.getAttribute('data-figma-id');
          const elementName = component.getAttribute('data-figma-name');
          const parentComponent = component.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing nested component:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for nested components that are actually visible
          const computedStyle = window.getComputedStyle(component);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(component.getAttribute('data-reaction-trigger') || '{}');
            
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId);
                const actionType = component.getAttribute('data-reaction-action-type');
                const destinationId = component.getAttribute('data-reaction-destination');
                const transitionType = component.getAttribute('data-reaction-transition-type');
                const transitionDuration = component.getAttribute('data-reaction-transition-duration');
                handleReaction(component, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');
          }
        });
      }
      
      // Function to start timeout reactions for a specific newly active variant
      function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {
        if (!newlyActiveElement) return;
        
        const elementId = newlyActiveElement.getAttribute('data-figma-id');
        const elementName = newlyActiveElement.getAttribute('data-figma-name');
        const parentComponent = newlyActiveElement.closest('[data-figma-type="COMPONENT_SET"]');
        const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
        
        console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);
        
        // Only start timers for variants that are actually visible (not hidden by CSS)
        const computedStyle = window.getComputedStyle(newlyActiveElement);
        
        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
          const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');
          const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');
          const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');
          const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');
          const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');
          
          // Handle timeout reactions only for active variants that don't have an active timer
          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
            console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
            const timeoutId = setTimeout(() => {
              activeTimers.delete(elementId); // Clear the timer when it completes
              handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);
            }, (trigger.timeout || 0) * 1000);
            activeTimers.set(elementId, timeoutId);
          } else if (activeTimers.has(elementId)) {
            console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');
          }
          
          // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant
          startTimeoutReactionsForNestedComponents(newlyActiveElement);
        } else {
          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
        }
      }
      
      // CRITICAL FIX: Only start timeout reactions for the initial visible variant
      // Instead of starting timers for all variant-active elements immediately,
      // we wait for the first variant transition or user interaction
      function startTimeoutReactionsForInitialVariant() {
        // Find the first visible variant that should start the flow
        // This is typically the first variant in a component set that's marked as active
        const componentSets = document.querySelectorAll('[data-figma-type="COMPONENT_SET"]');
        console.log('DEBUG: Found', componentSets.length, 'component sets');
        
        // Also check for any elements with reactions
        const allReactionElements = document.querySelectorAll('[data-has-reactions="true"]');
        console.log('DEBUG: Found', allReactionElements.length, 'total elements with reactions');
        
        // Log details about reaction elements
        allReactionElements.forEach((element, index) => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
          const computedStyle = window.getComputedStyle(element);
          
          console.log('DEBUG: Reaction element', index + 1, ':', {
            id: elementId,
            name: elementName,
            trigger: trigger,
            display: computedStyle.display,
            visibility: computedStyle.visibility,
            isActive: element.classList.contains('variant-active'),
            isHidden: element.classList.contains('variant-hidden')
          });
        });
        
        componentSets.forEach(componentSet => {
          const componentSetName = componentSet.getAttribute('data-figma-name');
          const activeVariants = componentSet.querySelectorAll('.variant-active[data-has-reactions="true"]');
          console.log('DEBUG: Component set', componentSetName, 'has', activeVariants.length, 'active variants with reactions');
          
          // Only start timers for the first active variant in each component set
          if (activeVariants.length > 0) {
            const firstActiveVariant = activeVariants[0];
            const elementId = firstActiveVariant.getAttribute('data-figma-id');
            const elementName = firstActiveVariant.getAttribute('data-figma-name');
            const computedStyle = window.getComputedStyle(firstActiveVariant);
            
            console.log('DEBUG: Processing initial variant:', elementId, 'name:', elementName, 'in component set:', componentSetName);
            
            // Only start timer if the variant is actually visible
            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
              const trigger = JSON.parse(firstActiveVariant.getAttribute('data-reaction-trigger') || '{}');
              
              // Skip nested components that should only start when their parent becomes visible
              // Allow independent components to start their timers on page load
              // Check if this component set is nested within another component set
              const parentComponentSet = componentSet.closest('[data-figma-type="COMPONENT_SET"]');
              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;
              
              if (isNestedComponent) {
                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');
                return;
              }
              
              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
                console.log('DEBUG: Starting initial timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);
                const timeoutId = setTimeout(() => {
                  console.log('DEBUG: Timeout triggered for element:', elementId, 'name:', elementName);
                  activeTimers.delete(elementId);
                  const actionType = firstActiveVariant.getAttribute('data-reaction-action-type');
                  const destinationId = firstActiveVariant.getAttribute('data-reaction-destination');
                  const transitionType = firstActiveVariant.getAttribute('data-reaction-transition-type');
                  const transitionDuration = firstActiveVariant.getAttribute('data-reaction-transition-duration');
                  console.log('DEBUG: Calling handleReaction with:', {
                    destinationId: destinationId,
                    transitionType: transitionType,
                    transitionDuration: transitionDuration
                  });
                  handleReaction(firstActiveVariant, destinationId, transitionType, transitionDuration);
                }, (trigger.timeout || 0) * 1000);
                activeTimers.set(elementId, timeoutId);
                console.log('DEBUG: Created timeout timer for element:', elementId, 'timeout ID:', timeoutId, 'duration:', (trigger.timeout || 0) * 1000, 'ms');
                
                // CRITICAL FIX: Also start timeout reactions for any nested components within this initial variant
                startTimeoutReactionsForNestedComponents(firstActiveVariant);
              } else {
                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- no timeout trigger or timer already active');
              }
            } else {
              console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
            }
          }
          
          // CRITICAL FIX: Also check for non-variant reaction elements in this component set
          const reactionElements = componentSet.querySelectorAll('[data-has-reactions="true"]');
          reactionElements.forEach(element => {
            const elementId = element.getAttribute('data-figma-id');
            const elementName = element.getAttribute('data-figma-name');
            
            // Skip if this element was already processed as a variant
            if (element.classList.contains('variant-active')) {
              return;
            }
            
            // Skip if this element has variant properties (it will be handled by variant logic)
            if (element.hasAttribute('data-variant-property-1')) {
              return;
            }
            
            const computedStyle = window.getComputedStyle(element);
            
            console.log('DEBUG: Processing initial non-variant reaction element:', elementId, 'name:', elementName, 'in component set:', componentSetName);
            
            // Only start timer if the element is actually visible
            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
              const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
              
              // Skip nested components that should only start when their parent becomes visible
              const parentComponentSet = componentSet.closest('[data-figma-type="COMPONENT_SET"]');
              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;
              
              if (isNestedComponent) {
                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');
                return;
              }
              
              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
                console.log('DEBUG: Starting initial timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);
                const timeoutId = setTimeout(() => {
                  activeTimers.delete(elementId);
                  const actionType = element.getAttribute('data-reaction-action-type');
                  const destinationId = element.getAttribute('data-reaction-destination');
                  const transitionType = element.getAttribute('data-reaction-transition-type');
                  const transitionDuration = element.getAttribute('data-reaction-transition-duration');
                  handleReaction(element, destinationId, transitionType, transitionDuration);
                }, (trigger.timeout || 0) * 1000);
                activeTimers.set(elementId, timeoutId);
                
                // Also start timeout reactions for any nested components within this element
                startTimeoutReactionsForNestedComponents(element);
              } else {
                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- no timeout trigger or timer already active');
              }
            } else {
              console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
            }
          });
        });
      }
      
      // Start timeout reactions for the initial visible variant after a short delay
      // to ensure CSS classes and visibility are properly applied
      console.log('DEBUG: Setting up initial timeout reactions');
      setTimeout(() => {
        console.log('DEBUG: Starting initial timeout reactions');
        startTimeoutReactionsForInitialVariant();
      }, 100);
  
      
      // Helper function to find elements with property changes between variants
      function findElementsWithPropertyChanges(targetVariant, currentVariant) {
        console.log('DEBUG: findElementsWithPropertyChanges called');
        console.log('  Target variant ID:', targetVariant.getAttribute('data-figma-id'), 'Name:', targetVariant.getAttribute('data-figma-name'));
        console.log('  Current variant ID:', currentVariant.getAttribute('data-figma-id'), 'Name:', currentVariant.getAttribute('data-figma-name'));
        
        if (!currentVariant) {
          console.log('DEBUG: No current variant provided, returning empty array');
          return [];
        }
        
        const targetElements = targetVariant.querySelectorAll('[data-figma-id]');
        const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');
        const sourceElementMap = new Map();
        const elementsToAnimate = [];

        console.log('DEBUG: Found', targetElements.length, 'target elements and', sourceElements.length, 'source elements');

        // Build source element map by name
        sourceElements.forEach(function(sourceElement) {
          const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');
          if (sourceName) {
            sourceElementMap.set(sourceName, sourceElement);
            console.log('  Mapped source element:', sourceName, '->', sourceElement.getAttribute('data-figma-id'));
          }
        });

        // Analyze each target element for property changes
        targetElements.forEach(function(element, index) {
          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
          const sourceElement = sourceElementMap.get(targetName);
          
          console.log('DEBUG: Analyzing target element ' + (index + 1) + ':', targetName);
          console.log('  Target element ID:', element.getAttribute('data-figma-id'));
          console.log('  Source element found:', !!sourceElement);
          
          if (sourceElement) {
            console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));
            const changes = detectPropertyChanges(element, sourceElement);
            
            if (changes.hasChanges) {
              elementsToAnimate.push({
                element: sourceElement,  // Use SOURCE element (from copy) instead of target
                sourceElement: sourceElement,
                changes: changes
              });
              console.log('DEBUG: Found element with property changes:', targetName, 'changes:', changes);
            } else {
              console.log('DEBUG: No changes detected for element:', targetName);
            }
          } else {
            console.log('DEBUG: No matching source element found for:', targetName);
          }
        });
        
        console.log('DEBUG: Returning', elementsToAnimate.length, 'elements to animate');
        return elementsToAnimate;
      }

      // Helper function to detect property changes between elements
      function detectPropertyChanges(targetElement, sourceElement) {
        const changes = {
          hasChanges: false,
          positionX: { changed: false, sourceValue: null, targetValue: null },
          positionY: { changed: false, sourceValue: null, targetValue: null },
          backgroundColor: { changed: false, sourceValue: null, targetValue: null },
          color: { changed: false, sourceValue: null, targetValue: null },
          justifyContent: { changed: false, sourceValue: null, targetValue: null },
          alignItems: { changed: false, sourceValue: null, targetValue: null }
        };

        try {
          // Check position changes by comparing the computed styles
          const sourceStyle = window.getComputedStyle(sourceElement);
          const targetStyle = window.getComputedStyle(targetElement);
          
          // Check left position changes - use Figma data attributes for more accurate positioning
          const sourceLeft = parseFloat(sourceStyle.left) || 0;
          const targetLeft = parseFloat(targetStyle.left) || 0;
          
          // Get Figma position data for more accurate target positioning
          const sourceFigmaX = parseFloat(sourceElement.getAttribute('data-figma-x')) || 0;
          const targetFigmaX = parseFloat(targetElement.getAttribute('data-figma-x')) || 0;
          
          // CRITICAL FIX: Check if the source element has a transform applied from a previous animation
          // If so, we need to account for that in the position calculation
          const sourceTransform = sourceStyle.transform;
          let sourceTransformOffset = 0;
          if (sourceTransform && sourceTransform !== 'none') {
            // Extract translateX value from transform matrix
            const matrix = new DOMMatrix(sourceTransform);
            sourceTransformOffset = matrix.m41; // m41 is the translateX value
            console.log('DEBUG: Source element has transform:', sourceTransform, 'translateX offset:', sourceTransformOffset);
          }
          
          // Log detailed information about the elements
          const sourceName = sourceElement.getAttribute('data-figma-name');
          const targetName = targetElement.getAttribute('data-figma-name');
          const sourceId = sourceElement.getAttribute('data-figma-id');
          const targetId = targetElement.getAttribute('data-figma-id');
          
          console.log('DEBUG: Analyzing elements:');
          console.log('  Source:', sourceName, 'ID:', sourceId, 'Left:', sourceLeft, 'FigmaX:', sourceFigmaX);
          console.log('  Target:', targetName, 'ID:', targetId, 'Left:', targetLeft, 'FigmaX:', targetFigmaX);
          
          // Log parent container dimensions
          const sourceContainer = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          const targetContainer = targetElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          
          if (sourceContainer) {
            const sourceContainerRect = sourceContainer.getBoundingClientRect();
            console.log('  Source container dimensions:', sourceContainerRect.width, 'x', sourceContainerRect.height);
          }
          
          if (targetContainer) {
            const targetContainerRect = targetContainer.getBoundingClientRect();
            console.log('  Target container dimensions:', targetContainerRect.width, 'x', targetContainerRect.height);
          }
          
          // Log viewport dimensions
          console.log('  Viewport dimensions:', window.innerWidth, 'x', window.innerHeight);
          
          // Log element dimensions
          const sourceRect = sourceElement.getBoundingClientRect();
          const targetRect = targetElement.getBoundingClientRect();
          console.log('  Source element dimensions:', sourceRect.width, 'x', sourceRect.height);
          console.log('  Target element dimensions:', targetRect.width, 'x', targetRect.height);
          
          // Check if target element is properly rendered
          if (targetRect.width === 0 && targetRect.height === 0) {
            console.log('DEBUG: Target element has zero dimensions, skipping animation');
            return changes;
          }
          
          // CRITICAL FIX: Use current computed position for source if element has been animated
          // This ensures we detect changes from the actual current position, not the original Figma position
          const sourceHasBeenAnimated = sourceElement.style.position === 'absolute' && 
                                       (sourceElement.style.left || sourceElement.style.top);
          
          // Calculate target position by scaling Figma coordinates to actual rendered size
          // Use SOURCE element's parent (copy) for scaling since we're animating the copy
          const sourceContainerForScaling = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          const targetContainerForScaling = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          
          let finalTargetLeft = 0; // Start with 0, will be calculated below
          // Always use computed styles for consistency
          let finalSourceLeft = parseFloat(sourceStyle.left) || 0;
          
          // Add transform offset if present
          finalSourceLeft += sourceTransformOffset;
          
          // CRITICAL FIX: Scale position from component set dimensions to instance dimensions
          // The target element is positioned in the component set (2619.125px) but needs to be scaled to the instance (346px)
          const targetComputedStyle = window.getComputedStyle(targetElement);
          let targetContainerX = targetElement.parentElement;
          
          // Walk up the DOM tree to find the nearest INSTANCE container
          while (targetContainerX && targetContainerX.getAttribute('data-figma-type') !== 'INSTANCE') {
            targetContainerX = targetContainerX.parentElement;
          }
          
          if (targetContainerX) {
            const containerRectX = targetContainerX.getBoundingClientRect();
            const targetElementRectX = targetElement.getBoundingClientRect();
            
            // Get the original Figma X position from the target element
            const figmaX = parseFloat(targetElement.getAttribute('data-figma-x')) || 0;
            
            // Scale factor: instance width / component set width
            // From JSON: component set width = 2619.125px, instance width = 346px
            const componentSetWidth = 2619.125;
            const instanceWidth = containerRectX.width;
            const scaleFactor = instanceWidth / componentSetWidth;
            
            // Scale the Figma X position to fit within the instance
            // Account for the object's width to prevent overflow
            const objectWidth = targetElementRectX.width;
            const scaledPosition = figmaX * scaleFactor;
            
            // Ensure the object doesn't overflow the container
            finalTargetLeft = Math.min(scaledPosition, instanceWidth - objectWidth);
            
            console.log('DEBUG: Position calculation with object size:', {
              figmaX: figmaX,
              scaleFactor: scaleFactor,
              scaledPosition: scaledPosition,
              objectWidth: objectWidth,
              instanceWidth: instanceWidth,
              finalTargetLeft: finalTargetLeft
            });
            
            console.log('DEBUG: Using scaled INSTANCE-relative position calculation:', {
              targetElementLeft: targetElementRectX.left,
              containerLeft: containerRectX.left,
              containerWidth: containerRectX.width,
              figmaX: figmaX,
              componentSetWidth: componentSetWidth,
              scaleFactor: scaleFactor,
              finalTargetLeft: finalTargetLeft,
              targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'),
              containerElement: targetContainerX.tagName + (targetContainerX.className ? '.' + targetContainerX.className : ''),
              containerType: targetContainerX.getAttribute('data-figma-type'),
              containerId: targetContainerX.getAttribute('data-figma-id'),
              targetComputedLeft: targetComputedStyle.left
            });
          } else {
            // Fallback to computed values if no instance found
            finalTargetLeft = parseFloat(targetComputedStyle.left) || 0;
            console.log('DEBUG: Using computed values fallback:', {
              targetComputedLeft: targetComputedStyle.left,
              finalTargetLeft: finalTargetLeft,
              targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id')
            });
          }
          
          console.log('DEBUG: X Position Analysis:');
          console.log('  Source has been animated:', sourceHasBeenAnimated);
          console.log('  Source computed left:', sourceLeft, 'Source Figma X:', sourceFigmaX, 'Transform offset:', sourceTransformOffset, 'Final source left:', finalSourceLeft);
          console.log('  Target computed left:', targetLeft, 'Target Figma X:', targetFigmaX, 'Final target left:', finalTargetLeft);
          
          if (Math.abs(finalSourceLeft - finalTargetLeft) > 1) {
            changes.positionX.changed = true;
            changes.positionX.sourceValue = finalSourceLeft;
            changes.positionX.targetValue = finalTargetLeft;
            changes.hasChanges = true;
            console.log('DEBUG: Position X change detected:', finalSourceLeft, '->', finalTargetLeft, '(scaled from Figma coordinates)');
            console.log('DEBUG: Position X change details:');
            console.log('  Source element rect:', sourceElement.getBoundingClientRect());
            console.log('  Target element rect:', targetElement.getBoundingClientRect());
            console.log('  Source element computed style:', window.getComputedStyle(sourceElement).left);
            console.log('  Target element computed style:', window.getComputedStyle(targetElement).left);
          } else {
            console.log('DEBUG: No X position change detected - difference:', Math.abs(finalSourceLeft - finalTargetLeft));
          }
          
          // Check top position changes - use Figma data attributes for more accurate positioning
          const sourceTop = parseFloat(sourceStyle.top) || 0;
          const targetTop = parseFloat(targetStyle.top) || 0;
          
          // Get Figma position data for more accurate target positioning
          const sourceFigmaY = parseFloat(sourceElement.getAttribute('data-figma-y')) || 0;
          const targetFigmaY = parseFloat(targetElement.getAttribute('data-figma-y')) || 0;
          
          // CRITICAL FIX: Check if the source element has a transform applied from a previous animation
          // If so, we need to account for that in the position calculation
          let sourceTransformYOffset = 0;
          if (sourceTransform && sourceTransform !== 'none') {
            // Extract translateY value from transform matrix
            const matrix = new DOMMatrix(sourceTransform);
            sourceTransformYOffset = matrix.m42; // m42 is the translateY value
            console.log('DEBUG: Source element has transform:', sourceTransform, 'translateY offset:', sourceTransformYOffset);
          }
          
          // Calculate target position by scaling Figma coordinates to actual rendered size
          let finalTargetTop = 0; // Start with 0, will be calculated below
          // Always use computed styles for consistency
          let finalSourceTop = parseFloat(sourceStyle.top) || 0;
          
          // Add transform offset if present
          finalSourceTop += sourceTransformYOffset;
          
          // CRITICAL FIX: Scale position from component set dimensions to instance dimensions
          // The target element is positioned in the component set but needs to be scaled to the instance
          const targetComputedStyleY = window.getComputedStyle(targetElement);
          let targetContainerY = targetElement.parentElement;
          
          // Walk up the DOM tree to find the nearest INSTANCE container
          while (targetContainerY && targetContainerY.getAttribute('data-figma-type') !== 'INSTANCE') {
            targetContainerY = targetContainerY.parentElement;
          }
          
          if (targetContainerY) {
            const containerRectY = targetContainerY.getBoundingClientRect();
            const targetElementRectY = targetElement.getBoundingClientRect();
            
            // Get the original Figma Y position from the target element
            const figmaY = parseFloat(targetElement.getAttribute('data-figma-y')) || 0;
            
            // Scale factor: instance height / component set height
            // From JSON: component set height = 214px, instance height = 84px
            const componentSetHeight = 214;
            const instanceHeight = containerRectY.height;
            const scaleFactorY = instanceHeight / componentSetHeight;
            
            // Scale the Figma Y position to fit within the instance
            // Account for the object's height to prevent overflow
            const objectHeight = targetElementRectY.height;
            const scaledPositionY = figmaY * scaleFactorY;
            
            // Ensure the object doesn't overflow the container
            finalTargetTop = Math.min(scaledPositionY, instanceHeight - objectHeight);
            
            console.log('DEBUG: Y Position calculation with object size:', {
              figmaY: figmaY,
              scaleFactorY: scaleFactorY,
              scaledPositionY: scaledPositionY,
              objectHeight: objectHeight,
              instanceHeight: instanceHeight,
              finalTargetTop: finalTargetTop
            });
            
            console.log('DEBUG: Using scaled INSTANCE-relative position calculation Y:', {
              targetElementTop: targetElementRectY.top,
              containerTop: containerRectY.top,
              containerHeight: containerRectY.height,
              figmaY: figmaY,
              componentSetHeight: componentSetHeight,
              scaleFactorY: scaleFactorY,
              finalTargetTop: finalTargetTop,
              targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'),
              containerElement: targetContainerY.tagName + (targetContainerY.className ? '.' + targetContainerY.className : ''),
              containerType: targetContainerY.getAttribute('data-figma-type'),
              containerId: targetContainerY.getAttribute('data-figma-id'),
              targetComputedTop: targetComputedStyleY.top
            });
          } else {
            // Fallback to computed values if no instance found
            finalTargetTop = parseFloat(targetComputedStyleY.top) || 0;
            console.log('DEBUG: Using computed values fallback Y:', {
              targetComputedTop: targetComputedStyleY.top,
              finalTargetTop: finalTargetTop,
              targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id')
            });
          }
          
          console.log('DEBUG: Y Position Analysis:');
          console.log('  Source computed top:', sourceTop, 'Source Figma Y:', sourceFigmaY, 'Transform offset:', sourceTransformYOffset, 'Final source top:', finalSourceTop);
          console.log('  Target computed top:', targetTop, 'Target Figma Y:', targetFigmaY, 'Final target top:', finalTargetTop);
          
          if (Math.abs(finalSourceTop - finalTargetTop) > 1) {
            changes.positionY.changed = true;
            changes.positionY.sourceValue = finalSourceTop;
            changes.positionY.targetValue = finalTargetTop;
            changes.hasChanges = true;
            console.log('DEBUG: Position Y change detected:', finalSourceTop, '->', finalTargetTop, '(scaled from Figma coordinates)');
          } else {
            console.log('DEBUG: No Y position change detected - difference:', Math.abs(finalSourceTop - finalTargetTop));
          }

          // Check style changes - use more specific comparison
          const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          
          if (sourceBg !== targetBg) {
            changes.backgroundColor.changed = true;
            changes.backgroundColor.sourceValue = sourceBg;
            changes.backgroundColor.targetValue = targetBg;
            changes.hasChanges = true;
            console.log('DEBUG: Background color change detected:', sourceBg, '->', targetBg);
          }
          
          if (sourceStyle.color !== targetStyle.color) {
            changes.color.changed = true;
            changes.color.sourceValue = sourceStyle.color;
            changes.color.targetValue = targetStyle.color;
            changes.hasChanges = true;
            console.log('DEBUG: Color change detected:', sourceStyle.color, '->', targetStyle.color);
          }
          
          if (sourceStyle.justifyContent !== targetStyle.justifyContent) {
            changes.justifyContent.changed = true;
            changes.justifyContent.sourceValue = sourceStyle.justifyContent;
            changes.justifyContent.targetValue = targetStyle.justifyContent;
            changes.hasChanges = true;
          }
          
          if (sourceStyle.alignItems !== targetStyle.alignItems) {
            changes.alignItems.changed = true;
            changes.alignItems.sourceValue = sourceStyle.alignItems;
            changes.alignItems.targetValue = targetStyle.alignItems;
            changes.hasChanges = true;
          }
        } catch (error) {
          console.log('DEBUG: Error detecting property changes:', error);
        }

        return changes;
      }
  
      
      // Global transition lock to prevent multiple simultaneous transitions
      let isTransitionInProgress = false;
      
      // Helper function to map Figma animation types to CSS easing functions
      function getEasingFunction(animationType) {
        switch (animationType) {
          case 'EASE_IN_AND_OUT_BACK':
            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';
          case 'EASE_IN_AND_OUT':
            return 'ease-in-out';
          case 'EASE_IN':
            return 'ease-in';
          case 'EASE_OUT':
            return 'ease-out';
          case 'LINEAR':
            return 'linear';
          case 'BOUNCY':
            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';
          case 'GENTLE':
            return 'ease-in-out'; // Gentle is typically a smooth ease-in-out
          case 'SMART_ANIMATE':
            // SMART_ANIMATE should use the actual easing type from the reaction data
            // For now, default to ease-in-out which is commonly used for smart animate
            return 'ease-in-out';
          default:
            return 'ease-out';
        }
      }
      
      // Helper function to create a deep copy of an element
      function createElementCopy(sourceElement) {
        const copy = sourceElement.cloneNode(true);
        copy.setAttribute('data-figma-id', sourceElement.getAttribute('data-figma-id') + '-copy');
        copy.setAttribute('data-is-animation-copy', 'true');
        
        // Immediately reset all internal elements to their original positions
        const copyElements = copy.querySelectorAll('*');
        copyElements.forEach(element => {
          if (element.hasAttribute('data-figma-id')) {
            // Reset to original Figma positions (0,0) for animation
            element.style.position = 'relative';
            element.style.left = '0px';
            element.style.top = '0px';
            
            // Force remove any existing inline styles that might interfere
            element.style.removeProperty('transform');
            element.style.removeProperty('margin');
            element.style.removeProperty('padding');
            
            // Force the style to be applied by setting it again
            element.style.setProperty('left', '0px', 'important');
            element.style.setProperty('top', '0px', 'important');
            
            console.log('DEBUG: Reset copy element:', element.getAttribute('data-figma-id'), {
              position: element.style.position,
              left: element.style.left,
              top: element.style.top,
              computedLeft: window.getComputedStyle(element).left,
              computedTop: window.getComputedStyle(element).top,
              elementRect: element.getBoundingClientRect()
            });
          }
        });
        
        // Debug: List all elements in the copy with their IDs
        console.log('DEBUG: All elements in copy:', Array.from(copy.querySelectorAll('[data-figma-id]')).map(el => ({
          id: el.getAttribute('data-figma-id'),
          left: el.style.left,
          top: el.style.top
        })));
        
        // Get the source element's computed position
        const sourceRect = sourceElement.getBoundingClientRect();
        const parentRect = sourceElement.parentElement.getBoundingClientRect();
        
        // Position the copy absolutely over the source element
        copy.style.position = 'absolute';
        copy.style.top = (sourceRect.top - parentRect.top) + 'px';
        copy.style.left = (sourceRect.left - parentRect.left) + 'px';
        

        
        // Override any inline styles that might interfere with positioning
        copy.style.transform = 'none'; // Remove any transforms
        copy.style.margin = '0'; // Remove margins
        copy.style.padding = '0'; // Remove padding
        
        // Ensure copy is always on top by finding the highest z-index in the document
        const allElements = document.querySelectorAll('*');
        let maxZIndex = 0;
        allElements.forEach(el => {
          const zIndex = parseInt(window.getComputedStyle(el).zIndex) || 0;
          if (zIndex > maxZIndex) maxZIndex = zIndex;
        });
        
        // Set copy z-index higher than any existing element
        const copyZIndex = maxZIndex + 1000;
        copy.style.zIndex = copyZIndex.toString();
        copy.style.pointerEvents = 'none'; // Prevent interaction with copy
        copy.style.transform = 'translateZ(0)'; // Create new stacking context and enable hardware acceleration
        copy.style.willChange = 'transform, left, top'; // Optimize for animations
        
        console.log('DEBUG: Copy z-index management:', {
          maxZIndexFound: maxZIndex,
          copyZIndex: copyZIndex,
          copyPosition: copy.style.position,
          copyTop: copy.style.top,
          copyLeft: copy.style.left
        });
        
        console.log('DEBUG: Copy positioned at:', {
          sourceTop: sourceRect.top - parentRect.top,
          sourceLeft: sourceRect.left - parentRect.left,
          sourceRect: sourceRect,
          parentRect: parentRect,
          copyPosition: copy.style.position,
          copyTop: copy.style.top,
          copyLeft: copy.style.left
        });
        
        return copy;
      }
      
      // Helper function to animate copy to destination values
      function animateCopyToDestination(copy, destination, transitionType, transitionDuration) {
        return new Promise((resolve) => {
          // Find elements with property changes
          const elementsToAnimate = findElementsWithPropertyChanges(destination, copy);
          
          if (elementsToAnimate.length > 0) {
            console.log('DEBUG: Animating copy with', elementsToAnimate.length, 'elements');
            console.log('DEBUG: Elements to animate:', elementsToAnimate.map(({ element, changes }) => ({
              id: element.getAttribute('data-figma-id'),
              left: element.style.left,
              top: element.style.top,
              hasPositionX: changes.positionX?.changed || false,
              hasPositionY: changes.positionY?.changed || false
            })));
            
            // Setup animation for each element in the copy
            elementsToAnimate.forEach(({ element, sourceElement, changes }) => {
              const easingFunction = getEasingFunction(transitionType);
              const duration = parseFloat(transitionDuration || '0.3');
              
              console.log('DEBUG: Animation setup for element:', element.getAttribute('data-figma-id'), {
                transitionType: transitionType,
                easingFunction: easingFunction,
                duration: duration
              });
              
              // Build transition string
              const transitionProperties = [];
              if (changes.backgroundColor && changes.backgroundColor.changed) {
                transitionProperties.push(`background-color ${duration}s ${easingFunction}`);
              }
              if (changes.color && changes.color.changed) {
                transitionProperties.push(`color ${duration}s ${easingFunction}`);
              }
              if (changes.opacity && changes.opacity.changed) {
                transitionProperties.push(`opacity ${duration}s ${easingFunction}`);
              }
              if (changes.positionX && changes.positionX.changed) {
                transitionProperties.push(`left ${duration}s ${easingFunction}`);
              }
              if (changes.positionY && changes.positionY.changed) {
                transitionProperties.push(`top ${duration}s ${easingFunction}`);
              }
              if (changes.width && changes.width.changed) {
                transitionProperties.push(`width ${duration}s ${easingFunction}`);
              }
              if (changes.height && changes.height.changed) {
                transitionProperties.push(`height ${duration}s ${easingFunction}`);
              }
              
              // Apply transition
              if (transitionProperties.length > 0) {
                element.style.transition = transitionProperties.join(', ');
                console.log('DEBUG: Applied transition to element:', element.getAttribute('data-figma-id'), 'transition:', element.style.transition);
                
                // Verify transition was applied
                setTimeout(() => {
                  const computedTransition = window.getComputedStyle(element).transition;
                  console.log('DEBUG: Verified transition for element:', element.getAttribute('data-figma-id'), 'computed transition:', computedTransition);
                }, 0);
              }
            });
            
            // Force reflow to ensure transitions are applied
            copy.offsetHeight;
            
                    // Apply target values to animate the copy with proper timing
        requestAnimationFrame(() => {
          console.log('DEBUG: Applying target values to copy elements');
          
          // Log initial positions before animation
          elementsToAnimate.forEach(({ element, changes }) => {
            console.log('DEBUG: Initial position of element:', element.getAttribute('data-figma-id'), {
              top: element.style.top,
              left: element.style.left,
              transition: element.style.transition,
              computedTransition: window.getComputedStyle(element).transition
            });
          });
              
              elementsToAnimate.forEach(({ element, changes }) => {
                if (changes.backgroundColor && changes.backgroundColor.changed) {
                  element.style.backgroundColor = changes.backgroundColor.targetValue;
                }
                if (changes.color && changes.color.changed) {
                  element.style.color = changes.color.targetValue;
                }
                if (changes.opacity && changes.opacity.changed) {
                  element.style.opacity = changes.opacity.targetValue;
                }
                if (changes.positionX && changes.positionX.changed) {
                  // Set the target position directly (not relative to current position)
                  const targetLeft = parseFloat(changes.positionX.targetValue);
                  
                  console.log('DEBUG: Before position change - element:', element.getAttribute('data-figma-id'), {
                    currentLeft: element.style.left,
                    currentPosition: element.style.position,
                    targetLeft: targetLeft,
                    elementRect: element.getBoundingClientRect()
                  });
                  
                  element.style.left = targetLeft + 'px';
                  
                  console.log('DEBUG: After position change - element:', element.getAttribute('data-figma-id'), {
                    newLeft: element.style.left,
                    elementRect: element.getBoundingClientRect()
                  });
                  
                  console.log('DEBUG: Applied position change to copy:', element.getAttribute('data-figma-id'), 'from:', element.style.left || '0px', 'to:', targetLeft + 'px', 'target:', targetLeft, 'easing:', getEasingFunction(transitionType));
                }
                if (changes.positionY && changes.positionY.changed) {
                  // Set the target position directly (not relative to current position)
                  const targetTop = parseFloat(changes.positionY.targetValue);
                  
                  element.style.top = targetTop + 'px';
                  console.log('DEBUG: Applied position change to copy:', element.getAttribute('data-figma-id'), 'from:', element.style.top || '0px', 'to:', targetTop + 'px', 'target:', targetTop, 'easing:', getEasingFunction(transitionType));
                }
                if (changes.width && changes.width.changed) {
                  element.style.width = changes.width.targetValue + 'px';
                }
                if (changes.height && changes.height.changed) {
                  element.style.height = changes.height.targetValue + 'px';
                }
              });
            }, 16);
            
            // Monitor animation progress
            const animationDuration = parseFloat(transitionDuration || '0.3') * 1000;
            const checkInterval = 100; // Check every 100ms
            let checkCount = 0;
            
                          const progressCheck = setInterval(() => {
                checkCount++;
                elementsToAnimate.forEach(({ element, changes }) => {
                  const elementRect = element.getBoundingClientRect();
                  console.log('DEBUG: Animation progress check', checkCount, 'for element:', element.getAttribute('data-figma-id'), {
                    top: element.style.top,
                    left: element.style.left,
                    computedTop: getComputedStyle(element).top,
                    computedLeft: getComputedStyle(element).left,
                    boundingRect: elementRect,
                    isVisible: elementRect.width > 0 && elementRect.height > 0,
                    viewportPosition: {
                      x: elementRect.x,
                      y: elementRect.y,
                      right: elementRect.right,
                      bottom: elementRect.bottom
                    }
                  });
                });
              
              if (checkCount * checkInterval >= animationDuration) {
                clearInterval(progressCheck);
                console.log('DEBUG: Animation completed, removing copy');
                resolve();
              }
            }, checkInterval);
          } else {
            // No elements to animate, resolve immediately
            resolve();
          }
        });
      }
      
      // Helper function to perform instant variant switch (no animation)
      function performInstantVariantSwitch(allVariants, destination) {
        console.log('DEBUG: Performing instant variant switch');
        
        // Hide all variants
        allVariants.forEach(variant => {
          variant.classList.add('variant-hidden');
          variant.classList.remove('variant-active');
          // Ensure all variants maintain their original positioning
          variant.style.position = 'relative';
          variant.style.top = '0px';
          variant.style.left = '0px';
        });
        
        // Show destination variant
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        // Ensure destination maintains its original positioning
        destination.style.position = 'relative';
        destination.style.top = '0px';
        destination.style.left = '0px';
        
        // Start timeout reactions
        startTimeoutReactionsForNewlyActiveVariant(destination);
        startTimeoutReactionsForNestedComponents(destination);
      }
      
      // Helper function to handle animated variant switching using copy approach
      async function handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration) {
        console.log('DEBUG: Starting animated variant switch with copy approach');
        console.log('  Transition type:', transitionType, 'Duration:', transitionDuration);
        
        // Create a copy of the source variant
        const sourceCopy = createElementCopy(sourceElement);
        
        // Insert the copy into the DOM (positioned over the source)
        const sourceParent = sourceElement.parentElement;
        sourceParent.appendChild(sourceCopy);
        
        // Hide the original source element and all other variants for testing
        sourceElement.style.opacity = '0';
        sourceElement.style.visibility = 'hidden';
        
        // Hide all other variants too for clean testing
        allVariants.forEach(variant => {
          if (variant !== sourceElement) {
            variant.style.opacity = '0';
            variant.style.visibility = 'hidden';
          }
        });
        
        console.log('DEBUG: Copy created and positioned:', {
          copyId: sourceCopy.getAttribute('data-figma-id'),
          copyPosition: sourceCopy.style.position,
          copyTop: sourceCopy.style.top,
          copyLeft: sourceCopy.style.left,
          copyOpacity: sourceCopy.style.opacity,
          copyZIndex: sourceCopy.style.zIndex,
          copyDisplay: sourceCopy.style.display,
          copyVisibility: sourceCopy.style.visibility,
          copyTransform: sourceCopy.style.transform,
          copyWillChange: sourceCopy.style.willChange
        });
        
        // Log the copy's actual DOM position and visibility
        setTimeout(() => {
          const copyRect = sourceCopy.getBoundingClientRect();
          const copyComputedStyle = window.getComputedStyle(sourceCopy);
          console.log('DEBUG: Copy DOM position and visibility:', {
            copyId: sourceCopy.getAttribute('data-figma-id'),
            boundingRect: copyRect,
            computedPosition: copyComputedStyle.position,
            computedTop: copyComputedStyle.top,
            computedLeft: copyComputedStyle.left,
            computedOpacity: copyComputedStyle.opacity,
            computedZIndex: copyComputedStyle.zIndex,
            computedDisplay: copyComputedStyle.display,
            computedVisibility: copyComputedStyle.visibility,
            computedTransform: copyComputedStyle.transform,
            isVisible: copyRect.width > 0 && copyRect.height > 0 && copyComputedStyle.opacity !== '0',
            parentOverflow: window.getComputedStyle(sourceCopy.parentElement).overflow
          });
        }, 100);
        
        // Show the destination variant (but keep it hidden visually)
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        destination.style.visibility = 'hidden'; // Hidden but active for calculations
        
        // Force reflow to ensure destination is rendered for calculations
        destination.offsetHeight;
        
        // Animate the copy to match the destination
        await animateCopyToDestination(sourceCopy, destination, transitionType, transitionDuration);
        
        // Animation complete - restore normal behavior
        sourceCopy.remove(); // Remove the copy
        
        // Reset source element visibility
        sourceElement.style.opacity = '1';
        sourceElement.style.visibility = 'visible';
        
        console.log('DEBUG: Animation completed - normal behavior restored');
        
        // Properly activate the destination variant
        destination.style.visibility = 'visible';
        destination.style.opacity = '1';
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        
        // Ensure destination has proper positioning
        destination.style.position = 'relative';
        destination.style.top = '0px';
        destination.style.left = '0px';
        
        // Hide all other variants
        allVariants.forEach(variant => {
          if (variant !== destination) {
            variant.classList.add('variant-hidden');
            variant.classList.remove('variant-active');
            variant.style.position = 'relative';
            variant.style.top = '0px';
            variant.style.left = '0px';
            variant.style.opacity = '0';
            variant.style.visibility = 'hidden';
          }
        });
        
        console.log('DEBUG: Normal mode - copy removed, destination variant active and visible');
        
        // Start timeout reactions
        startTimeoutReactionsForNewlyActiveVariant(destination);
        startTimeoutReactionsForNestedComponents(destination);
      }
      
      // Helper function to handle reaction transitions
      function handleReaction(sourceElement, destinationId, transitionType, transitionDuration) {
        console.log('DEBUG: handleReaction called');
        console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));
        console.log('  Destination ID:', destinationId);
        console.log('  Transition type:', transitionType, 'Duration:', transitionDuration);
        
        // Prevent multiple simultaneous transitions
        if (isTransitionInProgress) {
          console.log('DEBUG: Transition already in progress, skipping');
          return;
        }
        
        // Set transition lock
        isTransitionInProgress = true;
        
        // Safety timeout
        const safetyTimeout = setTimeout(() => {
          if (isTransitionInProgress) {
            console.log('WARNING: Transition lock stuck, forcing release');
            isTransitionInProgress = false;
          }
        }, 5000);
        
        if (destinationId) {
          const destination = document.querySelector(`[data-figma-id="${destinationId}"]`);
          
          if (!destination) {
            console.log('ERROR: Destination element not found:', destinationId);
            clearTimeout(safetyTimeout);
            isTransitionInProgress = false;
            return;
          }
          
          // Check if this is a variant switch within a component set
          const sourceComponentSet = sourceElement.closest('[data-figma-type="COMPONENT_SET"]');
          const destinationComponentSet = destination.closest('[data-figma-type="COMPONENT_SET"]');
          
          if (sourceComponentSet && destinationComponentSet && sourceComponentSet === destinationComponentSet) {
            // This is a variant switch
            const componentSet = sourceComponentSet;
            const allVariants = Array.from(componentSet.children).filter(child => 
              child.getAttribute('data-figma-type') === 'COMPONENT'
            );
            
            console.log('DEBUG: Transition type check:', {
              transitionType: transitionType,
              transitionDuration: transitionDuration,
              isAnimated: transitionType === 'SMART_ANIMATE' || transitionType === 'BOUNCY' || 
                         transitionType === 'EASE_IN_AND_OUT' || transitionType === 'EASE_IN' || 
                         transitionType === 'EASE_OUT' || transitionType === 'LINEAR'
            });
            
            if (transitionType === 'SMART_ANIMATE' || transitionType === 'BOUNCY' || 
                transitionType === 'EASE_IN_AND_OUT' || transitionType === 'EASE_IN' || 
                transitionType === 'EASE_OUT' || transitionType === 'LINEAR' || 
                transitionType === 'GENTLE') {
              console.log('DEBUG: Using animated variant switching');
              // Handle animated variant switching with copy approach
              handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration)
                .then(() => {
                  clearTimeout(safetyTimeout);
                  isTransitionInProgress = false;
                })
                .catch((error) => {
                  console.error('Animation error:', error);
                  clearTimeout(safetyTimeout);
                  isTransitionInProgress = false;
                });
            } else {
              console.log('DEBUG: Using instant variant switching - transition type not recognized:', transitionType);
              // Handle instant variant switching
              performInstantVariantSwitch(allVariants, destination);
              clearTimeout(safetyTimeout);
              isTransitionInProgress = false;
            }
          } else {
            // This is a regular transition (not variant switching)
            // Handle different transition types
            if (transitionType === 'DISSOLVE') {
              // Dissolve transition
              sourceElement.style.opacity = '0';
              setTimeout(() => {
                sourceElement.style.opacity = '1';
                destination.classList.add('variant-active');
                destination.classList.remove('variant-hidden');
                destination.style.opacity = '1';
                
                startTimeoutReactionsForNewlyActiveVariant(destination);
                startTimeoutReactionsForNestedComponents(destination);
                
                clearTimeout(safetyTimeout);
                isTransitionInProgress = false;
              }, parseFloat(transitionDuration || '300'));
            } else {
              // Default transition - simple show/hide
              sourceElement.style.opacity = '1';
              destination.classList.add('variant-active');
              destination.classList.remove('variant-hidden');
              destination.style.opacity = '1';
              
              startTimeoutReactionsForNewlyActiveVariant(destination);
              startTimeoutReactionsForNestedComponents(destination);
              
              clearTimeout(safetyTimeout);
              isTransitionInProgress = false;
            }
          }
        } else {
          // No destination ID provided
          clearTimeout(safetyTimeout);
          isTransitionInProgress = false;
        }
      }
      
      // Make function globally available
      window.handleReaction = handleReaction;
    
      
      // Initialize component set variants - handle both single and multiple variants
      // Handle both COMPONENT_SET and COMPONENT elements that contain variants
      // With the new 1:1 structure, this will handle nested component sets correctly
      const componentSets = document.querySelectorAll('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
      componentSets.forEach(componentSet => {
        // Find all COMPONENT children - these are the variants
        // Some may have explicit variant attributes, others are variants by hierarchy
        const variants = componentSet.querySelectorAll('[data-figma-type="COMPONENT"]');
        
        // Handle both single and multiple variants
        if (variants.length >= 1) {
          console.log('Initializing component set/instance with', variants.length, 'variants:', {
            componentSetId: componentSet.getAttribute('data-figma-id'),
            componentSetName: componentSet.getAttribute('data-figma-name'),
            componentSetType: componentSet.getAttribute('data-figma-type'),
            parentType: componentSet.parentElement?.getAttribute('data-figma-type'),
            parentId: componentSet.parentElement?.getAttribute('data-figma-id'),
            variantIds: Array.from(variants).map(v => v.getAttribute('data-figma-id'))
          });
          
          // Reset opacity for all variants to ensure clean initial state
          variants.forEach(variant => {
            variant.style.opacity = '1'; // Ensure all variants start with opacity 1
          });
          
          // For single components, just make them visible
          if (variants.length === 1) {
            const singleVariant = variants[0];
            singleVariant.classList.add('variant-active');
            singleVariant.classList.remove('variant-hidden');
            console.log('Set single variant as active:', singleVariant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
          } else {
            // For multiple variants, the FIRST variant should be active initially (where reactions are)
            // This ensures the animation starts from the variant with reactions
            variants.forEach((variant, index) => {
              if (index === 0) {
                variant.classList.add('variant-active');
                variant.classList.remove('variant-hidden');
                console.log('Set first variant as active (with reactions):', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
              } else {
                variant.classList.add('variant-hidden');
                variant.classList.remove('variant-active');
                console.log('Set variant as hidden:', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
              }
            });
          }
        }
      });
  
      console.log('DEBUG: All event handlers initialized (immediate)');
    }
  
</script>
</body>
</html>