(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["FigmaRefactoredSystem"] = factory();
	else
		root["FigmaRefactoredSystem"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 44:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createComponentSetInitializer = createComponentSetInitializer;
// Component set initialization logic
function createComponentSetInitializer() {
    return "\n      // Initialize component set variants - handle both single and multiple variants\n      // Handle both COMPONENT_SET and COMPONENT elements that contain variants\n      // With the new 1:1 structure, this will handle nested component sets correctly\n      const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"], [data-figma-type=\"COMPONENT\"]');\n      componentSets.forEach(componentSet => {\n        // Find all COMPONENT children - these are the variants\n        // Some may have explicit variant attributes, others are variants by hierarchy\n        const variants = componentSet.querySelectorAll('[data-figma-type=\"COMPONENT\"]');\n        \n        // Handle both single and multiple variants\n        if (variants.length >= 1) {\n          console.log('Initializing component set/instance with', variants.length, 'variants:', {\n            componentSetId: componentSet.getAttribute('data-figma-id'),\n            componentSetName: componentSet.getAttribute('data-figma-name'),\n            componentSetType: componentSet.getAttribute('data-figma-type'),\n            parentType: componentSet.parentElement?.getAttribute('data-figma-type'),\n            parentId: componentSet.parentElement?.getAttribute('data-figma-id'),\n            variantIds: Array.from(variants).map(v => v.getAttribute('data-figma-id'))\n          });\n          \n          // Reset opacity for all variants to ensure clean initial state\n          variants.forEach(variant => {\n            variant.style.opacity = '1'; // Ensure all variants start with opacity 1\n          });\n          \n          // For single components, just make them visible\n          if (variants.length === 1) {\n            const singleVariant = variants[0];\n            singleVariant.classList.add('variant-active');\n            singleVariant.classList.remove('variant-hidden');\n            console.log('Set single variant as active:', singleVariant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));\n          } else {\n            // For multiple variants, the FIRST variant should be active initially (where reactions are)\n            // This ensures the animation starts from the variant with reactions\n            variants.forEach((variant, index) => {\n              if (index === 0) {\n                variant.classList.add('variant-active');\n                variant.classList.remove('variant-hidden');\n                console.log('Set first variant as active (with reactions):', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));\n              } else {\n                variant.classList.add('variant-hidden');\n                variant.classList.remove('variant-active');\n                console.log('Set variant as hidden:', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));\n              }\n            });\n          }\n        }\n      });\n  ";
}


/***/ }),

/***/ 82:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPropertyDetector = createPropertyDetector;
// Property change detection logic
function createPropertyDetector() {
    return "\n      // Helper function to find elements with property changes between variants\n      // This function has been moved to modular-transition-handler.ts to avoid conflicts\n      // The enhanced version with parent alignment detection is used instead\n  ";
}


/***/ }),

/***/ 120:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createVariantSwitchingHandler = createVariantSwitchingHandler;
// Variant switching handler - instant switching only, no animation
function createVariantSwitchingHandler() {
    return "\n      // Handle variant switching - instant switching only, no animation\n      // This is a simple slideshow-like system that switches between variants instantly\n      const variantButtons = document.querySelectorAll('[data-variant], [data-variant-property-1]');\n      variantButtons.forEach(button => {\n        button.addEventListener('click', function() {\n          console.log('DEBUG: Variant switch clicked');\n          \n          const variant = this.getAttribute('data-variant') || this.getAttribute('data-variant-property-1');\n          const targetId = this.getAttribute('data-target');\n          \n          if (targetId) {\n            const target = document.querySelector(`[data-figma-id=\"${targetId}\"]`);\n            if (target) {\n              console.log('Variant switch:', { variant, targetId, targetName: target.getAttribute('data-figma-name') });\n              \n              // Find the specific component set that contains this button\n              let componentSet = target;\n              let buttonElement = this;\n              \n              // Walk up the DOM tree to find the immediate component set parent\n              while (buttonElement && buttonElement.parentElement) {\n                buttonElement = buttonElement.parentElement;\n                if (buttonElement.getAttribute('data-figma-type') === 'COMPONENT_SET') {\n                  componentSet = buttonElement;\n                  console.log('Found component set for switching:', {\n                    id: componentSet.getAttribute('data-figma-id'),\n                    name: componentSet.getAttribute('data-figma-name')\n                  });\n                  break;\n                }\n              }\n              \n              // Get all variants within this specific component set instance\n              const allVariants = Array.from(componentSet.children).filter(child => \n                child.getAttribute('data-figma-type') === 'COMPONENT' &&\n                (child.getAttribute('data-variant') || child.getAttribute('data-variant-property-1'))\n              );\n              \n              console.log('Found', allVariants.length, 'variants in component set:', componentSet.getAttribute('data-figma-id'));\n              \n              // INSTANT VARIANT SWITCHING - Hide all variants\n              allVariants.forEach(variant => {\n                variant.classList.add('variant-hidden');\n                variant.classList.remove('variant-active');\n                // Ensure all variants maintain their original positioning (relative with 0px)\n                variant.style.position = 'relative';\n                variant.style.top = '0px';\n                variant.style.left = '0px';\n                console.log('Hidden variant:', variant.getAttribute('data-figma-id'));\n              });\n              \n              // Show selected variant instantly\n              const selectedVariant = allVariants.find(v => \n                v.getAttribute('data-variant') === variant || \n                v.getAttribute('data-variant-property-1') === variant\n              );\n              \n              if (selectedVariant) {\n                selectedVariant.classList.add('variant-active');\n                selectedVariant.classList.remove('variant-hidden');\n                // Ensure selected variant maintains its original positioning\n                selectedVariant.style.position = 'relative';\n                selectedVariant.style.top = '0px';\n                selectedVariant.style.left = '0px';\n                console.log('Switched to variant:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));\n                \n                // Start timeout reactions for the newly active variant\n                startTimeoutReactionsForNewlyActiveVariant(selectedVariant);\n                startTimeoutReactionsForNestedComponents(selectedVariant);\n              } else {\n                console.log('Selected variant not found:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));\n              }\n            }\n          }\n        });\n      });\n  ";
}


/***/ }),

/***/ 172:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createComponentSetInitializer = exports.createModularSmartAnimateHandler = exports.createPropertyDetector = exports.createTimeoutHandler = exports.createReactionHandler = exports.createVariantSwitchingHandler = exports.generateVariantAttributes = exports.generateReactionAttributes = void 0;
exports.generateEventHandlingJavaScript = generateEventHandlingJavaScript;
exports.generateExternalScriptReference = generateExternalScriptReference;
// Re-export all event functions
var attributes_1 = __webpack_require__(275);
Object.defineProperty(exports, "generateReactionAttributes", ({ enumerable: true, get: function () { return attributes_1.generateReactionAttributes; } }));
Object.defineProperty(exports, "generateVariantAttributes", ({ enumerable: true, get: function () { return attributes_1.generateVariantAttributes; } }));
var variant_handler_1 = __webpack_require__(120);
Object.defineProperty(exports, "createVariantSwitchingHandler", ({ enumerable: true, get: function () { return variant_handler_1.createVariantSwitchingHandler; } }));
var reaction_handler_1 = __webpack_require__(332);
Object.defineProperty(exports, "createReactionHandler", ({ enumerable: true, get: function () { return reaction_handler_1.createReactionHandler; } }));
Object.defineProperty(exports, "createTimeoutHandler", ({ enumerable: true, get: function () { return reaction_handler_1.createTimeoutHandler; } }));
var property_detector_1 = __webpack_require__(82);
Object.defineProperty(exports, "createPropertyDetector", ({ enumerable: true, get: function () { return property_detector_1.createPropertyDetector; } }));
// export { createSmartAnimateHandler } from './transition-handler';
var modular_transition_handler_1 = __webpack_require__(821);
Object.defineProperty(exports, "createModularSmartAnimateHandler", ({ enumerable: true, get: function () { return modular_transition_handler_1.createModularSmartAnimateHandler; } }));
var initializer_1 = __webpack_require__(44);
Object.defineProperty(exports, "createComponentSetInitializer", ({ enumerable: true, get: function () { return initializer_1.createComponentSetInitializer; } }));
var reaction_handler_2 = __webpack_require__(332);
// Main event handling JavaScript generator
function generateEventHandlingJavaScript() {
    return "\n    // Reference the external refactored-system.js file\n    // This file contains all the animation and event handling logic\n    console.log('DEBUG: Event handling JavaScript loaded');\n    \n    // Global function for testing event handlers\n    window.handleFigmaEvent = function(eventType, elementId) {\n      console.log('DEBUG: Manual event trigger:', eventType, elementId);\n      const element = document.querySelector(`[data-figma-id=\"${elementId}\"]`);\n      if (element) {\n        if (eventType === 'click') {\n          element.click();\n        } else if (eventType === 'variant-switch') {\n          const variantButton = element.querySelector('[data-variant], [data-variant-property-1]');\n          if (variantButton) {\n            variantButton.click();\n          }\n        }\n      }\n    };\n    \n    // Global timer tracking\n    const activeTimers = new Map();\n    \n    // CRITICAL FIX: Add click event handlers for reaction elements\n    ".concat((0, reaction_handler_2.createReactionHandler)(), "\n    \n    // Function to start timeout reactions for nested components within a parent element\n    function startTimeoutReactionsForNestedComponents(parentElement) {\n      if (!parentElement) return;\n      \n      // Find all nested components with timeout reactions within the parent\n      const nestedComponents = parentElement.querySelectorAll('[data-has-reactions=\"true\"]');\n      \n      nestedComponents.forEach(element => {\n        const elementId = element.getAttribute('data-figma-id');\n        const elementName = element.getAttribute('data-figma-name');\n        const computedStyle = window.getComputedStyle(element);\n        \n        // Only start timers for elements that are actually visible\n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n          \n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId);\n              const actionType = element.getAttribute('data-reaction-action-type');\n              const destinationId = element.getAttribute('data-reaction-destination');\n              const transitionType = element.getAttribute('data-reaction-transition-type');\n              const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n              \n              if (window.handleReaction) {\n                window.handleReaction(element, destinationId, transitionType, transitionDuration);\n              } else {\n                console.error('DEBUG: handleReaction function not found in external script');\n              }\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n          } else if (activeTimers.has(elementId)) {\n            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');\n          }\n        } else {\n          console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');\n        }\n      });\n    }\n    \n    // Function to start timeout reactions for a specific newly active variant\n    function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {\n      if (!newlyActiveElement) return;\n      \n      const elementId = newlyActiveElement.getAttribute('data-figma-id');\n      const elementName = newlyActiveElement.getAttribute('data-figma-name');\n      const parentComponent = newlyActiveElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n      const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n      \n      console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);\n      \n      // Only start timers for variants that are actually visible (not hidden by CSS)\n      const computedStyle = window.getComputedStyle(newlyActiveElement);\n      \n      if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n        const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');\n        const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');\n        const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');\n        const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');\n        const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');\n        \n        // Handle timeout reactions only for active variants that don't have an active timer\n        if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n          console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n          const timeoutId = setTimeout(() => {\n            activeTimers.delete(elementId); // Clear the timer when it completes\n            if (window.handleReaction) {\n              window.handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);\n            } else {\n              console.error('DEBUG: handleReaction function not found in external script');\n            }\n          }, (trigger.timeout || 0) * 1000);\n          activeTimers.set(elementId, timeoutId);\n        } else if (activeTimers.has(elementId)) {\n          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');\n        }\n        \n        // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant\n        startTimeoutReactionsForNestedComponents(newlyActiveElement);\n      } else {\n        console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n      }\n    }\n    \n    // Function to start timeout reactions for the initial visible variant\n    function startTimeoutReactionsForInitialVariant() {\n      // Find the first visible variant that should start the flow\n      const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"]');\n      console.log('DEBUG: Found', componentSets.length, 'component sets');\n      \n      // Also check for any elements with reactions\n      const allReactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n      console.log('DEBUG: Found', allReactionElements.length, 'total elements with reactions');\n      \n      // Log details about reaction elements\n      allReactionElements.forEach((element, index) => {\n        const elementId = element.getAttribute('data-figma-id');\n        const elementName = element.getAttribute('data-figma-name');\n        const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n        const computedStyle = window.getComputedStyle(element);\n        \n        console.log('DEBUG: Reaction element', index + 1, ':', {\n          id: elementId,\n          name: elementName,\n          trigger: trigger,\n          display: computedStyle.display,\n          visibility: computedStyle.visibility,\n          isActive: element.classList.contains('variant-active'),\n          isHidden: element.classList.contains('variant-hidden')\n        });\n      });\n      \n      componentSets.forEach(componentSet => {\n        const componentSetName = componentSet.getAttribute('data-figma-name');\n        const activeVariants = componentSet.querySelectorAll('.variant-active[data-has-reactions=\"true\"]');\n        console.log('DEBUG: Component set', componentSetName, 'has', activeVariants.length, 'active variants with reactions');\n        \n        // Only start timers for the first active variant in each component set\n        if (activeVariants.length > 0) {\n          const firstActiveVariant = activeVariants[0];\n          const elementId = firstActiveVariant.getAttribute('data-figma-id');\n          const elementName = firstActiveVariant.getAttribute('data-figma-name');\n          const computedStyle = window.getComputedStyle(firstActiveVariant);\n          \n          console.log('DEBUG: Processing initial variant:', elementId, 'name:', elementName, 'in component set:', componentSetName);\n          \n          // Only start timer if the variant is actually visible\n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(firstActiveVariant.getAttribute('data-reaction-trigger') || '{}');\n            \n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting initial timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);\n              \n              const timeoutId = setTimeout(() => {\n                console.log('DEBUG: Timeout triggered for element:', elementId, 'name:', elementName);\n                activeTimers.delete(elementId);\n                const actionType = firstActiveVariant.getAttribute('data-reaction-action-type');\n                const destinationId = firstActiveVariant.getAttribute('data-reaction-destination');\n                const transitionType = firstActiveVariant.getAttribute('data-reaction-transition-type');\n                const transitionDuration = firstActiveVariant.getAttribute('data-reaction-transition-duration');\n                \n                console.log('DEBUG: Calling handleReaction with:', {\n                  destinationId: destinationId,\n                  transitionType: transitionType,\n                  transitionDuration: transitionDuration\n                });\n                \n                // Call the handleReaction function from the external refactored-system.js\n                if (window.handleReaction) {\n                  window.handleReaction(firstActiveVariant, destinationId, transitionType, transitionDuration);\n                } else {\n                  console.error('DEBUG: handleReaction function not found in external script');\n                }\n              }, (trigger.timeout || 0) * 1000);\n              \n              activeTimers.set(elementId, timeoutId);\n              console.log('DEBUG: Created timeout timer for element:', elementId, 'timeout ID:', timeoutId, 'duration:', (trigger.timeout || 0) * 1000, 'ms');\n            } else {\n              console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n            }\n            \n            // CRITICAL FIX: Also start timeout reactions for any nested components within this initial variant\n            startTimeoutReactionsForNestedComponents(firstActiveVariant);\n          } else {\n            console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n          }\n        }\n      });\n      \n      // Also check for any non-variant elements with reactions\n      const nonVariantReactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]:not([data-figma-type=\"COMPONENT\"])');\n      nonVariantReactionElements.forEach(element => {\n        const elementId = element.getAttribute('data-figma-id');\n        const elementName = element.getAttribute('data-figma-name');\n        const computedStyle = window.getComputedStyle(element);\n        \n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n          \n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for initial non-variant element:', elementId, 'name:', elementName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId);\n              const actionType = element.getAttribute('data-reaction-action-type');\n              const destinationId = element.getAttribute('data-reaction-destination');\n              const transitionType = element.getAttribute('data-reaction-transition-type');\n              const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n              \n              if (window.handleReaction) {\n                window.handleReaction(element, destinationId, transitionType, transitionDuration);\n              } else {\n                console.error('DEBUG: handleReaction function not found in external script');\n              }\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n            \n            // CRITICAL FIX: Also start timeout reactions for any nested components within this element\n            startTimeoutReactionsForNestedComponents(element);\n          } else {\n            console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n          }\n        } else {\n          console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- not visible');\n        }\n      });\n    }\n    \n    document.addEventListener('DOMContentLoaded', function() {\n      console.log('DEBUG: DOMContentLoaded event fired');\n      console.log('DEBUG: Using external refactored-system.js file');\n      console.log('DEBUG: Starting component set initialization...');\n      \n      // Initialize component sets\n      const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"]');\n      console.log('DEBUG: Found', componentSets.length, 'component sets');\n      console.log('DEBUG: Component sets found:', Array.from(componentSets).map(cs => cs.getAttribute('data-figma-name')));\n      \n      componentSets.forEach(componentSet => {\n        const componentSetId = componentSet.getAttribute('data-figma-id');\n        const componentSetName = componentSet.getAttribute('data-figma-name');\n        const componentSetType = componentSet.getAttribute('data-figma-type');\n        const parentType = componentSet.parentElement ? componentSet.parentElement.getAttribute('data-figma-type') : 'NONE';\n        const parentId = componentSet.parentElement ? componentSet.parentElement.getAttribute('data-figma-id') : 'NONE';\n        \n        console.log('Initializing component set/instance with', componentSet.children.length, 'variants:', {\n          componentSetId: componentSetId,\n          componentSetName: componentSetName,\n          componentSetType: componentSetType,\n          parentType: parentType,\n          parentId: parentId\n        });\n        \n        // Get all variants (COMPONENT elements)\n        const variants = Array.from(componentSet.children).filter(child => \n          child.getAttribute('data-figma-type') === 'COMPONENT'\n        );\n        \n        if (variants.length > 0) {\n          // Set first variant as active\n          const firstVariant = variants[0];\n          const firstVariantId = firstVariant.getAttribute('data-figma-id');\n          console.log('Set first variant as active (with reactions):', firstVariantId, 'in component set:', componentSetId);\n          firstVariant.classList.add('variant-active');\n          firstVariant.classList.remove('variant-hidden');\n          \n          // Hide all other variants\n          variants.slice(1).forEach(variant => {\n            const variantId = variant.getAttribute('data-figma-id');\n            console.log('Set variant as hidden:', variantId, 'in component set:', componentSetId);\n            variant.classList.add('variant-hidden');\n            variant.classList.remove('variant-active');\n          });\n        }\n      });\n      \n      // Start timeout reactions after a short delay\n      setTimeout(() => {\n        console.log('DEBUG: Starting initial timeout reactions');\n        startTimeoutReactionsForInitialVariant();\n      }, 100);\n    });\n  ");
}
// Generate script tag that references the external file
function generateExternalScriptReference() {
    return "<script src=\"refactored-system.js?v=".concat(Date.now(), "\"></script>");
}


/***/ }),

/***/ 275:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateReactionAttributes = generateReactionAttributes;
exports.generateVariantAttributes = generateVariantAttributes;
var utils_1 = __webpack_require__(489);
// Event attribute generation
function generateReactionAttributes(node) {
    var attributes = {};
    if ((0, utils_1.safeHasProperty)(node, 'reactions') && node.reactions && node.reactions.length > 0) {
        var reactions = node.reactions;
        var firstReaction = reactions[0];
        if (firstReaction) {
            attributes['data-has-reactions'] = 'true';
            attributes['data-reaction-count'] = String(reactions.length);
            if (firstReaction.trigger) {
                attributes['data-reaction-trigger'] = (0, utils_1.escapeHtmlAttribute)(JSON.stringify(firstReaction.trigger));
            }
            // Check both action and actions fields
            var actionToUse = null;
            if (firstReaction.action) {
                actionToUse = firstReaction.action;
            }
            else if (firstReaction.actions && firstReaction.actions.length > 0) {
                actionToUse = firstReaction.actions[0];
            }
            if (actionToUse && actionToUse.type) {
                attributes['data-reaction-action-type'] = actionToUse.type;
                if (actionToUse.destinationId) {
                    attributes['data-reaction-destination'] = actionToUse.destinationId;
                }
                // Extract transition data from the action
                if (actionToUse.transition && actionToUse.transition.type) {
                    // Use the easing type from the transition if available, otherwise use the transition type
                    var transitionType = actionToUse.transition.type;
                    if (actionToUse.transition.easing && actionToUse.transition.easing.type) {
                        var easingType = actionToUse.transition.easing.type;
                        // Preserve the original easing type instead of mapping to BOUNCY
                        transitionType = easingType;
                    }
                    attributes['data-reaction-transition-type'] = transitionType;
                    if (actionToUse.transition.duration) {
                        attributes['data-reaction-transition-duration'] = String(actionToUse.transition.duration);
                    }
                }
                else if (actionToUse.transition === null) {
                    // Handle instant transitions (no animation)
                    attributes['data-reaction-transition-type'] = 'INSTANT';
                    attributes['data-reaction-transition-duration'] = '0';
                }
            }
        }
    }
    return attributes;
}
function generateVariantAttributes(node, parentNode) {
    var attributes = {};
    if ((0, utils_1.safeHasProperty)(node, 'variantProperties') && node.variantProperties) {
        var variantProps = node.variantProperties;
        Object.entries(variantProps).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            var cleanKey = key.toLowerCase().replace(/\s+/g, '-');
            attributes["data-variant-".concat(cleanKey)] = (0, utils_1.escapeHtmlAttribute)((0, utils_1.safeToString)(value));
        });
        // Add data-target attribute to point to the immediate parent component set
        // This allows variant buttons to know which component set to target for switching
        // For nested components, this will point to their immediate parent, not the top-level
        if (parentNode && (parentNode.type === 'COMPONENT_SET' || parentNode.type === 'COMPONENT')) {
            attributes['data-target'] = parentNode.id;
        }
    }
    return attributes;
}


/***/ }),

/***/ 332:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReactionHandler = createReactionHandler;
exports.createTimeoutHandler = createTimeoutHandler;
// Reaction handling and timeout management
function createReactionHandler() {
    return "\n      // Handle reactions - click, press, and drag\n      const reactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n      reactionElements.forEach(element => {\n        const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n        const actionType = element.getAttribute('data-reaction-action-type');\n        const destinationId = element.getAttribute('data-reaction-destination');\n        const transitionType = element.getAttribute('data-reaction-transition-type');\n        const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n        \n        // Handle click, press, and drag reactions\n        element.addEventListener('click', function() {\n          console.log('DEBUG: Click event triggered on element:', {\n            id: this.getAttribute('data-figma-id'),\n            name: this.getAttribute('data-figma-name'),\n            type: this.getAttribute('data-figma-type'),\n            trigger: trigger,\n            actionType: actionType,\n            destinationId: destinationId,\n            transitionType: transitionType,\n            transitionDuration: transitionDuration\n          });\n          \n          if (trigger.type === 'ON_CLICK' || trigger.type === 'ON_PRESS') {\n            console.log('DEBUG: Processing click reaction for element:', this.getAttribute('data-figma-id'));\n            handleReaction(this, destinationId, transitionType, transitionDuration);\n          }\n        });\n        \n        // Handle drag reactions\n        element.addEventListener('mousedown', function() {\n          if (trigger.type === 'ON_DRAG') {\n            handleReaction(this, destinationId, transitionType, transitionDuration);\n          }\n        });\n      });\n  ";
}
function createTimeoutHandler() {
    return "\n      // Track which variants have active timers (for preventing duplicate timers during the same activation)\n      const activeTimers = new Map(); // elementId -> timeoutId\n      \n      // Function to start timeout reactions for active variants\n      function startTimeoutReactionsForActiveVariants() {\n        // Look for both variant-active elements with reactions AND any elements with reactions that don't have variant properties\n        const activeVariants = document.querySelectorAll('.variant-active[data-has-reactions=\"true\"]');\n        const reactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n        \n        console.log('DEBUG: Found', activeVariants.length, 'active variants with reactions');\n        console.log('DEBUG: Found', reactionElements.length, 'total elements with reactions');\n        \n        // Process active variants first\n        activeVariants.forEach(element => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          const parentComponent = element.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n          \n          console.log('DEBUG: Processing variant:', elementId, 'name:', elementName, 'parent:', parentName);\n          \n          // Only start timers for variants that are actually visible (not hidden by CSS)\n          const computedStyle = window.getComputedStyle(element);\n          \n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n            const actionType = element.getAttribute('data-reaction-action-type');\n            const destinationId = element.getAttribute('data-reaction-destination');\n            const transitionType = element.getAttribute('data-reaction-transition-type');\n            const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n            \n            // Handle timeout reactions only for active variants that don't have an active timer\n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId); // Clear the timer when it completes\n                handleReaction(element, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n          }\n        });\n        \n        // Also process any reaction elements that don't have variant properties (like 6461:693)\n        reactionElements.forEach(element => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          \n          // Skip if this element was already processed as a variant\n          if (element.classList.contains('variant-active')) {\n            return;\n          }\n          \n          // Skip if this element has variant properties (it will be handled by variant logic)\n          if (element.hasAttribute('data-variant-property-1')) {\n            return;\n          }\n          \n          const parentComponent = element.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n          \n          console.log('DEBUG: Processing non-variant reaction element:', elementId, 'name:', elementName, 'parent:', parentName);\n          \n          // Only start timers for elements that are actually visible (not hidden by CSS)\n          const computedStyle = window.getComputedStyle(element);\n          \n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n            const actionType = element.getAttribute('data-reaction-action-type');\n            const destinationId = element.getAttribute('data-reaction-destination');\n            const transitionType = element.getAttribute('data-reaction-transition-type');\n            const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n            \n            // Handle timeout reactions only for elements that don't have an active timer\n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId); // Clear the timer when it completes\n                handleReaction(element, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n          }\n        });\n      }\n      \n      // Function to start timeout reactions for nested components when their parent becomes visible\n      function startTimeoutReactionsForNestedComponents(parentElement) {\n        if (!parentElement) return;\n        \n        // Find all nested components with timeout reactions within the parent\n        const nestedComponents = parentElement.querySelectorAll('[data-has-reactions=\"true\"][data-reaction-trigger*=\"AFTER_TIMEOUT\"]');\n        \n        nestedComponents.forEach(component => {\n          const elementId = component.getAttribute('data-figma-id');\n          const elementName = component.getAttribute('data-figma-name');\n          const parentComponent = component.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n          \n          console.log('DEBUG: Processing nested component:', elementId, 'name:', elementName, 'parent:', parentName);\n          \n          // Only start timers for nested components that are actually visible\n          const computedStyle = window.getComputedStyle(component);\n          \n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(component.getAttribute('data-reaction-trigger') || '{}');\n            \n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId);\n                const actionType = component.getAttribute('data-reaction-action-type');\n                const destinationId = component.getAttribute('data-reaction-destination');\n                const transitionType = component.getAttribute('data-reaction-transition-type');\n                const transitionDuration = component.getAttribute('data-reaction-transition-duration');\n                handleReaction(component, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');\n          }\n        });\n      }\n      \n      // Function to start timeout reactions for a specific newly active variant\n      function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {\n        if (!newlyActiveElement) return;\n        \n        const elementId = newlyActiveElement.getAttribute('data-figma-id');\n        const elementName = newlyActiveElement.getAttribute('data-figma-name');\n        const parentComponent = newlyActiveElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n        const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n        \n        console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);\n        \n        // Only start timers for variants that are actually visible (not hidden by CSS)\n        const computedStyle = window.getComputedStyle(newlyActiveElement);\n        \n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');\n          const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');\n          const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');\n          const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');\n          const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');\n          \n          // Handle timeout reactions only for active variants that don't have an active timer\n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId); // Clear the timer when it completes\n              handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n          } else if (activeTimers.has(elementId)) {\n            console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');\n          }\n          \n          // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant\n          startTimeoutReactionsForNestedComponents(newlyActiveElement);\n        } else {\n          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n        }\n      }\n      \n      // CRITICAL FIX: Only start timeout reactions for the initial visible variant\n      // Instead of starting timers for all variant-active elements immediately,\n      // we wait for the first variant transition or user interaction\n      function startTimeoutReactionsForInitialVariant() {\n        // Find the first visible variant that should start the flow\n        // This is typically the first variant in a component set that's marked as active\n        const componentSets = document.querySelectorAll('[data-figma-type=\"COMPONENT_SET\"]');\n        console.log('DEBUG: Found', componentSets.length, 'component sets');\n        \n        // Also check for any elements with reactions\n        const allReactionElements = document.querySelectorAll('[data-has-reactions=\"true\"]');\n        console.log('DEBUG: Found', allReactionElements.length, 'total elements with reactions');\n        \n        // Log details about reaction elements\n        allReactionElements.forEach((element, index) => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n          const computedStyle = window.getComputedStyle(element);\n          \n          console.log('DEBUG: Reaction element', index + 1, ':', {\n            id: elementId,\n            name: elementName,\n            trigger: trigger,\n            display: computedStyle.display,\n            visibility: computedStyle.visibility,\n            isActive: element.classList.contains('variant-active'),\n            isHidden: element.classList.contains('variant-hidden')\n          });\n        });\n        \n        componentSets.forEach(componentSet => {\n          const componentSetName = componentSet.getAttribute('data-figma-name');\n          const activeVariants = componentSet.querySelectorAll('.variant-active[data-has-reactions=\"true\"]');\n          console.log('DEBUG: Component set', componentSetName, 'has', activeVariants.length, 'active variants with reactions');\n          \n          // Only start timers for the first active variant in each component set\n          if (activeVariants.length > 0) {\n            const firstActiveVariant = activeVariants[0];\n            const elementId = firstActiveVariant.getAttribute('data-figma-id');\n            const elementName = firstActiveVariant.getAttribute('data-figma-name');\n            const computedStyle = window.getComputedStyle(firstActiveVariant);\n            \n            console.log('DEBUG: Processing initial variant:', elementId, 'name:', elementName, 'in component set:', componentSetName);\n            \n            // Only start timer if the variant is actually visible\n            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n              const trigger = JSON.parse(firstActiveVariant.getAttribute('data-reaction-trigger') || '{}');\n              \n              // Skip nested components that should only start when their parent becomes visible\n              // Allow independent components to start their timers on page load\n              // Check if this component set is nested within another component set\n              const parentComponentSet = componentSet.closest('[data-figma-type=\"COMPONENT_SET\"]');\n              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;\n              \n              if (isNestedComponent) {\n                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');\n                return;\n              }\n              \n              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n                console.log('DEBUG: Starting initial timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);\n                const timeoutId = setTimeout(() => {\n                  console.log('DEBUG: Timeout triggered for element:', elementId, 'name:', elementName);\n                  activeTimers.delete(elementId);\n                  const actionType = firstActiveVariant.getAttribute('data-reaction-action-type');\n                  const destinationId = firstActiveVariant.getAttribute('data-reaction-destination');\n                  const transitionType = firstActiveVariant.getAttribute('data-reaction-transition-type');\n                  const transitionDuration = firstActiveVariant.getAttribute('data-reaction-transition-duration');\n                  console.log('DEBUG: Calling handleReaction with:', {\n                    destinationId: destinationId,\n                    transitionType: transitionType,\n                    transitionDuration: transitionDuration\n                  });\n                  handleReaction(firstActiveVariant, destinationId, transitionType, transitionDuration);\n                }, (trigger.timeout || 0) * 1000);\n                activeTimers.set(elementId, timeoutId);\n                console.log('DEBUG: Created timeout timer for element:', elementId, 'timeout ID:', timeoutId, 'duration:', (trigger.timeout || 0) * 1000, 'ms');\n                \n                // CRITICAL FIX: Also start timeout reactions for any nested components within this initial variant\n                startTimeoutReactionsForNestedComponents(firstActiveVariant);\n              } else {\n                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n              }\n            } else {\n              console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n            }\n          }\n          \n          // CRITICAL FIX: Also check for non-variant reaction elements in this component set\n          const reactionElements = componentSet.querySelectorAll('[data-has-reactions=\"true\"]');\n          reactionElements.forEach(element => {\n            const elementId = element.getAttribute('data-figma-id');\n            const elementName = element.getAttribute('data-figma-name');\n            \n            // Skip if this element was already processed as a variant\n            if (element.classList.contains('variant-active')) {\n              return;\n            }\n            \n            // Skip if this element has variant properties (it will be handled by variant logic)\n            if (element.hasAttribute('data-variant-property-1')) {\n              return;\n            }\n            \n            const computedStyle = window.getComputedStyle(element);\n            \n            console.log('DEBUG: Processing initial non-variant reaction element:', elementId, 'name:', elementName, 'in component set:', componentSetName);\n            \n            // Only start timer if the element is actually visible\n            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n              const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n              \n              // Skip nested components that should only start when their parent becomes visible\n              const parentComponentSet = componentSet.closest('[data-figma-type=\"COMPONENT_SET\"]');\n              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;\n              \n              if (isNestedComponent) {\n                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');\n                return;\n              }\n              \n              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n                console.log('DEBUG: Starting initial timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);\n                const timeoutId = setTimeout(() => {\n                  activeTimers.delete(elementId);\n                  const actionType = element.getAttribute('data-reaction-action-type');\n                  const destinationId = element.getAttribute('data-reaction-destination');\n                  const transitionType = element.getAttribute('data-reaction-transition-type');\n                  const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n                  handleReaction(element, destinationId, transitionType, transitionDuration);\n                }, (trigger.timeout || 0) * 1000);\n                activeTimers.set(elementId, timeoutId);\n                \n                // Also start timeout reactions for any nested components within this element\n                startTimeoutReactionsForNestedComponents(element);\n              } else {\n                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- no timeout trigger or timer already active');\n              }\n            } else {\n              console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n            }\n          });\n        });\n      }\n      \n      // Start timeout reactions for the initial visible variant after a short delay\n      // to ensure CSS classes and visibility are properly applied\n      console.log('DEBUG: Setting up initial timeout reactions');\n      setTimeout(() => {\n        console.log('DEBUG: Starting initial timeout reactions');\n        startTimeoutReactionsForInitialVariant();\n      }, 100);\n  ";
}


/***/ }),

/***/ 489:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.safeHasProperty = safeHasProperty;
exports.safeToString = safeToString;
exports.safeAttributeValue = safeAttributeValue;
exports.escapeHtmlAttribute = escapeHtmlAttribute;
// Utility functions for HTML generation
function safeHasProperty(obj, prop) {
    return obj && typeof obj === 'object' && prop in obj;
}
function safeToString(value) {
    if (value === null || value === undefined)
        return '';
    if (typeof value === 'symbol')
        return value.toString();
    return String(value);
}
// Helper function to safely convert any value to string for HTML attributes, handling symbols
function safeAttributeValue(value) {
    if (value === null || value === undefined)
        return '';
    if (typeof value === 'symbol')
        return value.toString();
    return String(value);
}
function escapeHtmlAttribute(value) {
    return value
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}


/***/ }),

/***/ 821:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createModularSmartAnimateHandler = createModularSmartAnimateHandler;
/**
 * Creates a modular smart animate handler that uses the new animation system
 */
function createModularSmartAnimateHandler() {
    return "\n      // Global transition lock to prevent multiple simultaneous transitions\n      let isTransitionInProgress = false;\n      let currentTransitionPromise = null;\n      \n      // Animation types\n      const AnimationType = {\n        SIMPLE: 'SIMPLE',\n        SIZE: 'SIZE', \n        TRANSFORM: 'TRANSFORM'\n      };\n      \n      // Translation conditions\n      const TranslationCondition = {\n        ABSOLUTE: 'ABSOLUTE',\n        RELATIVE_PADDING: 'RELATIVE_PADDING',\n        RELATIVE_ALIGNMENT: 'RELATIVE_ALIGNMENT'\n      };\n      \n      // Helper function to determine animation type for a property\n      function getAnimationType(property) {\n        const simpleProperties = [\n          'opacity', 'color', 'backgroundColor', 'cornerRadius', 'borderRadius',\n          'fontSize', 'fontWeight', 'textAlign', 'letterSpacing', 'lineHeight'\n        ];\n        \n        const sizeProperties = [\n          'width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'\n        ];\n        \n        const transformProperties = [\n          'translateX', 'translateY', 'translateZ', 'rotation', 'scale', 'transform'\n        ];\n        \n        if (simpleProperties.includes(property)) {\n          return AnimationType.SIMPLE;\n        } else if (sizeProperties.includes(property)) {\n          return AnimationType.SIZE;\n        } else if (transformProperties.includes(property)) {\n          return AnimationType.TRANSFORM;\n        }\n        \n        return AnimationType.SIMPLE;\n      }\n      \n      // Helper function to determine translation condition\n      function getTranslationCondition(element, node, parentNode) {\n        const ignoreAutoLayout = node.layoutPositioning === 'ABSOLUTE';\n        \n        const parentHasAutoLayout = parentNode && \n                                   parentNode.type === 'FRAME' && \n                                   parentNode.layoutMode && \n                                   parentNode.layoutMode !== 'NONE';\n        \n        if (ignoreAutoLayout || !parentHasAutoLayout) {\n          return TranslationCondition.ABSOLUTE;\n        }\n        \n        if (parentHasAutoLayout) {\n          // For now, default to padding-based relative positioning\n          // This could be enhanced to detect which type of relative positioning is needed\n          return TranslationCondition.RELATIVE_PADDING;\n        }\n        \n        return TranslationCondition.ABSOLUTE;\n      }\n      \n      // Helper function to detect animation changes\n      function detectAnimationChanges(sourceElement, targetElement, sourceNode, targetNode, parentNode) {\n        const changes = [];\n        \n        let sourceStyle = window.getComputedStyle(sourceElement);\n        let targetStyle = window.getComputedStyle(targetElement);\n        \n        // Check simple properties\n        const simpleProperties = ['opacity', 'backgroundColor', 'color'];\n        simpleProperties.forEach(property => {\n          const sourceValue = sourceStyle[property];\n          const targetValue = targetStyle[property];\n          \n          if (sourceValue !== targetValue) {\n            changes.push({\n              type: AnimationType.SIMPLE,\n              property,\n              sourceValue,\n              targetValue,\n              changed: true\n            });\n          }\n        });\n        \n        // Check size properties\n        const sizeProperties = ['width', 'height'];\n        sizeProperties.forEach(property => {\n          const sourceValue = parseFloat(sourceStyle[property]) || 0;\n          const targetValue = parseFloat(targetStyle[property]) || 0;\n          \n          if (Math.abs(sourceValue - targetValue) > 1) {\n            changes.push({\n              type: AnimationType.SIZE,\n              property,\n              sourceValue,\n              targetValue,\n              changed: true\n            });\n          }\n        });\n        \n        // Check transform properties based on translation condition\n        const translationCondition = getTranslationCondition(sourceElement, sourceNode, parentNode);\n        \n        console.log('DEBUG: Translation condition detected:', translationCondition);\n        \n        if (translationCondition === TranslationCondition.ABSOLUTE) {\n          // Check left/top changes for absolute positioning\n          const sourceLeft = parseFloat(sourceStyle.left) || 0;\n          const targetLeft = parseFloat(targetStyle.left) || 0;\n          const sourceTop = parseFloat(sourceStyle.top) || 0;\n          const targetTop = parseFloat(targetStyle.top) || 0;\n          \n          if (Math.abs(sourceLeft - targetLeft) > 1) {\n            changes.push({\n              type: AnimationType.TRANSFORM,\n              property: 'translateX',\n              sourceValue: sourceLeft,\n              targetValue: targetLeft,\n              changed: true,\n              translationCondition\n            });\n          }\n          \n          if (Math.abs(sourceTop - targetTop) > 1) {\n            changes.push({\n              type: AnimationType.TRANSFORM,\n              property: 'translateY',\n              sourceValue: sourceTop,\n              targetValue: targetTop,\n              changed: true,\n              translationCondition\n            });\n          }\n        } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n          // Check parent padding changes\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          \n          if (sourceParent && targetParent) {\n            const sourceParentStylePadding = window.getComputedStyle(sourceParent);\n            const targetParentStylePadding = window.getComputedStyle(targetParent);\n            \n            const paddingProperties = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'];\n            paddingProperties.forEach(property => {\n              const sourceValue = parseFloat(sourceParentStylePadding[property]) || 0;\n              const targetValue = parseFloat(targetParentStylePadding[property]) || 0;\n              \n              if (Math.abs(sourceValue - targetValue) > 1) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: `parent_${property}`,\n                  sourceValue,\n                  targetValue,\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n          }\n        } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n          // Check parent alignment changes - ENHANCED FOR JUSTIFYCONTENT\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          \n          if (sourceParent && targetParent) {\n            const sourceParentStyleAlignment = window.getComputedStyle(sourceParent);\n            const targetParentStyleAlignment = window.getComputedStyle(targetParent);\n            \n            // Check alignment properties with detailed logging\n            const alignmentProperties = ['justifyContent', 'alignItems', 'textAlign', 'verticalAlign'];\n            \n            console.log('DEBUG: Checking alignment properties for RELATIVE_ALIGNMENT');\n            \n            alignmentProperties.forEach(property => {\n              const sourceValue = sourceParentStyleAlignment[property];\n              const targetValue = targetParentStyleAlignment[property];\n              \n              console.log(`DEBUG: Parent ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });\n              \n              if (sourceValue !== targetValue) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: `parent_${property}`,\n                  sourceValue: sourceValue || '',\n                  targetValue: targetValue || '',\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n            \n            // Check element's own alignment properties\n            alignmentProperties.forEach(property => {\n              const sourceValue = sourceStyle[property];\n              const targetValue = targetStyle[property];\n              \n              console.log(`DEBUG: Element ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });\n              \n              if (sourceValue !== targetValue) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: property,\n                  sourceValue: sourceValue || '',\n                  targetValue: targetValue || '',\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n            \n            // Check for flexbox-specific properties\n            const flexProperties = ['flexDirection', 'flexWrap', 'alignContent', 'justifyItems'];\n            flexProperties.forEach(property => {\n              const sourceValue = sourceParentStyleAlignment[property];\n              const targetValue = targetParentStyleAlignment[property];\n              \n              console.log(`DEBUG: Flex ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });\n              \n              if (sourceValue !== targetValue) {\n                changes.push({\n                  type: AnimationType.TRANSFORM,\n                  property: `parent_${property}`,\n                  sourceValue: sourceValue || '',\n                  targetValue: targetValue || '',\n                  changed: true,\n                  translationCondition\n                });\n              }\n            });\n            \n            // Check for position changes that might be due to alignment\n            // Even if alignment values are the same, the computed position might differ\n            const sourceRect = sourceElement.getBoundingClientRect();\n            const targetRect = targetElement.getBoundingClientRect();\n            const sourceParentRect = sourceParent.getBoundingClientRect();\n            const targetParentRect = targetParent.getBoundingClientRect();\n            \n            // Calculate relative positions within their containers\n            // For nested instances with responsive parents, use percentage-based positioning\n            // But first, check if we should use the actual rendered position instead of Figma coordinates\n            let sourceRelativeX, targetRelativeX, sourceRelativeY, targetRelativeY;\n            \n            // Check if the target element has a different alignment that would affect positioning\n            const sourceParentStylePosition = window.getComputedStyle(sourceParent);\n            const targetParentStylePosition = window.getComputedStyle(targetParent);\n            const sourceStyle = window.getComputedStyle(sourceElement);\n            const targetStyle = window.getComputedStyle(targetElement);\n            \n            // If there's an alignment difference, calculate the actual rendered position\n            if (sourceParentStylePosition.justifyContent !== targetParentStylePosition.justifyContent ||\n                sourceParentStylePosition.alignItems !== targetParentStylePosition.alignItems ||\n                sourceStyle.justifyContent !== targetStyle.justifyContent ||\n                sourceStyle.alignItems !== targetStyle.alignItems) {\n              \n              // Use the actual rendered positions\n              sourceRelativeX = (sourceRect.left - sourceParentRect.left) / sourceParentRect.width * 100;\n              targetRelativeX = (targetRect.left - targetParentRect.left) / targetParentRect.width * 100;\n              sourceRelativeY = (sourceRect.top - sourceParentRect.top) / sourceParentRect.height * 100;\n              targetRelativeY = (targetRect.top - targetParentRect.top) / targetParentRect.height * 100;\n              \n              console.log('DEBUG: Using actual rendered positions for alignment change:', {\n                sourceJustifyContent: sourceParentStylePosition.justifyContent,\n                targetJustifyContent: targetParentStylePosition.justifyContent,\n                sourceAlignItems: sourceParentStylePosition.alignItems,\n                targetAlignItems: targetParentStylePosition.alignItems,\n                sourceRelativeX,\n                targetRelativeX,\n                sourceRelativeY,\n                targetRelativeY\n              });\n            } else {\n              // Use the actual rendered positions as fallback\n              sourceRelativeX = (sourceRect.left - sourceParentRect.left) / sourceParentRect.width * 100;\n              targetRelativeX = (targetRect.left - targetParentRect.left) / targetParentRect.width * 100;\n              sourceRelativeY = (sourceRect.top - sourceParentRect.top) / sourceParentRect.height * 100;\n              targetRelativeY = (targetRect.top - targetParentRect.top) / targetParentRect.height * 100;\n            }\n            \n            console.log('DEBUG: Relative position analysis:', {\n              sourceRelativeX,\n              targetRelativeX,\n              sourceRelativeY,\n              targetRelativeY,\n              xDifference: Math.abs(sourceRelativeX - targetRelativeX),\n              yDifference: Math.abs(sourceRelativeY - targetRelativeY)\n            });\n            \n            // If there's a significant position difference, it might be due to alignment\n            // Use a smaller threshold for percentage-based positioning\n            if (Math.abs(sourceRelativeX - targetRelativeX) > 0.5) {\n              changes.push({\n                type: AnimationType.TRANSFORM,\n                property: 'alignTranslateX',\n                sourceValue: sourceRelativeX,\n                targetValue: targetRelativeX,\n                changed: true,\n                translationCondition\n              });\n            }\n            \n            if (Math.abs(sourceRelativeY - targetRelativeY) > 0.5) {\n              changes.push({\n                type: AnimationType.TRANSFORM,\n                property: 'alignTranslateY',\n                sourceValue: sourceRelativeY,\n                targetValue: targetRelativeY,\n                changed: true,\n                translationCondition\n              });\n            }\n          }\n        }\n        \n        console.log('DEBUG: Total changes detected:', changes.length, changes);\n        return changes;\n      }\n      \n      // Helper function to apply animation changes\n      function applyAnimationChange(element, change, duration, easing) {\n        const { type, property, targetValue, translationCondition, destination } = change;\n        \n        console.log('DEBUG: Applying animation change:', { type, property, targetValue, translationCondition });\n        \n        // Get transition property\n        let transitionProperty = property;\n        if (type === AnimationType.TRANSFORM) {\n          if (translationCondition === TranslationCondition.ABSOLUTE) {\n            transitionProperty = property === 'translateX' ? 'left' : 'top';\n          } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n            transitionProperty = property.replace('parent_', '');\n          } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n            if (property === 'alignTranslateX' || property === 'alignTranslateY') {\n              transitionProperty = property === 'alignTranslateX' ? 'left' : 'top';\n            } else if (property.startsWith('parent_')) {\n              // For alignment changes, animate the element's position instead of the parent's alignment\n              if (property === 'parent_justifyContent') {\n                // Use the target element's actual position from the destination variant\n                const sourceElementName = element.getAttribute('data-figma-name');\n                const targetElement = destination.querySelector(`[data-figma-name=\"${sourceElementName}\"]`);\n                \n                if (targetElement) {\n                  const targetRect = targetElement.getBoundingClientRect();\n                  const parent = element.parentElement;\n                  const parentRect = parent.getBoundingClientRect();\n                  \n                  // Calculate the target position relative to the parent using percentage\n                  const targetLeft = (targetRect.left - parentRect.left) / parentRect.width * 100;\n                  \n                  console.log('DEBUG: Calculating justifyContent animation using target position:', {\n                    currentLeft: (element.getBoundingClientRect().left - parentRect.left) / parentRect.width * 100,\n                    targetLeft: targetLeft,\n                    targetElementId: targetElement.getAttribute('data-figma-id'),\n                    targetElementName: sourceElementName,\n                    justifyContent: targetValue\n                  });\n                  \n                  // Set transition for left position using percentage\n                  element.style.transition = `left ${duration}s ${easing}`;\n                  element.style.left = `${targetLeft}%`;\n                  \n                  console.log('DEBUG: Applied justifyContent animation via target position:', {\n                    property: 'left',\n                    transitionProperty: 'left',\n                    targetValue: `${targetLeft}px`\n                  });\n                  \n                  return; // Skip the default handling\n                } else {\n                  console.log('DEBUG: Target element not found in destination by name:', sourceElementName);\n                }\n              } else if (property === 'parent_alignItems') {\n                // Use the target element's actual position from the destination variant\n                const sourceElementName = element.getAttribute('data-figma-name');\n                const targetElement = destination.querySelector(`[data-figma-name=\"${sourceElementName}\"]`);\n                \n                if (targetElement) {\n                  const targetRect = targetElement.getBoundingClientRect();\n                  const parent = element.parentElement;\n                  const parentRect = parent.getBoundingClientRect();\n                  \n                  // Calculate the target position relative to the parent using percentage\n                  const targetTop = (targetRect.top - parentRect.top) / parentRect.height * 100;\n                  \n                  console.log('DEBUG: Calculating alignItems animation using target position:', {\n                    currentTop: (element.getBoundingClientRect().top - parentRect.top) / parentRect.height * 100,\n                    targetTop: targetTop,\n                    targetElementId: targetElement.getAttribute('data-figma-id'),\n                    targetElementName: sourceElementName,\n                    alignItems: targetValue\n                  });\n                  \n                  // Set transition for top position using percentage\n                  element.style.transition = `top ${duration}s ${easing}`;\n                  element.style.top = `${targetTop}%`;\n                  \n                  console.log('DEBUG: Applied alignItems animation via target position:', {\n                    property: 'top',\n                    transitionProperty: 'top',\n                    targetValue: `${targetTop}px`\n                  });\n                  \n                  return; // Skip the default handling\n                } else {\n                  console.log('DEBUG: Target element not found in destination by name:', sourceElementName);\n                }\n              }\n              transitionProperty = property.replace('parent_', '');\n            } else {\n              transitionProperty = property;\n            }\n          }\n        }\n        \n        // Set up transition\n        element.style.transition = `${transitionProperty} ${duration}s ${easing}`;\n        \n        // Apply the change based on type and condition\n        switch (type) {\n          case AnimationType.SIMPLE:\n            element.style[property] = targetValue;\n            break;\n            \n          case AnimationType.SIZE:\n            element.style[property] = `${targetValue}px`;\n            break;\n            \n          case AnimationType.TRANSFORM:\n            if (translationCondition === TranslationCondition.ABSOLUTE) {\n              if (change.isCombinedTransform && property === 'translate') {\n                // Handle combined X and Y transform for simultaneous movement\n                const { x: translateX, y: translateY } = targetValue;\n                \n                // Use CSS transform for hardware-accelerated simultaneous animation\n                element.style.transition = `transform ${duration}s ${easing}`;\n                element.style.transform = `translate(${translateX}px, ${translateY}px)`;\n                \n                console.log('DEBUG: Applying combined transform animation:', {\n                  translateX: translateX,\n                  translateY: translateY,\n                  elementName: element.getAttribute('data-figma-name')\n                });\n              } else if (property === 'translateX') {\n                // For additive position changes, add the difference to current position\n                const currentLeft = parseFloat(element.style.left) || 0;\n                const newLeft = currentLeft + targetValue;\n                element.style.left = `${newLeft}px`;\n                \n                console.log('DEBUG: Applying additive translateX animation:', {\n                  currentLeft: currentLeft,\n                  targetValue: targetValue,\n                  newLeft: newLeft,\n                  elementName: element.getAttribute('data-figma-name')\n                });\n              } else if (property === 'translateY') {\n                // For additive position changes, add the difference to current position\n                const currentTop = parseFloat(element.style.top) || 0;\n                const newTop = currentTop + targetValue;\n                element.style.top = `${newTop}px`;\n                \n                console.log('DEBUG: Applying additive translateY animation:', {\n                  currentTop: currentTop,\n                  targetValue: targetValue,\n                  newTop: newTop,\n                  elementName: element.getAttribute('data-figma-name')\n                });\n              }\n            } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {\n              if (element.parentElement) {\n                const paddingProperty = property.replace('parent_', '');\n                element.parentElement.style[paddingProperty] = `${targetValue}px`;\n              }\n            } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {\n              if (property === 'alignTranslateX') {\n                // Use percentage-based positioning for nested instances with responsive parents\n                element.style.left = `${targetValue}%`;\n              } else if (property === 'alignTranslateY') {\n                // Use percentage-based positioning for nested instances with responsive parents\n                element.style.top = `${targetValue}%`;\n              } else if (property.startsWith('parent_')) {\n                if (element.parentElement) {\n                  const alignmentProperty = property.replace('parent_', '');\n                  element.parentElement.style[alignmentProperty] = targetValue;\n                }\n              } else {\n                // Direct property change on the element\n                element.style[property] = targetValue;\n              }\n            }\n            break;\n        }\n        \n        console.log('DEBUG: Applied change:', { property, transitionProperty, targetValue });\n      }\n      \n      // Helper function to get easing function\n      function getEasingFunction(animationType) {\n        switch (animationType) {\n          case 'EASE_IN_AND_OUT_BACK':\n            return 'cubic-bezier(0.68, -0.6, 0.32, 1.6)';\n          case 'EASE_IN_AND_OUT':\n            return 'ease-in-out';\n          case 'EASE_IN':\n            return 'ease-in';\n          case 'EASE_OUT':\n            return 'ease-out';\n          case 'LINEAR':\n            return 'linear';\n          case 'BOUNCY':\n            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';\n          case 'GENTLE':\n            return 'ease-in-out';\n          case 'SMART_ANIMATE':\n            return 'ease-in-out';\n          default:\n            return 'ease-out';\n        }\n      }\n      \n      // Helper function to create element copy\n      function createElementCopy(sourceElement) {\n        console.log('DEBUG: createElementCopy function called');\n        console.log('DEBUG: Creating element copy for:', sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id'));\n        \n        const copy = sourceElement.cloneNode(true);\n        copy.setAttribute('data-figma-id', sourceElement.getAttribute('data-figma-id') + '-copy');\n        copy.setAttribute('data-is-animation-copy', 'true');\n        \n        // Make an exact copy - don't manipulate positions\n        console.log('DEBUG: Making exact copy of source variant');\n        \n        // Get source elements for copy creation (no detailed logging)\n        const sourceElements = sourceElement.querySelectorAll('[data-figma-id]');\n        \n        // The copy is already an exact clone, no position manipulation needed\n        \n        // Position the copy absolutely over the source element\n        const sourceRect = sourceElement.getBoundingClientRect();\n        const parentRect = sourceElement.parentElement.getBoundingClientRect();\n        \n        copy.style.position = 'absolute';\n        copy.style.top = (sourceRect.top - parentRect.top) + 'px';\n        copy.style.left = (sourceRect.left - parentRect.left) + 'px';\n        copy.style.transform = 'none';\n        copy.style.margin = '0';\n        copy.style.padding = '0';\n        \n        // Set high z-index\n        const allElements = document.querySelectorAll('*');\n        let maxZIndex = 0;\n        allElements.forEach(el => {\n          const zIndex = parseInt(window.getComputedStyle(el).zIndex) || 0;\n          if (zIndex > maxZIndex) maxZIndex = zIndex;\n        });\n        \n        const copyZIndex = maxZIndex + 1000;\n        copy.style.zIndex = copyZIndex.toString();\n        copy.style.pointerEvents = 'none';\n        copy.style.transform = 'translateZ(0)';\n        copy.style.willChange = 'transform, left, top';\n        \n        // Preserve original overflow, display, and visibility from source element\n        const sourceComputedStyle = window.getComputedStyle(sourceElement);\n        copy.style.overflow = sourceComputedStyle.overflow;\n        copy.style.display = sourceComputedStyle.display;\n        copy.style.visibility = sourceComputedStyle.visibility;\n        copy.style.opacity = '1';\n\n        // Preserve original display and visibility for all nested elements, but ensure opacity is 1\n        const copyChildren = copy.querySelectorAll('*');\n        copyChildren.forEach(child => {\n          child.style.opacity = '1';\n          // Don't override display, visibility, or overflow - preserve the original values from the clone\n        });\n\n        // Ensure all nodes in the copy are visible (no detailed logging)\n        \n        console.log('DEBUG: Copy creation completed');\n        return copy;\n      }\n      \n      // Helper function to update copy content to match destination\n      function updateCopyContentToMatchDestination(copy, destination) {\n        console.log('DEBUG: Updating copy content to match destination');\n        \n        // Get all elements in both copy and destination\n        const copyElements = copy.querySelectorAll('[data-figma-id]');\n        const destinationElements = destination.querySelectorAll('[data-figma-id]');\n        \n        // Create a map of destination elements by name\n        const destinationElementMap = new Map();\n        destinationElements.forEach(element => {\n          const name = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n          if (name) {\n            destinationElementMap.set(name, element);\n          }\n        });\n        \n        // Update each copy element's content to match destination\n        copyElements.forEach(copyElement => {\n          const copyElementName = copyElement.getAttribute('data-figma-name') || copyElement.getAttribute('data-figma-id');\n          const destinationElement = destinationElementMap.get(copyElementName);\n          \n          if (destinationElement) {\n            // Update text content\n            if (destinationElement.textContent !== copyElement.textContent) {\n              copyElement.textContent = destinationElement.textContent;\n            }\n            \n            // Update innerHTML for more complex content, but preserve positioning\n            if (destinationElement.innerHTML !== copyElement.innerHTML) {\n              \n              // CRITICAL FIX: Preserve the positioning of ALL nested elements before updating content\n              const allNestedElements = copyElement.querySelectorAll('[data-figma-id]');\n              const originalPositions = new Map();\n              \n              allNestedElements.forEach(nestedElement => {\n                const nestedElementName = nestedElement.getAttribute('data-figma-name') || nestedElement.getAttribute('data-figma-id');\n                const computedStyle = window.getComputedStyle(nestedElement);\n                originalPositions.set(nestedElementName, {\n                  position: computedStyle.position,\n                  left: computedStyle.left,\n                  top: computedStyle.top,\n                  transform: computedStyle.transform\n                });\n              });\n              \n              // Also preserve the copy element itself\n              const copyComputedStyle = window.getComputedStyle(copyElement);\n              originalPositions.set(copyElementName, {\n                position: copyComputedStyle.position,\n                left: copyComputedStyle.left,\n                top: copyComputedStyle.top,\n                transform: copyComputedStyle.transform\n              });\n              \n              // Update the innerHTML\n              copyElement.innerHTML = destinationElement.innerHTML;\n              \n              // CRITICAL FIX: Restore the positioning of ALL elements after content update\n              originalPositions.forEach((positionData, elementName) => {\n                const elementToRestore = elementName === copyElementName ? \n                  copyElement : \n                  copyElement.querySelector('[data-figma-name=\"' + elementName + '\"]') ||\n                  copyElement.querySelector('[data-figma-id=\"' + elementName + '\"]');\n                \n                if (elementToRestore) {\n                  elementToRestore.style.position = positionData.position;\n                  elementToRestore.style.left = positionData.left;\n                  elementToRestore.style.top = positionData.top;\n                  elementToRestore.style.transform = positionData.transform;\n                }\n              });\n            }\n            \n            // Update specific attributes that might contain content\n            const contentAttributes = ['data-content', 'data-text', 'title', 'alt'];\n            contentAttributes.forEach(attr => {\n              const destValue = destinationElement.getAttribute(attr);\n              const copyValue = copyElement.getAttribute(attr);\n              if (destValue !== copyValue && destValue !== null) {\n                copyElement.setAttribute(attr, destValue);\n              }\n            });\n          }\n        });\n        \n        // Ensure all elements in the copy have opacity 1 after content update, but preserve display, visibility, and overflow\n        const allCopyElements = copy.querySelectorAll('*');\n        allCopyElements.forEach(element => {\n          element.style.opacity = '1';\n          // Don't override display, visibility, or overflow - preserve the original values from the clone\n        });\n      }\n      \n      // Helper function to animate copy to destination\n      function animateCopyToDestination(copy, destination, originalSourceElement, transitionType, transitionDuration) {\n        return new Promise((resolve) => {\n          // Update copy content to match destination content\n          updateCopyContentToMatchDestination(copy, destination);\n          \n          // Find elements with property changes\n          console.log('DEBUG: About to call findElementsWithPropertyChanges');\n          let elementsToAnimate = [];\n          try {\n            elementsToAnimate = findElementsWithPropertyChanges(destination, copy, originalSourceElement);\n            console.log('DEBUG: findElementsWithPropertyChanges returned:', elementsToAnimate.length, 'elements');\n          } catch (error) {\n            console.error('DEBUG: Error calling findElementsWithPropertyChanges:', error);\n            elementsToAnimate = [];\n          }\n          \n          const easingFunction = getEasingFunction(transitionType);\n          const duration = parseFloat(transitionDuration || '0.3');\n          \n          if (elementsToAnimate.length > 0) {\n            console.log('DEBUG: Animating copy with', elementsToAnimate.length, 'elements using modular system');\n            \n            // Setup animation for each element using the changes already detected\n            elementsToAnimate.forEach(({ element, sourceElement, changes }) => {\n              console.log('DEBUG: Processing element with changes:', changes);\n              \n              // Handle nested instance variant switch\n              if (changes.isNestedInstanceVariantSwitch) {\n                console.log('DEBUG: Handling nested instance variant switch');\n                \n                // Switch the internal variants\n                const sourceComponentSet = sourceElement.querySelector('[data-figma-type=\"COMPONENT_SET\"]');\n                if (sourceComponentSet) {\n                  // Hide current active variant\n                  const currentActiveVariant = sourceComponentSet.querySelector('.variant-active');\n                  if (currentActiveVariant) {\n                    currentActiveVariant.classList.remove('variant-active');\n                    currentActiveVariant.classList.add('variant-hidden');\n                    console.log('DEBUG: Hidden current active variant:', currentActiveVariant.getAttribute('data-figma-id'));\n                  }\n                  \n                  // Show target variant\n                  const targetVariant = changes.targetVariant;\n                  if (targetVariant) {\n                    targetVariant.classList.add('variant-active');\n                    targetVariant.classList.remove('variant-hidden');\n                    console.log('DEBUG: Showed target variant:', targetVariant.getAttribute('data-figma-id'));\n                  }\n                  \n                  console.log('DEBUG: Completed nested instance variant switch');\n                }\n                \n                return; // Skip regular animation processing\n              }\n              \n              // Convert the detected changes to animation changes\n              const animationChanges = [];\n              \n              // Handle position changes - use combined transform for simultaneous X and Y movement\n              const hasPositionX = changes.positionX && changes.positionX.changed;\n              const hasPositionY = changes.positionY && changes.positionY.changed;\n              \n              if (hasPositionX || hasPositionY) {\n                // Create a single combined transform animation\n                const translateX = hasPositionX ? changes.positionX.targetValue : 0;\n                const translateY = hasPositionY ? changes.positionY.targetValue : 0;\n                \n                animationChanges.push({\n                  type: AnimationType.TRANSFORM,\n                  property: 'translate',\n                  sourceValue: { x: 0, y: 0 },\n                  targetValue: { x: translateX, y: translateY },\n                  changed: true,\n                  translationCondition: TranslationCondition.ABSOLUTE,\n                  isCombinedTransform: true\n                });\n                \n                console.log('DEBUG: Created combined transform animation:', {\n                  translateX: translateX,\n                  translateY: translateY,\n                  elementName: element.getAttribute('data-figma-name')\n                });\n              }\n              \n              // Handle color changes\n              if (changes.backgroundColor && changes.backgroundColor.changed) {\n                animationChanges.push({\n                  type: AnimationType.SIMPLE,\n                  property: 'backgroundColor',\n                  sourceValue: changes.backgroundColor.sourceValue,\n                  targetValue: changes.backgroundColor.targetValue,\n                  changed: true\n                });\n              }\n              \n              if (changes.color && changes.color.changed) {\n                animationChanges.push({\n                  type: AnimationType.SIMPLE,\n                  property: 'color',\n                  sourceValue: changes.color.sourceValue,\n                  targetValue: changes.color.targetValue,\n                  changed: true\n                });\n              }\n              \n              // Handle alignment changes\n              if (changes.justifyContent && changes.justifyContent.changed) {\n                // Calculate the position difference that the alignment change creates\n                const parent = element.parentElement;\n                console.log('DEBUG: Alignment change detected:');\n                console.log('  element:', element.getAttribute('data-figma-name'), 'ID:', element.getAttribute('data-figma-id'));\n                console.log('  parent:', parent ? parent.getAttribute('data-figma-name') : 'none', 'ID:', parent ? parent.getAttribute('data-figma-id') : 'none');\n                if (parent) {\n                  const parentRect = parent.getBoundingClientRect();\n                  // Use the original element's dimensions, not the copy's dimensions\n                  const originalElement = originalSourceElement.querySelector(`[data-figma-name=\"${element.getAttribute('data-figma-name')}\"]`) || originalSourceElement;\n                  const elementWidth = originalElement ? originalElement.offsetWidth : element.offsetWidth;\n                  console.log('DEBUG: Element dimension calculation:');\n                  console.log('  originalElement found:', !!originalElement);\n                  console.log('  originalElement name:', originalElement ? originalElement.getAttribute('data-figma-name') : 'none');\n                  console.log('  originalElement.offsetWidth:', originalElement ? originalElement.offsetWidth : 'N/A');\n                  console.log('  copy element.offsetWidth:', element.offsetWidth);\n                  console.log('  final elementWidth used:', elementWidth);\n                  \n                  // Calculate target position based on alignment change using percentage\n                  let targetLeft = 0;\n                  let sourceLeft = 0;\n                  \n                  // Calculate source position (where the element was)\n                  if (changes.justifyContent.sourceValue === 'flex-end') {\n                    // Was positioned at right edge\n                    const elementWidthPercent = (elementWidth / parentRect.width) * 100;\n                    sourceLeft = 100 - elementWidthPercent;\n                  } else if (changes.justifyContent.sourceValue === 'center') {\n                    // Was positioned at center\n                    const elementWidthPercent = (elementWidth / parentRect.width) * 100;\n                    sourceLeft = 50 - (elementWidthPercent / 2);\n                  } else if (changes.justifyContent.sourceValue === 'flex-start') {\n                    // Was positioned at left edge\n                    sourceLeft = 0;\n                  }\n                  \n                  // Calculate target position (where the element should be)\n                  if (changes.justifyContent.targetValue === 'flex-end') {\n                    // For flex-end, position the element so its right edge aligns with parent's right edge\n                    // Calculate the position that places the element's right edge at the parent's right edge\n                    const elementWidthPercent = (elementWidth / parentRect.width) * 100;\n                    targetLeft = 100 - elementWidthPercent;\n                  } else if (changes.justifyContent.targetValue === 'center') {\n                    // For center, position the element so its center aligns with parent's center\n                    const elementWidthPercent = (elementWidth / parentRect.width) * 100;\n                    targetLeft = 50 - (elementWidthPercent / 2);\n                  } else if (changes.justifyContent.targetValue === 'flex-start') {\n                    // For flex-start, position the element at the left edge\n                    targetLeft = 0;\n                  }\n                  \n                  // Always animate the position change for alignment changes\n                  console.log('DEBUG: Calculating justifyContent position animation - KEY VALUES:');\n                  console.log('  sourceLeft:', sourceLeft);\n                  console.log('  targetLeft:', targetLeft);\n                  console.log('  positionDifference:', targetLeft - sourceLeft);\n                  console.log('  sourceJustifyContent:', changes.justifyContent.sourceValue);\n                  console.log('  targetJustifyContent:', changes.justifyContent.targetValue);\n                  console.log('  parentWidth:', parentRect.width);\n                  console.log('  elementWidth (calculated):', elementWidth);\n                  console.log('  element.offsetWidth:', element.offsetWidth);\n                  console.log('  element.clientWidth:', element.clientWidth);\n                  console.log('  element.getBoundingClientRect().width:', element.getBoundingClientRect().width);\n                  console.log('  parent.getBoundingClientRect().width:', parent.getBoundingClientRect().width);\n                  console.log('  availableSpace:', parentRect.width - elementWidth);\n                  \n                  // Set initial position to source position, then animate to target position\n                  element.style.left = `${sourceLeft}%`;\n                  \n                  // Force a reflow to ensure the initial position is applied\n                  element.offsetHeight;\n                  \n                  // Now animate to the target position\n                  element.style.transition = `left ${duration}s ${easingFunction}`;\n                  element.style.left = `${targetLeft}%`;\n                  \n                  console.log('DEBUG: Applied justifyContent position animation:', {\n                    property: 'left',\n                    transitionProperty: 'left',\n                    targetValue: `${targetLeft}%`\n                  });\n                  \n                  // Don't add to animationChanges array since we're handling it directly\n                  return;\n                }\n              }\n              \n              if (changes.alignItems && changes.alignItems.changed) {\n                // Calculate the position difference that the alignment change creates\n                const parent = element.parentElement;\n                if (parent) {\n                  const parentRect = parent.getBoundingClientRect();\n                  const elementHeight = element.offsetHeight;\n                  \n                  // Calculate target position based on alignment change using percentage\n                  let targetTop = 0;\n                  let sourceTop = 0;\n                  \n                  // Calculate source position (where the element was)\n                  if (changes.alignItems.sourceValue === 'flex-end') {\n                    // Was positioned at bottom edge\n                    const elementHeightPercent = (elementHeight / parentRect.height) * 100;\n                    sourceTop = 100 - elementHeightPercent;\n                  } else if (changes.alignItems.sourceValue === 'center') {\n                    // Was positioned at center\n                    const elementHeightPercent = (elementHeight / parentRect.height) * 100;\n                    sourceTop = 50 - (elementHeightPercent / 2);\n                  } else if (changes.alignItems.sourceValue === 'flex-start') {\n                    // Was positioned at top edge\n                    sourceTop = 0;\n                  }\n                  \n                  // Calculate target position (where the element should be)\n                  if (changes.alignItems.targetValue === 'flex-end') {\n                    // Position at bottom edge\n                    const elementHeightPercent = (elementHeight / parentRect.height) * 100;\n                    targetTop = 100 - elementHeightPercent;\n                  } else if (changes.alignItems.targetValue === 'center') {\n                    // Position at center\n                    const elementHeightPercent = (elementHeight / parentRect.height) * 100;\n                    targetTop = 50 - (elementHeightPercent / 2);\n                  } else if (changes.alignItems.targetValue === 'flex-start') {\n                    // Position at top edge\n                    targetTop = 0;\n                  }\n                  \n                  // Always animate the position change for alignment changes\n                  console.log('DEBUG: Calculating alignItems position animation:', {\n                    sourceTop: sourceTop,\n                    targetTop: targetTop,\n                    positionDifference: targetTop - sourceTop,\n                    sourceAlignItems: changes.alignItems.sourceValue,\n                    targetAlignItems: changes.alignItems.targetValue,\n                    parentHeight: parentRect.height,\n                    elementHeight: elementHeight\n                  });\n                  \n                  // Set initial position to source position, then animate to target position\n                  element.style.top = `${sourceTop}%`;\n                  \n                  // Force a reflow to ensure the initial position is applied\n                  element.offsetHeight;\n                  \n                  // Now animate to the target position\n                  element.style.transition = `top ${duration}s ${easingFunction}`;\n                  element.style.top = `${targetTop}%`;\n                  \n                  console.log('DEBUG: Applied alignItems position animation:', {\n                    property: 'top',\n                    transitionProperty: 'top',\n                    targetValue: `${targetTop}%`\n                  });\n                  \n                  // Don't add to animationChanges array since we're handling it directly\n                  return;\n                }\n              }\n              \n              // Note: justifyContent and alignItems changes are handled directly above\n              // and only applied if there's an actual position difference\n              \n              console.log('DEBUG: Converted to animation changes:', animationChanges);\n              \n                          // Apply each change\n            animationChanges.forEach(change => {\n              applyAnimationChange(element, change, duration, easingFunction);\n            });\n          });\n          \n          // Force reflow\n          copy.offsetHeight;\n          \n\n          \n\n            \n\n            \n            // Monitor animation progress using transition end events\n            let completedAnimations = 0;\n            const totalAnimations = elementsToAnimate.length;\n            \n            console.log('DEBUG: Setting up animation monitoring for', totalAnimations, 'elements');\n            \n            // Track which elements have actually been animated and their transition properties\n            const animatedElementsSet = new Set();\n            const transitionProperties = new Map(); // Track which properties are being transitioned\n            \n            // Also track which elements have been processed to avoid double-counting\n            const processedElements = new Set();\n            \n            // Track if animation has completed to stop sub-frame tracking\n            let animationCompleted = false;\n            \n            // Set up transition properties for monitoring\n            elementsToAnimate.forEach(({ element, changes }, index) => {\n              const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n              const elementProperties = [];\n              \n              // Check for combined transform or individual position changes\n              const hasPositionX = changes.positionX && changes.positionX.changed;\n              const hasPositionY = changes.positionY && changes.positionY.changed;\n              \n              if (hasPositionX || hasPositionY) {\n                // Use transform for combined movement, or individual properties for single-axis movement\n                if (hasPositionX && hasPositionY) {\n                  elementProperties.push('transform'); // Combined transform\n                } else {\n                  if (hasPositionX) elementProperties.push('left');\n                  if (hasPositionY) elementProperties.push('top');\n                }\n              }\n              if (changes.backgroundColor && changes.backgroundColor.changed) {\n                elementProperties.push('background-color');\n              }\n              if (changes.color && changes.color.changed) {\n                elementProperties.push('color');\n              }\n              if (changes.justifyContent && changes.justifyContent.changed) {\n                elementProperties.push('left');\n              }\n              if (changes.alignItems && changes.alignItems.changed) {\n                elementProperties.push('top');\n              }\n              \n              // Remove duplicates and set the properties\n              const uniqueProperties = [...new Set(elementProperties)];\n              transitionProperties.set(element, uniqueProperties);\n            });\n            \n            const onTransitionEnd = (event) => {\n              const targetElement = event.target;\n              const propertyName = event.propertyName;\n              \n              console.log('\uD83C\uDFAF TRANSITION END EVENT:', {\n                targetElement: targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'),\n                propertyName: propertyName,\n                timestamp: Date.now()\n              });\n              \n              // Find which element this transition belongs to\n              const animatedElement = elementsToAnimate.find(({ element }) => \n                targetElement === element || element.contains(targetElement)\n              );\n              \n              if (animatedElement) {\n                const elementKey = animatedElement.element;\n                const expectedProperties = transitionProperties.get(elementKey) || [];\n                \n                // Check if this is a property we're expecting to transition\n                if (expectedProperties.includes(propertyName)) {\n                  // Remove this property from the expected list\n                  const updatedProperties = expectedProperties.filter(p => p !== propertyName);\n                  transitionProperties.set(elementKey, updatedProperties);\n                  \n                  // If all properties for this element have completed, mark the element as done\n                                  if (updatedProperties.length === 0 && !animatedElementsSet.has(elementKey)) {\n                  animatedElementsSet.add(elementKey);\n                  completedAnimations++;\n                  \n                  if (completedAnimations >= totalAnimations) {\n                    console.log('\uD83C\uDFAF All animations completed via transition end');\n                    animationCompleted = true;\n                    copy.removeEventListener('transitionend', onTransitionEnd);\n                    copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                    childElements.forEach(child => {\n                      child.removeEventListener('transitionend', onTransitionEnd);\n                    });\n                    clearTimeout(fallbackTimeout);\n                    clearInterval(intervalId);\n                    clearInterval(progressCheckInterval);\n                    resolve();\n                  }\n                }\n                }\n              } else {\n                // Check if this is a child element that might be part of an animated element\n                const parentAnimatedElement = elementsToAnimate.find(({ element }) => \n                  element.contains(targetElement)\n                );\n                \n                if (parentAnimatedElement && !processedElements.has(targetElement)) {\n                  processedElements.add(targetElement);\n                  \n                  // For child elements, we'll use a simpler approach - just count unique elements\n                  const elementKey = parentAnimatedElement.element;\n                  if (!animatedElementsSet.has(elementKey)) {\n                    animatedElementsSet.add(elementKey);\n                    completedAnimations++;\n                    \n                    if (completedAnimations >= totalAnimations) {\n                      console.log('\uD83C\uDFAF All animations completed via child transition');\n                      animationCompleted = true;\n                      copy.removeEventListener('transitionend', onTransitionEnd);\n                      copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                      childElements.forEach(child => {\n                        child.removeEventListener('transitionend', onTransitionEnd);\n                      });\n                      clearTimeout(fallbackTimeout);\n                      clearInterval(intervalId);\n                      clearInterval(progressCheckInterval);\n                      resolve();\n                    }\n                  }\n                }\n              }\n            };\n            \n            // Add a more aggressive monitoring approach - check if animations are actually complete\n            const checkAnimationProgressDetailed = () => {\n              let actuallyCompleted = 0;\n              elementsToAnimate.forEach(({ element, changes }) => {\n                const computedStyle = window.getComputedStyle(element);\n                const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n                \n                // Only log position when there's a significant change or completion\n                const currentLeft = parseFloat(computedStyle.left) || 0;\n                const currentTop = parseFloat(computedStyle.top) || 0;\n                const currentTransform = computedStyle.transform;\n                \n                // Check if the element has reached its target position\n                let isComplete = false;\n                \n                if (changes.positionY && changes.positionY.changed) {\n                  const targetTop = changes.positionY.targetValue;\n                  const difference = Math.abs(currentTop - targetTop);\n                  \n                  if (difference < 5) { // Allow for small rounding differences\n                    isComplete = true;\n                  }\n                }\n                \n                if (changes.positionX && changes.positionX.changed) {\n                  const targetLeft = changes.positionX.targetValue;\n                  const difference = Math.abs(currentLeft - targetLeft);\n                  \n                  if (difference < 5) { // Allow for small rounding differences\n                    isComplete = true;\n                  }\n                }\n                \n                if (isComplete && !animatedElementsSet.has(element)) {\n                  console.log('\uD83C\uDFAF POSITION CHECK COMPLETED:', {\n                    elementName: elementName,\n                    currentLeft: currentLeft,\n                    currentTop: currentTop,\n                    targetLeft: changes.positionX?.targetValue || 0,\n                    targetTop: changes.positionY?.targetValue || 0,\n                    timestamp: Date.now()\n                  });\n                  animatedElementsSet.add(element);\n                  actuallyCompleted++;\n                }\n              });\n              \n              if (actuallyCompleted > 0) {\n                completedAnimations += actuallyCompleted;\n                \n                if (completedAnimations >= totalAnimations) {\n                  console.log('\uD83C\uDFAF All animations completed via position check');\n                  animationCompleted = true;\n                  copy.removeEventListener('transitionend', onTransitionEnd);\n                  copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                  childElements.forEach(child => {\n                    child.removeEventListener('transitionend', onTransitionEnd);\n                  });\n                  clearInterval(intervalId);\n                  clearInterval(progressCheckInterval);\n                  resolve();\n                }\n              }\n            };\n            \n            // Log animation start details\n            console.log('\uD83C\uDFAC ANIMATION START:', {\n              totalElements: elementsToAnimate.length,\n              transitionType: transitionType,\n              transitionDuration: transitionDuration,\n              easingFunction: getEasingFunction(transitionType),\n              elements: elementsToAnimate.map(({ element, changes }) => ({\n                elementName: element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id'),\n                initialLeft: parseFloat(window.getComputedStyle(element).left) || 0,\n                initialTop: parseFloat(window.getComputedStyle(element).top) || 0,\n                targetLeft: changes.positionX?.targetValue || 0,\n                targetTop: changes.positionY?.targetValue || 0,\n                hasPositionX: changes.positionX?.changed || false,\n                hasPositionY: changes.positionY?.changed || false\n              }))\n            });\n            \n            // Add simplified animation progress tracking (no sub-frame logging)\n            let animationStartTime = Date.now();\n            \n            const checkAnimationProgressSimple = () => {\n              // Stop tracking if animation has completed\n              if (animationCompleted) {\n                return;\n              }\n              \n              const currentTime = Date.now();\n              const elapsed = currentTime - animationStartTime;\n              \n              // Only log significant progress milestones (every 100ms)\n              if (elapsed % 100 < 16) { // Log roughly every 100ms\n                console.log('\uD83C\uDFAF ANIMATION PROGRESS:', {\n                  elapsed: elapsed + 'ms',\n                  elements: elementsToAnimate.length,\n                  transitionType: transitionType,\n                  transitionDuration: transitionDuration\n                });\n              }\n            };\n            \n            // Check progress every 100ms instead of 16ms\n            const progressInterval = setInterval(checkAnimationProgressSimple, 100);\n            \n            // Stop progress tracking after animation duration + buffer\n            setTimeout(() => {\n              clearInterval(progressInterval);\n              console.log('\uD83C\uDFAF PROGRESS TRACKING COMPLETED');\n              \n                      // CRITICAL FIX: Stop all animation monitoring when the animation should be complete\n        // This prevents the monitoring from continuing to track the destination variant\n        if (!animationCompleted) {\n          console.log('\uD83C\uDFAF FORCING ANIMATION COMPLETION - stopping all monitoring');\n          animationCompleted = true;\n          copy.removeEventListener('transitionend', onTransitionEnd);\n          copy.removeEventListener('transitionend', onCopyTransitionEnd);\n          childElements.forEach(child => {\n            child.removeEventListener('transitionend', onTransitionEnd);\n          });\n          clearTimeout(fallbackTimeout);\n          clearInterval(intervalId);\n          clearInterval(progressInterval);\n          \n                      // CRITICAL FIX: Ensure the copy has the final position before resolving\n            elementsToAnimate.forEach(({ element, changes }) => {\n              const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n              let computedStyle = window.getComputedStyle(element);\n            console.log('\uD83C\uDFAF FINAL POSITION BEFORE RESOLVE:', {\n              elementName: elementName,\n              finalLeft: computedStyle.left,\n              finalTop: computedStyle.top,\n              targetLeft: changes.positionX?.targetValue || 0,\n              targetTop: changes.positionY?.targetValue || 0\n            });\n          });\n          \n          resolve();\n        }\n            }, parseFloat(transitionDuration || '0.3') * 1000 + 500);\n            \n            // Set up periodic position checking with simplified logging\n            const progressCheckInterval = setInterval(checkAnimationProgressDetailed, 100); // Check every 100ms\n            \n            // Store the interval ID so we can clear it later\n            const intervalId = progressCheckInterval;\n            \n            // Also listen for transitions on the copy element itself\n            const onCopyTransitionEnd = (event) => {\n              const propertyName = event.propertyName;\n              \n              // Since the copy itself isn't animated, we need to find which child element this transition belongs to\n              // The transition end event on the copy usually means one of its animated children has completed\n              const animatedElement = elementsToAnimate.find(({ element }) => \n                copy.contains(element)\n              );\n              \n              if (animatedElement) {\n                const elementKey = animatedElement.element;\n                const expectedProperties = transitionProperties.get(elementKey) || [];\n                \n                // Check if this is a property we're expecting to transition\n                if (expectedProperties.includes(propertyName)) {\n                  // Remove this property from the expected list\n                  const updatedProperties = expectedProperties.filter(p => p !== propertyName);\n                  transitionProperties.set(elementKey, updatedProperties);\n                  \n                  // If all properties for this element have completed, mark the element as done\n                  if (updatedProperties.length === 0 && !animatedElementsSet.has(elementKey)) {\n                    animatedElementsSet.add(elementKey);\n                    completedAnimations++;\n                    \n                    if (completedAnimations >= totalAnimations) {\n                      console.log('\uD83C\uDFAF All animations completed via property completion');\n                      animationCompleted = true;\n                      copy.removeEventListener('transitionend', onTransitionEnd);\n                      copy.removeEventListener('transitionend', onCopyTransitionEnd);\n                      childElements.forEach(child => {\n                        child.removeEventListener('transitionend', onTransitionEnd);\n                      });\n                      clearTimeout(fallbackTimeout);\n                      clearInterval(intervalId);\n                      clearInterval(progressCheckInterval);\n                      resolve();\n                    }\n                  }\n                }\n              }\n            };\n            \n            // Add transition end listener to the copy element and all its children\n            copy.addEventListener('transitionend', onTransitionEnd);\n            copy.addEventListener('transitionend', onCopyTransitionEnd);\n            \n            // Also listen for transitions on child elements that might be animated\n            const childElements = copy.querySelectorAll('*');\n            childElements.forEach(child => {\n              child.addEventListener('transitionend', onTransitionEnd);\n            });\n            \n            // Fallback timeout in case transition events don't fire\n            const fallbackTimeout = setTimeout(() => {\n              // Check if animations are actually complete by examining the computed styles\n              let actuallyCompleted = 0;\n              elementsToAnimate.forEach(({ element, changes }) => {\n                let computedStyle = window.getComputedStyle(element);\n                \n                // If transition is 'none' or empty, animation is likely complete\n                if (!computedStyle.transition || computedStyle.transition === 'none' || computedStyle.transition === 'all 0s ease 0s') {\n                  actuallyCompleted++;\n                }\n              });\n              \n              console.log('\uD83C\uDFAF All animations completed via fallback timeout');\n              animationCompleted = true;\n              copy.removeEventListener('transitionend', onTransitionEnd);\n              copy.removeEventListener('transitionend', onCopyTransitionEnd);\n              childElements.forEach(child => {\n                child.removeEventListener('transitionend', onTransitionEnd);\n              });\n              clearInterval(intervalId);\n              clearInterval(progressInterval);\n              resolve();\n            }, parseFloat(transitionDuration || '0.3') * 1000 + 2000); // Add 2s buffer for more reliability\n          } else {\n            resolve();\n          }\n        });\n      }\n      \n      // Helper function to get node data from element (placeholder)\n      function getNodeDataFromElement(element) {\n        // This would need to be implemented to extract Figma node data from DOM elements\n        // For now, return a basic structure\n        return {\n          type: element.getAttribute('data-figma-type') || 'UNKNOWN',\n          layoutPositioning: element.getAttribute('data-layout-positioning') || 'AUTO',\n          layoutMode: element.getAttribute('data-layout-mode') || 'NONE'\n        };\n      }\n      \n\n\n      // Helper function to find elements with property changes between variants\n      function findElementsWithPropertyChanges(targetVariant, currentVariant, originalSourceVariant) {\n        console.log('DEBUG: findElementsWithPropertyChanges MODULAR VERSION called');\n        console.log('DEBUG: findElementsWithPropertyChanges called in modular-transition-handler.ts');\n        console.log('DEBUG: Parameters:', {\n          targetVariant: targetVariant.getAttribute('data-figma-id'),\n          currentVariant: currentVariant.getAttribute('data-figma-id'),\n          originalSourceVariant: originalSourceVariant ? originalSourceVariant.getAttribute('data-figma-id') : 'none'\n        });\n        \n        if (!currentVariant) {\n          console.log('DEBUG: No current variant provided, returning empty array');\n          return [];\n        }\n        \n        // Check if this is a nested instance with internal variants\n        // Look for the parent instance that contains this component set\n        let isNestedInstance = false;\n        let parentInstance = null;\n        let parentComponentSet = null;\n        \n        if (originalSourceVariant) {\n          // Check if the original source variant is within a nested instance\n          parentComponentSet = originalSourceVariant.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          console.log('DEBUG: Nested instance detection check:', {\n            originalSourceVariant: originalSourceVariant.getAttribute('data-figma-id'),\n            originalSourceType: originalSourceVariant.getAttribute('data-figma-type'),\n            parentComponentSet: parentComponentSet ? parentComponentSet.getAttribute('data-figma-id') : 'none'\n          });\n          \n          if (parentComponentSet) {\n            parentInstance = parentComponentSet.closest('[data-figma-type=\"INSTANCE\"]');\n            if (parentInstance) {\n              isNestedInstance = true;\n              console.log('DEBUG: Found nested instance structure:', {\n                originalSourceVariant: originalSourceVariant.getAttribute('data-figma-id'),\n                parentComponentSet: parentComponentSet.getAttribute('data-figma-id'),\n                parentInstance: parentInstance.getAttribute('data-figma-id')\n              });\n            } else {\n              console.log('DEBUG: No parent instance found for component set');\n            }\n          } else {\n            console.log('DEBUG: No parent component set found');\n          }\n        }\n        \n        if (isNestedInstance) {\n          console.log('DEBUG: Detected nested instance, handling internal variant switch');\n          \n          // For nested instances, we need to handle the internal variant switching\n          // instead of animating individual elements\n          const sourceComponentSet = parentComponentSet;\n          const targetComponentSet = targetVariant.querySelector('[data-figma-type=\"COMPONENT_SET\"]');\n        \n          if (sourceComponentSet && targetComponentSet) {\n            // Find the active variants in both source and target\n            const sourceActiveVariant = sourceComponentSet.querySelector('.variant-active');\n            const targetActiveVariant = targetComponentSet.querySelector('.variant-active');\n            \n            if (sourceActiveVariant && targetActiveVariant) {\n              console.log('DEBUG: Nested instance variant switch:', {\n                sourceVariant: sourceActiveVariant.getAttribute('data-figma-id'),\n                targetVariant: targetActiveVariant.getAttribute('data-figma-id')\n              });\n              \n              // Return a special change that indicates this is a nested instance variant switch\n              return [{\n                element: parentInstance || currentVariant,\n                sourceElement: parentInstance || originalSourceVariant,\n                changes: {\n                  hasChanges: true,\n                  isNestedInstanceVariantSwitch: true,\n                  sourceVariant: sourceActiveVariant,\n                  targetVariant: targetActiveVariant\n                }\n              }];\n            }\n          }\n        }\n        \n        const targetElements = targetVariant.querySelectorAll('[data-figma-id]');\n        const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');\n        const sourceElementMap = new Map();\n        const elementsToAnimate = [];\n\n        console.log('DEBUG: Found', targetElements.length, 'target elements and', sourceElements.length, 'source elements');\n\n        // Build source element map by name\n        sourceElements.forEach(function(sourceElement) {\n          const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');\n          if (sourceName) {\n            sourceElementMap.set(sourceName, sourceElement);\n            console.log('  Mapped source element:', sourceName, '->', sourceElement.getAttribute('data-figma-id'));\n          }\n        });\n\n        // First, check for alignment changes on parent elements that affect child positioning\n        const parentAlignmentChanges = [];\n        targetElements.forEach(function(element, index) {\n          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n          const sourceElement = sourceElementMap.get(targetName);\n          \n          if (sourceElement) {\n            // Check if this element's parent has alignment changes\n            const sourceParent = sourceElement.parentElement;\n            const targetParent = element.parentElement;\n            \n            if (sourceParent && targetParent) {\n              const sourceParentStyleParent = window.getComputedStyle(sourceParent);\n              const targetParentStyleParent = window.getComputedStyle(targetParent);\n              \n              // Check for alignment changes that would affect child positioning\n              if (sourceParentStyleParent.justifyContent !== targetParentStyleParent.justifyContent ||\n                  sourceParentStyleParent.alignItems !== targetParentStyleParent.alignItems) {\n                \n                console.log('DEBUG: Detected parent alignment change:', {\n                  elementName: targetName,\n                  parentName: targetParent.getAttribute('data-figma-name'),\n                  sourceJustifyContent: sourceParentStyleParent.justifyContent,\n                  targetJustifyContent: targetParentStyleParent.justifyContent,\n                  sourceAlignItems: sourceParentStyleParent.alignItems,\n                  targetAlignItems: targetParentStyleParent.alignItems\n                });\n                \n                // Add the parent to the animation list with alignment changes\n                const parentChanges = {\n                  hasChanges: true,\n                  justifyContent: { \n                    changed: sourceParentStyleParent.justifyContent !== targetParentStyleParent.justifyContent,\n                    sourceValue: sourceParentStyleParent.justifyContent,\n                    targetValue: targetParentStyleParent.justifyContent\n                  },\n                  alignItems: { \n                    changed: sourceParentStyleParent.alignItems !== targetParentStyleParent.alignItems,\n                    sourceValue: sourceParentStyleParent.alignItems,\n                    targetValue: targetParentStyleParent.alignItems\n                  }\n                };\n                \n                parentAlignmentChanges.push({\n                  element: sourceElement,  // Animate the CHILD that will be affected by parent alignment\n                  sourceElement: sourceElement,\n                  changes: parentChanges\n                });\n              }\n            }\n          }\n        });\n        \n        // If we found parent alignment changes, prioritize those over child position changes\n        if (parentAlignmentChanges.length > 0) {\n          console.log('DEBUG: Prioritizing parent alignment changes over child position changes');\n          elementsToAnimate.push(...parentAlignmentChanges);\n        } else {\n          // Only check for child position changes if no parent alignment changes were found\n          targetElements.forEach(function(element, index) {\n            const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');\n            const sourceElement = sourceElementMap.get(targetName);\n            \n            console.log('DEBUG: Analyzing target element ' + (index + 1) + ':', targetName);\n            console.log('  Target element ID:', element.getAttribute('data-figma-id'));\n            console.log('  Source element found:', !!sourceElement);\n            \n            if (sourceElement) {\n              console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));\n              const changes = detectPropertyChanges(element, sourceElement, originalSourceVariant);\n              \n              if (changes.hasChanges) {\n                elementsToAnimate.push({\n                  element: sourceElement,  // Use SOURCE element (from copy) instead of target\n                  sourceElement: sourceElement,\n                  changes: changes\n                });\n                console.log('DEBUG: Found element with property changes:', targetName, 'changes:', changes);\n              } else {\n                console.log('DEBUG: No changes detected for element:', targetName);\n              }\n            } else {\n              console.log('DEBUG: No matching source element found for:', targetName);\n            }\n          });\n        }\n        \n        console.log('DEBUG: Returning', elementsToAnimate.length, 'elements to animate');\n        return elementsToAnimate;\n      }\n\n      // Helper function to detect property changes between elements\n      function detectPropertyChanges(targetElement, sourceElement, originalSourceVariant) {\n        console.log('DEBUG: detectPropertyChanges function called for:', targetElement.getAttribute('data-figma-name'));\n        const changes = {\n          hasChanges: false,\n          positionX: { changed: false, sourceValue: null, targetValue: null },\n          positionY: { changed: false, sourceValue: null, targetValue: null },\n          backgroundColor: { changed: false, sourceValue: null, targetValue: null },\n          color: { changed: false, sourceValue: null, targetValue: null },\n          justifyContent: { changed: false, sourceValue: null, targetValue: null },\n          alignItems: { changed: false, sourceValue: null, targetValue: null }\n        };\n\n        try {\n          const sourceStyle = window.getComputedStyle(sourceElement);\n          const targetStyle = window.getComputedStyle(targetElement);\n          \n          // Check for parent alignment changes first\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          \n          console.log('DEBUG: detectPropertyChanges - Checking parent alignment for element:', targetElement.getAttribute('data-figma-name'));\n          console.log('DEBUG: detectPropertyChanges - Source parent:', sourceParent ? sourceParent.getAttribute('data-figma-name') : 'none');\n          console.log('DEBUG: detectPropertyChanges - Target parent:', targetParent ? targetParent.getAttribute('data-figma-name') : 'none');\n          \n          if (sourceParent && targetParent) {\n            const sourceParentStyleProperty = window.getComputedStyle(sourceParent);\n            const targetParentStyleProperty = window.getComputedStyle(targetParent);\n            \n            console.log('DEBUG: detectPropertyChanges - Parent styles comparison:', {\n              sourceParentName: sourceParent.getAttribute('data-figma-name'),\n              targetParentName: targetParent.getAttribute('data-figma-name'),\n              sourceJustifyContent: sourceParentStyleProperty.justifyContent,\n              targetJustifyContent: targetParentStyleProperty.justifyContent,\n              sourceAlignItems: sourceParentStyleProperty.alignItems,\n              targetAlignItems: targetParentStyleProperty.alignItems,\n              justifyContentChanged: sourceParentStyleProperty.justifyContent !== targetParentStyleProperty.justifyContent,\n              alignItemsChanged: sourceParentStyleProperty.alignItems !== targetParentStyleProperty.alignItems\n            });\n            \n            // Check for alignment changes that would affect child positioning\n            if (sourceParentStyleProperty.justifyContent !== targetParentStyleProperty.justifyContent ||\n                sourceParentStyleProperty.alignItems !== targetParentStyleProperty.alignItems) {\n              \n              console.log('DEBUG: detectPropertyChanges - Detected parent alignment change:', {\n                elementName: targetElement.getAttribute('data-figma-name'),\n                parentName: targetParent.getAttribute('data-figma-name'),\n                sourceJustifyContent: sourceParentStyleProperty.justifyContent,\n                targetJustifyContent: targetParentStyleProperty.justifyContent,\n                sourceAlignItems: sourceParentStyleProperty.alignItems,\n                targetAlignItems: targetParentStyleProperty.alignItems\n              });\n              \n              changes.hasChanges = true;\n              changes.justifyContent = { \n                changed: sourceParentStyleProperty.justifyContent !== targetParentStyleProperty.justifyContent,\n                sourceValue: sourceParentStyleProperty.justifyContent,\n                targetValue: targetParentStyleProperty.justifyContent\n              };\n              changes.alignItems = { \n                changed: sourceParentStyleProperty.alignItems !== targetParentStyleProperty.alignItems,\n                sourceValue: sourceParentStyleProperty.alignItems,\n                targetValue: targetParentStyleProperty.alignItems\n              };\n              \n              return changes;\n            } else {\n              console.log('DEBUG: detectPropertyChanges - No parent alignment changes detected');\n            }\n          } else {\n            console.log('DEBUG: detectPropertyChanges - Missing parent elements');\n          }\n        } catch (error) {\n          console.log('DEBUG: Error in parent alignment check:', error);\n        }\n\n        try {\n          let sourceStyle = window.getComputedStyle(sourceElement);\n          let targetStyle = window.getComputedStyle(targetElement);\n          \n          // STEP 1: Check if the node has position changes using bounding rectangles (accounts for flexbox alignment)\n          const targetRect = targetElement.getBoundingClientRect();\n          \n          // Get parent rectangles for relative positioning\n          const sourceParent = sourceElement.parentElement;\n          const targetParent = targetElement.parentElement;\n          const targetParentRect = targetParent ? targetParent.getBoundingClientRect() : { left: 0, top: 0 };\n          \n          // CRITICAL FIX: Use the original source element's position, not the copy's position\n          // The copy is positioned absolutely at the top of the viewport, which creates false position differences\n          const originalSourceElement = originalSourceVariant.querySelector('[data-figma-name=\"' + sourceElement.getAttribute('data-figma-name') + '\"]');\n          \n          if (!originalSourceElement) {\n            return changes;\n          }\n          \n          const originalSourceStyle = window.getComputedStyle(originalSourceElement);\n          const originalSourceRect = originalSourceElement.getBoundingClientRect();\n          const originalSourceParent = originalSourceElement.parentElement;\n          const originalSourceParentRect = originalSourceParent ? originalSourceParent.getBoundingClientRect() : { left: 0, top: 0 };\n          \n          // DEBUG: Check if target element is found correctly\n          const targetName = targetElement.getAttribute('data-figma-name');\n          const sourceName = sourceElement.getAttribute('data-figma-name');\n          \n          if (targetName === 'Frame 1306') {\n            console.log('DEBUG: Frame 1306 position analysis:');\n            console.log('  Target element found:', !!targetElement);\n            console.log('  Target element ID:', targetElement.getAttribute('data-figma-id'));\n            console.log('  Target element data-figma-y:', targetElement.getAttribute('data-figma-y'));\n            console.log('  Target element computed style top:', targetStyle.top);\n            console.log('  Target element bounding rect:', targetRect);\n            console.log('  Target parent bounding rect:', targetParentRect);\n            console.log('  Source element data-figma-y:', originalSourceElement.getAttribute('data-figma-y'));\n            console.log('  Source element computed style top:', originalSourceStyle.top);\n            console.log('  Source element bounding rect:', originalSourceRect);\n            console.log('  Source parent bounding rect:', originalSourceParentRect);\n          }\n          \n          // Calculate positions relative to their respective parents\n          // This ensures we're comparing equivalent coordinate systems\n          // CRITICAL FIX: Use data-figma-y attributes directly since bounding rectangles may not reflect correct positioning\n          const sourceFigmaY = parseFloat(originalSourceElement.getAttribute('data-figma-y')) || 0;\n          const targetFigmaY = parseFloat(targetElement.getAttribute('data-figma-y')) || 0;\n          const sourceFigmaX = parseFloat(originalSourceElement.getAttribute('data-figma-x')) || 0;\n          const targetFigmaX = parseFloat(targetElement.getAttribute('data-figma-x')) || 0;\n          \n          // Use Figma coordinates directly for comparison\n          const sourceRelativeLeft = sourceFigmaX;\n          const sourceRelativeTop = sourceFigmaY;\n          const targetRelativeLeft = targetFigmaX;\n          const targetRelativeTop = targetFigmaY;\n          \n          if (targetName === 'Frame 1306') {\n            console.log('DEBUG: Frame 1306 Figma coordinates:');\n            console.log('  Source Figma coordinates:', { x: sourceFigmaX, y: sourceFigmaY });\n            console.log('  Target Figma coordinates:', { x: targetFigmaX, y: targetFigmaY });\n            console.log('  Differences:', { x: Math.abs(sourceFigmaX - targetFigmaX), y: Math.abs(sourceFigmaY - targetFigmaY) });\n          }\n          \n          // STEP 2: Check if the node has ignore auto layout enabled\n          const ignoreAutoLayout = sourceElement.getAttribute('data-layout-positioning') === 'ABSOLUTE';\n          \n          // STEP 3: Check if the node's parent has auto layout\n          const parentHasAutoLayout = sourceParent && targetParent && \n            sourceParent.getAttribute('data-layout-mode') && \n            sourceParent.getAttribute('data-layout-mode') !== 'NONE';\n          \n\n          \n          // Determine if this node should be animated based on the 3-point logic\n          let shouldAnimatePosition = false;\n          let animationType = 'ABSOLUTE';\n          \n          if (Math.abs(sourceRelativeLeft - targetRelativeLeft) > 1 || Math.abs(sourceRelativeTop - targetRelativeTop) > 1) {\n            // Node has position changes\n            if (ignoreAutoLayout) {\n              // Node ignores auto layout - animate absolutely\n              shouldAnimatePosition = true;\n              animationType = 'ABSOLUTE';\n            } else if (!parentHasAutoLayout) {\n              // Node's parent doesn't have auto layout - animate absolutely\n              shouldAnimatePosition = true;\n              animationType = 'ABSOLUTE';\n            } else {\n              // Node has position changes and parent has auto layout - ANIMATE the node\n              // The node moves due to parent's alignment changes, so we animate it smoothly\n              shouldAnimatePosition = true;\n              animationType = 'ABSOLUTE';\n            }\n          } else {\n            // No position changes - no animation needed\n            shouldAnimatePosition = false;\n          }\n          \n          // Apply position changes if animation is needed\n          if (shouldAnimatePosition) {\n            if (Math.abs(sourceRelativeLeft - targetRelativeLeft) > 1) {\n              changes.positionX.changed = true;\n              changes.positionX.sourceValue = 0; // Start from 0 (additive animation)\n              changes.positionX.targetValue = targetRelativeLeft - sourceRelativeLeft; // Add the difference to current position\n              changes.hasChanges = true;\n            }\n            \n            if (Math.abs(sourceRelativeTop - targetRelativeTop) > 1) {\n              changes.positionY.changed = true;\n              changes.positionY.sourceValue = 0; // Start from 0 (additive animation)\n              changes.positionY.targetValue = targetRelativeTop - sourceRelativeTop; // Add the difference to current position\n              changes.hasChanges = true;\n            }\n          }\n\n          // Check style changes (non-position)\n          const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';\n          const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';\n          \n          if (sourceBg !== targetBg) {\n            changes.backgroundColor.changed = true;\n            changes.backgroundColor.sourceValue = sourceBg;\n            changes.backgroundColor.targetValue = targetBg;\n            changes.hasChanges = true;\n          }\n          \n          if (sourceStyle.color !== targetStyle.color) {\n            changes.color.changed = true;\n            changes.color.sourceValue = sourceStyle.color;\n            changes.color.targetValue = targetStyle.color;\n            changes.hasChanges = true;\n          }\n          \n          // Only mark alignment changes as requiring animation if there's an actual position difference\n          if (sourceStyle.justifyContent !== targetStyle.justifyContent) {\n            changes.justifyContent.changed = true;\n            changes.justifyContent.sourceValue = sourceStyle.justifyContent;\n            changes.justifyContent.targetValue = targetStyle.justifyContent;\n            \n            // Only set hasChanges if there's an actual position difference to animate\n            if (shouldAnimatePosition) {\n              changes.hasChanges = true;\n            }\n          }\n          \n          if (sourceStyle.alignItems !== targetStyle.alignItems) {\n            changes.alignItems.changed = true;\n            changes.alignItems.sourceValue = sourceStyle.alignItems;\n            changes.alignItems.targetValue = targetStyle.alignItems;\n            \n            // Only set hasChanges if there's an actual position difference to animate\n            if (shouldAnimatePosition) {\n              changes.hasChanges = true;\n            }\n          }\n          \n        } catch (error) {\n          console.log('DEBUG: Error detecting property changes:', error);\n        }\n\n        return changes;\n      }\n      \n      // Helper function to handle animated variant switching\n      async function handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration) {\n        console.log('\uD83D\uDD04 VARIANT SWITCH SEQUENCE START:', {\n          sourceId: sourceElement.getAttribute('data-figma-id'),\n          sourceName: sourceElement.getAttribute('data-figma-name'),\n          destinationId: destination.getAttribute('data-figma-id'),\n          destinationName: destination.getAttribute('data-figma-name'),\n          transitionType: transitionType,\n          transitionDuration: transitionDuration,\n          totalVariants: allVariants.length\n        });\n        \n        // Create a copy of the source variant\n        const sourceCopy = createElementCopy(sourceElement);\n        console.log('DEBUG: Element copy created successfully');\n        \n        // Insert the copy into the DOM\n        const sourceParent = sourceElement.parentElement;\n        sourceParent.appendChild(sourceCopy);\n        console.log('DEBUG: Copy inserted into DOM');\n        \n        // Log the copy's position and visibility after insertion\n        const copyRect = sourceCopy.getBoundingClientRect();\n        const copyStyle = window.getComputedStyle(sourceCopy);\n        console.log('DEBUG: Copy after insertion:');\n        console.log('  position: ' + copyStyle.position);\n        console.log('  top: ' + copyStyle.top);\n        console.log('  left: ' + copyStyle.left);\n        console.log('  z-index: ' + copyStyle.zIndex);\n        console.log('  opacity: ' + copyStyle.opacity);\n        console.log('  visibility: ' + copyStyle.visibility);\n        console.log('  display: ' + copyStyle.display);\n        console.log('  bounding rect: ' + copyRect);\n        \n        // Hide the original source element and all other variants\n        sourceElement.style.opacity = '0';\n        sourceElement.style.visibility = 'hidden';\n        \n        allVariants.forEach(variant => {\n          if (variant !== sourceElement) {\n            variant.style.opacity = '0';\n            variant.style.visibility = 'hidden';\n          }\n        });\n        \n        // Prepare the destination variant but keep it hidden for now\n        destination.classList.add('variant-active');\n        destination.classList.remove('variant-hidden');\n        destination.style.visibility = 'hidden';\n        destination.style.opacity = '0';\n        \n        // DON'T pre-position the destination variant - let the copy do all the animation work\n        // The destination variant should remain in its natural position\n        \n        // Force reflow\n        destination.offsetHeight;\n        \n        // Animate the copy to match the destination\n        await animateCopyToDestination(sourceCopy, destination, sourceElement, transitionType, transitionDuration);\n        \n        // Animation complete - simply remove the copy and show the destination variant\n        console.log('\u2705 ANIMATION COMPLETED - removing copy and showing destination variant');\n        sourceCopy.remove();\n        \n        // Hide the original source element permanently\n        sourceElement.style.opacity = '0';\n        sourceElement.style.visibility = 'hidden';\n        sourceElement.classList.add('variant-hidden');\n        sourceElement.classList.remove('variant-active');\n        \n        // Simply show the destination variant - don't touch its positioning\n        console.log('\uD83C\uDFAF SHOWING DESTINATION VARIANT:', {\n          destinationId: destination.getAttribute('data-figma-id'),\n          destinationName: destination.getAttribute('data-figma-name'),\n          visibility: 'visible',\n          opacity: '1',\n          display: 'flex'\n        });\n        destination.style.visibility = 'visible';\n        destination.style.opacity = '1';\n        destination.style.display = 'flex';\n        destination.classList.add('variant-active');\n        destination.classList.remove('variant-hidden');\n        \n        // CRITICAL FIX: Ensure all nested components within the destination variant are also visible\n        const nestedElements = destination.querySelectorAll('[data-figma-id]');\n        nestedElements.forEach(nestedElement => {\n          const elementId = nestedElement.getAttribute('data-figma-id');\n          const elementName = nestedElement.getAttribute('data-figma-name');\n          const computedStyle = window.getComputedStyle(nestedElement);\n          \n          console.log('DEBUG: Processing nested element:', elementName, 'ID:', elementId);\n          console.log('  Before fix - display:', computedStyle.display, 'visibility:', computedStyle.visibility, 'opacity:', computedStyle.opacity);\n          console.log('  Has variant-hidden class:', nestedElement.classList.contains('variant-hidden'));\n          \n          // CRITICAL FIX: Remove variant-hidden class to override CSS !important rule\n          if (nestedElement.classList.contains('variant-hidden')) {\n            nestedElement.classList.remove('variant-hidden');\n            console.log('  Removed variant-hidden class');\n          }\n          \n          // Only make visible if it's not explicitly hidden by variant-hidden class\n          if (!nestedElement.classList.contains('variant-hidden')) {\n            nestedElement.style.visibility = 'visible';\n            nestedElement.style.opacity = '1';\n            // Don't override display if it's already set to flex/block/etc.\n            if (computedStyle.display === 'none') {\n              nestedElement.style.display = 'flex'; // Default to flex for most Figma elements\n            }\n            \n            // Force a reflow to ensure styles are applied\n            nestedElement.offsetHeight;\n            \n            // Check if styles were actually applied\n            const afterStyle = window.getComputedStyle(nestedElement);\n            console.log('  After fix - display:', afterStyle.display, 'visibility:', afterStyle.visibility, 'opacity:', afterStyle.opacity);\n            console.log('  Is now visible?', afterStyle.display !== 'none' && afterStyle.visibility !== 'hidden');\n          } else {\n            console.log('  Skipping - has variant-hidden class');\n          }\n        });\n        \n        console.log('\uD83C\uDFAF MADE NESTED COMPONENTS VISIBLE:', nestedElements.length, 'elements');\n        \n        // Hide all other variants\n        allVariants.forEach(variant => {\n          if (variant !== destination) {\n            variant.classList.add('variant-hidden');\n            variant.classList.remove('variant-active');\n            // Don't reset positions for hidden variants - let them keep their natural positions\n            if (!variant.style.position || variant.style.position === 'static') {\n              variant.style.position = 'relative';\n            }\n            variant.style.opacity = '0';\n            variant.style.visibility = 'hidden';\n          }\n        });\n        \n        // Force a reflow to ensure the position changes are applied before starting reactions\n        destination.offsetHeight;\n        \n        // Start timeout reactions\n        console.log('\u23F0 STARTING TIMEOUT REACTIONS for destination variant');\n        startTimeoutReactionsForNewlyActiveVariant(destination);\n        startTimeoutReactionsForNestedComponents(destination);\n        \n        console.log('\u2705 VARIANT SWITCH SEQUENCE COMPLETED:', {\n          sourceId: sourceElement.getAttribute('data-figma-id'),\n          destinationId: destination.getAttribute('data-figma-id'),\n          transitionType: transitionType\n        });\n      }\n      \n      // Helper function to perform instant variant switch\n      function performInstantVariantSwitch(allVariants, destination) {\n        console.log('\u26A1 PERFORMING INSTANT VARIANT SWITCH');\n        \n        // Hide all variants\n        allVariants.forEach(variant => {\n          variant.classList.add('variant-hidden');\n          variant.classList.remove('variant-active');\n          variant.style.display = 'none';\n          variant.style.visibility = 'hidden';\n          variant.style.opacity = '0';\n          // Don't reset positions for hidden variants - let them keep their natural positions\n          if (!variant.style.position || variant.style.position === 'static') {\n            variant.style.position = 'relative';\n          }\n        });\n        \n        // Show destination variant\n        destination.classList.add('variant-active');\n        destination.classList.remove('variant-hidden');\n        destination.style.display = 'flex';\n        destination.style.visibility = 'visible';\n        destination.style.opacity = '1';\n        // Don't reset position for destination - let it keep its natural position\n        if (!destination.style.position || destination.style.position === 'static') {\n          destination.style.position = 'relative';\n        }\n        \n        console.log('\u2705 INSTANT VARIANT SWITCH COMPLETED:', {\n          destinationId: destination.getAttribute('data-figma-id'),\n          destinationName: destination.getAttribute('data-figma-name'),\n          display: destination.style.display,\n          visibility: destination.style.visibility,\n          opacity: destination.style.opacity\n        });\n        \n        // Start timeout reactions\n        startTimeoutReactionsForNewlyActiveVariant(destination);\n        startTimeoutReactionsForNestedComponents(destination);\n      }\n      \n      // Main reaction handler function\n      function handleReaction(sourceElement, destinationId, transitionType, transitionDuration) {\n        console.log('\uD83C\uDFAF REACTION TRIGGERED:', {\n          sourceId: sourceElement.getAttribute('data-figma-id'),\n          sourceName: sourceElement.getAttribute('data-figma-name'),\n          destinationId: destinationId,\n          transitionType: transitionType,\n          transitionDuration: transitionDuration\n        });\n        \n        // Prevent multiple simultaneous transitions\n        if (isTransitionInProgress) {\n          console.log('\u26A0\uFE0F TRANSITION ALREADY IN PROGRESS - skipping');\n          return;\n        }\n        \n        // Set transition lock\n        isTransitionInProgress = true;\n        \n        // Safety timeout\n        const safetyTimeout = setTimeout(() => {\n          if (isTransitionInProgress) {\n            console.log('WARNING: Transition lock stuck, forcing release');\n            isTransitionInProgress = false;\n            currentTransitionPromise = null;\n          }\n        }, 10000); // Increased to 10 seconds\n        \n        if (destinationId) {\n          const destination = document.querySelector(`[data-figma-id=\"${destinationId}\"]`);\n          \n          if (!destination) {\n            console.error('Destination element not found:', destinationId);\n            clearTimeout(safetyTimeout);\n            isTransitionInProgress = false;\n            return;\n          }\n          \n          // Check if this is a variant switch within a component set\n          const sourceComponentSet = sourceElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          const destinationComponentSet = destination.closest('[data-figma-type=\"COMPONENT_SET\"]');\n          \n          if (sourceComponentSet && destinationComponentSet && sourceComponentSet === destinationComponentSet) {\n            // This is a variant switch\n            console.log('\uD83D\uDD04 VARIANT SWITCH DETECTED:', {\n              componentSetId: sourceComponentSet.getAttribute('data-figma-id'),\n              componentSetName: sourceComponentSet.getAttribute('data-figma-name')\n            });\n            \n            const componentSet = sourceComponentSet;\n            const allVariants = Array.from(componentSet.children).filter(child => \n              child.getAttribute('data-figma-type') === 'COMPONENT'\n            );\n            \n            console.log('\uD83D\uDCCA VARIANT ANALYSIS:', {\n              totalVariants: allVariants.length,\n              variantIds: allVariants.map(v => v.getAttribute('data-figma-id')),\n              variantNames: allVariants.map(v => v.getAttribute('data-figma-name'))\n            });\n            \n            // Check if transition type is null/undefined (instant transition) or a recognized animated type\n            const isAnimated = transitionType === 'SMART_ANIMATE' || \n                              transitionType === 'BOUNCY' || \n                              transitionType === 'EASE_IN_AND_OUT' || \n                              transitionType === 'EASE_IN_AND_OUT_BACK' || \n                              transitionType === 'EASE_IN' || \n                              transitionType === 'EASE_OUT' || \n                              transitionType === 'LINEAR' || \n                              transitionType === 'GENTLE';\n            \n            // Only use fallback values if we have a recognized animated transition type\n            const effectiveTransitionType = isAnimated ? (transitionType || 'EASE_OUT') : transitionType;\n            const effectiveTransitionDuration = isAnimated ? (transitionDuration || '0.3') : transitionDuration;\n            \n            if (isAnimated) {\n              console.log('\uD83C\uDFAC ANIMATED TRANSITION SELECTED:', {\n                transitionType: effectiveTransitionType,\n                transitionDuration: effectiveTransitionDuration\n              });\n              \n              currentTransitionPromise = handleAnimatedVariantSwitch(sourceElement, destination, allVariants, effectiveTransitionType, effectiveTransitionDuration)\n                .then(() => {\n                  clearTimeout(safetyTimeout);\n                  isTransitionInProgress = false;\n                  currentTransitionPromise = null;\n                })\n                .catch((error) => {\n                  console.error('Modular animation error:', error);\n                  clearTimeout(safetyTimeout);\n                  isTransitionInProgress = false;\n                  currentTransitionPromise = null;\n                });\n            } else {\n              console.log('\u26A1 INSTANT TRANSITION SELECTED:', {\n                transitionType: effectiveTransitionType,\n                reason: 'Not recognized as animated transition type'\n              });\n              \n              performInstantVariantSwitch(allVariants, destination);\n              clearTimeout(safetyTimeout);\n              isTransitionInProgress = false;\n              currentTransitionPromise = null;\n            }\n          } else {\n            // This is a regular transition (not variant switching)\n            if (transitionType === 'DISSOLVE') {\n              console.log('\uD83C\uDFAD DISSOLVE TRANSITION SELECTED:', {\n                transitionType: transitionType,\n                transitionDuration: transitionDuration\n              });\n              \n              // Hide source element\n              sourceElement.style.opacity = '0';\n              sourceElement.style.visibility = 'hidden';\n              \n              // Show destination after delay\n              setTimeout(() => {\n                destination.classList.add('variant-active');\n                destination.classList.remove('variant-hidden');\n                destination.style.opacity = '1';\n                destination.style.visibility = 'visible';\n                \n                startTimeoutReactionsForNewlyActiveVariant(destination);\n                startTimeoutReactionsForNestedComponents(destination);\n                \n                clearTimeout(safetyTimeout);\n                isTransitionInProgress = false;\n                currentTransitionPromise = null;\n              }, parseFloat(transitionDuration || '300'));\n            } else {\n              console.log('\u26A1 INSTANT TRANSITION SELECTED (non-variant):', {\n                transitionType: transitionType,\n                reason: 'Not a dissolve transition'\n              });\n              \n              destination.classList.add('variant-active');\n              destination.classList.remove('variant-hidden');\n              destination.style.opacity = '1';\n              destination.style.visibility = 'visible';\n              \n              startTimeoutReactionsForNewlyActiveVariant(destination);\n              startTimeoutReactionsForNestedComponents(destination);\n              \n              clearTimeout(safetyTimeout);\n              isTransitionInProgress = false;\n              currentTransitionPromise = null;\n            }\n          }\n        } else {\n          // Handle case where destinationId is null (final variant - no further transitions)\n          clearTimeout(safetyTimeout);\n          isTransitionInProgress = false;\n          currentTransitionPromise = null;\n        }\n      }\n      \n      // Global timer tracking\n      const activeTimers = new Map();\n      \n      // Function to start timeout reactions for nested components within a parent element\n      function startTimeoutReactionsForNestedComponents(parentElement) {\n        if (!parentElement) return;\n        \n        // Find all nested components with timeout reactions within the parent\n        const nestedComponents = parentElement.querySelectorAll('[data-has-reactions=\"true\"]');\n        \n        nestedComponents.forEach(element => {\n          const elementId = element.getAttribute('data-figma-id');\n          const elementName = element.getAttribute('data-figma-name');\n          const computedStyle = window.getComputedStyle(element);\n          \n          // Only start timers for elements that are actually visible\n          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');\n            \n            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n              console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName);\n              const timeoutId = setTimeout(() => {\n                activeTimers.delete(elementId);\n                const actionType = element.getAttribute('data-reaction-action-type');\n                const destinationId = element.getAttribute('data-reaction-destination');\n                const transitionType = element.getAttribute('data-reaction-transition-type');\n                const transitionDuration = element.getAttribute('data-reaction-transition-duration');\n                \n                handleReaction(element, destinationId, transitionType, transitionDuration);\n              }, (trigger.timeout || 0) * 1000);\n              activeTimers.set(elementId, timeoutId);\n            } else if (activeTimers.has(elementId)) {\n              console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');\n            }\n          } else {\n            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');\n          }\n        });\n      }\n      \n      // Function to start timeout reactions for a specific newly active variant\n      function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {\n        if (!newlyActiveElement) return;\n        \n        const elementId = newlyActiveElement.getAttribute('data-figma-id');\n        const elementName = newlyActiveElement.getAttribute('data-figma-name');\n        const parentComponent = newlyActiveElement.closest('[data-figma-type=\"COMPONENT_SET\"]');\n        const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';\n        \n        console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);\n        \n        // Only start timers for variants that are actually visible (not hidden by CSS)\n        const computedStyle = window.getComputedStyle(newlyActiveElement);\n        \n        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n          const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');\n          const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');\n          const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');\n          const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');\n          const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');\n          \n          // Handle timeout reactions only for active variants that don't have an active timer\n          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {\n            console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);\n            const timeoutId = setTimeout(() => {\n              activeTimers.delete(elementId); // Clear the timer when it completes\n              handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);\n            }, (trigger.timeout || 0) * 1000);\n            activeTimers.set(elementId, timeoutId);\n          } else if (activeTimers.has(elementId)) {\n            console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');\n          }\n          \n          // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant\n          startTimeoutReactionsForNestedComponents(newlyActiveElement);\n        } else {\n          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');\n        }\n      }\n      \n      // Make functions globally available\n      window.handleReaction = handleReaction;\n      window.startTimeoutReactionsForNewlyActiveVariant = startTimeoutReactionsForNewlyActiveVariant;\n      window.startTimeoutReactionsForNestedComponents = startTimeoutReactionsForNestedComponents;\n    ";
}


/***/ }),

/***/ 925:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// Browser-only entry point for the refactored system
// This file only includes code that runs in the browser, not in the Figma plugin
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Import all the event handling and animation modules
__exportStar(__webpack_require__(995), exports);
__exportStar(__webpack_require__(821), exports);
__exportStar(__webpack_require__(120), exports);
__exportStar(__webpack_require__(332), exports);
__exportStar(__webpack_require__(82), exports);
__exportStar(__webpack_require__(44), exports);
__exportStar(__webpack_require__(275), exports);
// Import the modular transition handler function
var modular_transition_handler_1 = __webpack_require__(821);
// Store the function for later execution
var modularTransitionHandlerCode = null;
// Function to execute the modular transition handler when needed
function executeModularTransitionHandler() {
    if (!modularTransitionHandlerCode) {
        modularTransitionHandlerCode = (0, modular_transition_handler_1.createModularSmartAnimateHandler)();
    }
    try {
        eval(modularTransitionHandlerCode);
        console.log('DEBUG: Modular transition handler executed successfully');
        return true;
    }
    catch (error) {
        console.error('DEBUG: Error executing modular transition handler:', error);
        return false;
    }
}
// Initialize the system when loaded in browser
if (typeof window !== 'undefined') {
    console.log('DEBUG: Refactored system loaded in browser');
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeSystem);
    }
    else {
        initializeSystem();
    }
}
function initializeSystem() {
    console.log('DEBUG: Initializing refactored system');
    // Execute the modular transition handler to expose handleReaction
    if (executeModularTransitionHandler()) {
        console.log('DEBUG: Modular transition handler executed successfully');
    }
    else {
        console.error('DEBUG: Failed to execute modular transition handler');
    }
    // Check if the function is available
    setTimeout(function () {
        if (window.handleReaction) {
            console.log('DEBUG: handleReaction function is available globally');
        }
        else {
            console.error('DEBUG: handleReaction function not found - the modular transition handler may not be properly loaded');
        }
    }, 100);
    console.log('DEBUG: Refactored system functions available');
}


/***/ }),

/***/ 995:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateEventHandlingJavaScript = exports.generateVariantAttributes = exports.generateReactionAttributes = void 0;
// Re-export from the new modular events structure
var index_1 = __webpack_require__(172);
Object.defineProperty(exports, "generateReactionAttributes", ({ enumerable: true, get: function () { return index_1.generateReactionAttributes; } }));
Object.defineProperty(exports, "generateVariantAttributes", ({ enumerable: true, get: function () { return index_1.generateVariantAttributes; } }));
Object.defineProperty(exports, "generateEventHandlingJavaScript", ({ enumerable: true, get: function () { return index_1.generateEventHandlingJavaScript; } }));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(925);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});