<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    
    /* iOS-compatible font declarations - using consistent font-family names */
    
    /* TrueType fonts - "CircularXX TT" family with font-weight and font-style variations */
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Thin.ttf") format("truetype");
      font-weight: 100;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-ThinItalic.ttf") format("truetype");
      font-weight: 100;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Light.ttf") format("truetype");
      font-weight: 300;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-LightItalic.ttf") format("truetype");
      font-weight: 300;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Regular.ttf") format("truetype");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Italic.ttf") format("truetype");
      font-weight: 400;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Book.ttf") format("truetype");
      font-weight: 450;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-BookItalic.ttf") format("truetype");
      font-weight: 450;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Medium.ttf") format("truetype");
      font-weight: 500;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-MediumItalic.ttf") format("truetype");
      font-weight: 500;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Bold.ttf") format("truetype");
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-BoldItalic.ttf") format("truetype");
      font-weight: 700;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-Black.ttf") format("truetype");
      font-weight: 900;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-BlackItalic.ttf") format("truetype");
      font-weight: 900;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-ExtraBlack.ttf") format("truetype");
      font-weight: 950;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "CircularXX TT";
      src: url("fonts/CircularXXTT-ExtraBlackItalic.ttf") format("truetype");
      font-weight: 950;
      font-style: italic;
      font-display: swap;
    }
  
    html, body { box-sizing: border-box; margin: 0; padding: 0; width: 100vw; height: 100vh; overflow: hidden; }
    p { margin: 0; }
    [data-figma-id]:not([style*="width:"]):not([style*="height:"]) { width: 100%; height: 100%; }
    .variant-active { display: flex !important; }
    .variant-hidden { display: none !important; }
    .dissolve-source, .dissolve-target { display: block !important; }
    .dissolve-source { opacity: 1; }
    .dissolve-target { opacity: 0; }
    .smart-animate-source, .smart-animate-target { display: block !important; }
    .smart-animate-source { opacity: 1; }
    .smart-animate-target { opacity: 1; }
    * { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    
    /* Debug panel styles */
    .debug-panel {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-family: monospace;
      font-size: 12px;
      max-width: 300px;
      z-index: 10000;
      backdrop-filter: blur(10px);
    }
    .debug-panel h3 {
      margin: 0 0 10px 0;
      color: #4CAF50;
    }
    .debug-panel p {
      margin: 5px 0;
      line-height: 1.4;
    }
    .debug-panel .status {
      color: #FFC107;
    }
    .debug-panel .error {
      color: #F44336;
    }
    .debug-panel .success {
      color: #4CAF50;
    }
  </style>
</head>
<body>
<div data-figma-id="5533:4251" data-figma-name="glydcar/info-bar/counter-sm" data-figma-type="INSTANCE" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="16" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.600000262260437" data-layout-positioning="AUTO" data-figma-x="17566" data-figma-y="1271" data-has-reactions="true" data-reaction-count="1" data-reaction-trigger="{&quot;type&quot;:&quot;AFTER_TIMEOUT&quot;,&quot;timeout&quot;:0.8}" data-reaction-action-type="NODE" data-reaction-destination="5533:3911" data-reaction-transition-type="GENTLE" data-reaction-transition-duration="1.0220937728881836" style="position: relative; top: 0px; left: 0px; display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 16px; box-sizing: border-box; width: 144px; height: 144px; border-radius: 0px"><div data-figma-id="5533:3901" data-figma-name="glydcar/info-bar/counter-sm" data-figma-type="COMPONENT_SET" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="20" data-sizing-horizontal="FILL" data-sizing-vertical="FILL" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="5" data-stroke-weight="1" data-layout-positioning="AUTO" data-figma-x="18406" data-figma-y="1251" style="position: relative; top: 0px; left: 0px; display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 20px; box-sizing: border-box; width: 100%; height: 100%"><div data-figma-id="5533:3902" data-figma-name="Property 1=3" data-figma-type="COMPONENT" data-variant-property-1="3" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="16" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.600000262260437" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" data-has-reactions="true" data-reaction-count="1" data-reaction-trigger="{&quot;type&quot;:&quot;AFTER_TIMEOUT&quot;,&quot;timeout&quot;:0.8}" data-reaction-action-type="NODE" data-reaction-destination="5533:3911" data-reaction-transition-type="GENTLE" data-reaction-transition-duration="1.0220937728881836" style="position: relative; top: 0px; left: 0px; display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 16px; box-sizing: border-box; width: 100%; height: 100%; border-radius: 0px"><div data-figma-id="5533:3903" data-figma-name="Frame 1233" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="MIN" data-item-spacing="10" data-sizing-horizontal="HUG" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="1000" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="background-color: rgba(44, 129, 165, 1); display: flex; flex-direction: row; justify-content: center; align-items: flex-start; gap: 10px; box-sizing: border-box; width: fit-content; height: 144px; position: relative; left: 0px; top: 0px; border-radius: 1000px"><div data-figma-id="5533:3904" data-figma-name="Frame 1232" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="144.00001525878906" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 144.00001525878906px; box-sizing: border-box; width: 144px; height: 720px; position: relative; left: 0px; top: 0px; border-radius: 0px"><div data-figma-id="5533:3905" data-figma-name="Frame 1236" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="1.6000001430511475" data-padding-right="0" data-padding-top="3.200000286102295" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 144px; height: 144px; position: relative; left: 0px; top: 0px; padding-left: 1.6000001430511475px; padding-top: 3.200000286102295px; border-radius: 0px"><svg width="54.25920104980469" height="76.26240539550781" viewBox="0 0 54.25920104980469 76.26240539550781" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="3">
    <path d="M 16.703999914991396 30.75839966834482 L 39.85919880796148 8.755197493907422 L 2.3039993897618625 8.755197493907422 L 2.3039993897618625 0 L 52.531198217307086 0 L 52.531198217307086 8.639998972451874 L 29.83679946931817 30.067197858458748 C 30.60480098251913 29.913597541032896 31.334398414628136 29.836799289668683 32.025596343281656 29.836799289668683 C 34.71359820625767 29.836799289668683 37.36320132871761 30.335999749098082 39.97439960714618 31.334400667956885 C 42.6624014701222 32.25600028369354 45.043198913120776 33.676799595920116 47.11679727671779 35.59680013051557 C 49.267196936044016 37.51680066511102 50.995197479723394 39.897601389044546 52.30079661893768 42.73920153937665 C 53.6063980469702 45.504001530995836 54.25920104980469 48.729598660195144 54.25920104980469 52.41599941196021 C 54.25920104980469 55.56479905273479 53.6447983133651 58.598399027644604 52.416000469880025 61.51679933668964 C 51.2639993444877 64.35839948702174 49.53600108962655 66.89280338940418 47.23200112766013 69.12000398664672 C 44.928001165693715 71.2704040437066 42.12479850353299 72.99840065292463 38.82239771881444 74.3040007761236 C 35.51999693409589 75.60960089932257 31.756799819093224 76.26240539550781 27.53280179616998 76.26240539550781 C 23.38560049133949 76.26240539550781 19.622399561639767 75.64800469800902 16.243199770010232 74.41920463815553 C 12.940800129700794 73.11360451495656 10.099200252902817 71.42400588701142 7.718400139616301 69.35040560719473 C 5.414400177649881 67.20000574086973 3.571199788460069 64.74240314160943 2.1887999257211286 61.97760257778564 C 0.8831996420977266 59.136002999658146 0.15359973043563444 56.14080119675609 0 52.99200041157228 L 9.446399920356264 50.80320027515594 C 9.52320007167636 53.41440109375849 10.060799986507917 55.795201817692025 11.059199664850935 57.94560168401703 C 12.057599343193953 60.01920196383372 13.36319924534765 61.78560218100333 14.976000134251436 63.24480233552584 C 16.588799878746105 64.70400249004835 18.47039996212626 65.8176040284463 20.620799621452488 66.58560447116632 C 22.771200425187832 67.35360434168173 25.036798976350237 67.73760036687459 27.417597945227637 67.73760036687459 C 30.02879851247444 67.73760036687459 32.40959900723066 67.35360434168173 34.559998666556886 66.58560447116632 C 36.71039832588311 65.8176040284463 38.5152001652917 64.7424000898515 39.97439960714618 63.36000009404191 C 41.43360133781889 61.977600098232315 42.54719914505868 60.36480248730702 43.315198369441404 58.5216026836291 C 44.15999888955334 56.678402307746566 44.58240105695784 54.68160314031715 44.58240105695784 52.53120327399215 C 44.58240105695784 49.99680261410251 44.12160014903726 47.80800018886772 43.20000062201434 45.96479981298519 C 42.27839880617319 44.04479927838974 41.04959791093047 42.50879991882865 39.51359946216501 41.356800971362446 C 37.97759872458132 40.12800072077409 36.21119867744646 39.206401105037436 34.21439932076043 38.591999835334036 C 32.29439897098537 37.977600854449086 30.297598088420514 37.670399456657904 28.223997436005266 37.670399456657904 C 25.766397171398655 37.670399456657904 23.500798620236253 38.01600036160094 21.42719911223012 38.70720064560804 L 16.703999914991396 30.75839966834482 Z" 
            fill="rgba(0, 0, 0, 1)" 
            stroke="none" 
            stroke-width="0.43928295373916626"
            fill-rule="nonzero" />
</g></svg></div>
<div data-figma-id="5533:3907" data-figma-name="Frame 1235" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="288" style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 144px; height: 144px; position: relative; left: 0px; top: 0px; border-radius: 0px"><svg width="51.37920379638672" height="76.26240539550781" viewBox="0 0 51.37920379638672 76.26240539550781" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="2">
    <path d="M 1.0367999722604826 27.187202891554318 C 0.8064000843886296 26.188804341418887 0.6912000927689886 25.075204227289905 0.6912000927689886 23.846404075046223 C 0.6912000927689886 20.62080453371341 1.2671999554997642 17.587204038652537 2.4191996809613157 14.74560182692418 C 3.5711996925251537 11.827202895856853 5.222399937981818 9.292803583212253 7.372800226596449 7.142403888990376 C 9.523199943006507 4.915205186611262 12.172799321104819 3.1872046148907307 15.321599886770244 1.9584021738287811 C 18.470399308026522 0.6528007246095937 22.041598237612245 0 26.035198201406274 0 C 29.875199002891833 0 33.33120094493192 0.6144012205309748 36.40320021282939 1.8432036615929241 C 39.47520176954515 2.9952025168611 42.04800061281494 4.6080022875275075 44.121599031457045 6.681602973592145 C 46.2719987478671 8.755203659656782 47.88480006105351 11.174404460065528 48.96000220807683 13.939205374818378 C 50.112001075231525 16.627202703777456 50.68800203468773 19.507202893705585 50.68800203468773 22.579204418723922 C 50.68800203468773 27.494405027698647 49.42080236529025 31.872002661360217 46.886403026495294 35.71200113440574 C 44.352001398882045 39.55200189626953 40.93439819837735 42.816002467559805 36.63359876555724 45.50400208533715 L 21.31200040466586 55.29600608802625 C 19.084800534896992 56.75520669796905 17.04960085779029 58.48320307352275 15.206400610406318 60.480002462611886 C 13.363200363022347 62.47680242390558 12.211199969988796 64.81920536056623 11.75040019424509 67.50720555054814 L 51.37920379638672 67.50720555054814 L 51.37920379638672 76.26240539550781 L 0 76.26240539550781 C 0.15360002061533082 70.50240539712127 1.4976001294739034 65.31840406342937 4.03200023120829 60.71040406472014 C 6.566400142207819 56.02560391344453 10.828799879818247 51.72480261765222 16.81919963477443 47.808002847631194 L 30.182399616327064 39.16800380372565 C 37.40160029914533 34.56000380501641 41.0112017849636 29.068802242528747 41.0112017849636 22.694402168020357 C 41.0112017849636 20.851203084063968 40.66560090411411 19.084803008264817 39.974400668293974 17.395201940622904 C 39.359999441423504 15.705600872980991 38.40000114840069 14.208001140429289 37.09440197452838 12.902404268846636 C 35.865601809605735 11.520003811470211 34.291200000894165 10.444804727298697 32.371199600151385 9.676805490453246 C 30.451199199408606 8.908806253607795 28.262399978523717 8.524806635185069 25.804799648678426 8.524806635185069 C 20.736000971088515 8.524806635185069 16.85760028365841 10.09920461295459 14.16959949373669 13.24800056849363 C 11.481599848224118 16.320002093511967 10.137600406937546 20.160002855375755 10.137600406937546 24.768002854084994 C 10.137600406937546 26.22720231961866 10.2528004462409 27.417602967783722 10.483199761908182 28.339204798580184 L 1.0367999722604826 27.187202891554318 Z" 
            fill="rgba(0, 0, 0, 1)" 
            stroke="none" 
            stroke-width="0.43928295373916626"
            fill-rule="nonzero" />
</g></svg></div>
<div data-figma-id="5533:3909" data-figma-name="Frame 1234" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="11.200000762939453" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="576" style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 144px; height: 144px; position: relative; left: 0px; top: 0px; padding-right: 11.200000762939453px; border-radius: 0px"><svg width="27.763200759887695" height="74.64959716796875" viewBox="0 0 27.763200759887695 74.64959716796875" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="1">
    <path d="M 18.316799171732722 74.64959716796875 L 18.316799171732722 20.15999755859375 L 0 20.15999755859375 L 0 14.630397033691407 C 5.222400068544256 14.399995422363283 9.484799947778232 12.9407958984375 12.787200400641348 10.252798461914063 C 16.16640024303896 7.487997436523438 18.316799934672144 4.0703979492187505 19.2383994755409 0 L 27.763200759887695 0 L 27.763200759887695 74.64959716796875 L 18.316799171732722 74.64959716796875 Z" 
            fill="rgba(0, 0, 0, 1)" 
            stroke="none" 
            stroke-width="0.43928295373916626"
            fill-rule="nonzero" />
</g></svg></div></div></div></div>
<div data-figma-id="5533:3911" data-figma-name="Property 1=2" data-figma-type="COMPONENT" data-variant-property-1="2" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="16" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.600000262260437" data-layout-positioning="AUTO" data-figma-x="164" data-figma-y="0" data-has-reactions="true" data-reaction-count="1" data-reaction-trigger="{&quot;type&quot;:&quot;AFTER_TIMEOUT&quot;,&quot;timeout&quot;:0.8}" data-reaction-action-type="NODE" data-reaction-destination="7335:742" data-reaction-transition-type="GENTLE" data-reaction-transition-duration="1.0220937728881836" style="position: relative; top: 0px; left: 0px; display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 16px; box-sizing: border-box; width: 100%; height: 100%; border-radius: 0px"><div data-figma-id="7235:2051" data-figma-name="Frame 1233" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="10" data-sizing-horizontal="HUG" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="1000" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="background-color: rgba(44, 129, 165, 1); display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 10px; box-sizing: border-box; width: fit-content; height: 144px; position: relative; left: 0px; top: 0px; border-radius: 1000px"><div data-figma-id="7235:2052" data-figma-name="Frame 1232" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="144.00001525878906" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="-288" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 144.00001525878906px; box-sizing: border-box; width: 144px; height: 720px; position: relative; left: 0px; top: 0px; border-radius: 0px"><div data-figma-id="7235:2053" data-figma-name="Frame 1236" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="1.6000001430511475" data-padding-right="0" data-padding-top="3.200000286102295" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 144px; height: 144px; position: relative; left: 0px; top: 0px; padding-left: 1.6000001430511475px; padding-top: 3.200000286102295px; border-radius: 0px"><svg width="54.25920104980469" height="76.26240539550781" viewBox="0 0 54.25920104980469 76.26240539550781" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="3">
    <path d="M 16.703999914991396 30.75839966834482 L 39.85919880796148 8.755197493907422 L 2.3039993897618625 8.755197493907422 L 2.3039993897618625 0 L 52.531198217307086 0 L 52.531198217307086 8.639998972451874 L 29.83679946931817 30.067197858458748 C 30.60480098251913 29.913597541032896 31.334398414628136 29.836799289668683 32.025596343281656 29.836799289668683 C 34.71359820625767 29.836799289668683 37.36320132871761 30.335999749098082 39.97439960714618 31.334400667956885 C 42.6624014701222 32.25600028369354 45.043198913120776 33.676799595920116 47.11679727671779 35.59680013051557 C 49.267196936044016 37.51680066511102 50.995197479723394 39.897601389044546 52.30079661893768 42.73920153937665 C 53.6063980469702 45.504001530995836 54.25920104980469 48.729598660195144 54.25920104980469 52.41599941196021 C 54.25920104980469 55.56479905273479 53.6447983133651 58.598399027644604 52.416000469880025 61.51679933668964 C 51.2639993444877 64.35839948702174 49.53600108962655 66.89280338940418 47.23200112766013 69.12000398664672 C 44.928001165693715 71.2704040437066 42.12479850353299 72.99840065292463 38.82239771881444 74.3040007761236 C 35.51999693409589 75.60960089932257 31.756799819093224 76.26240539550781 27.53280179616998 76.26240539550781 C 23.38560049133949 76.26240539550781 19.622399561639767 75.64800469800902 16.243199770010232 74.41920463815553 C 12.940800129700794 73.11360451495656 10.099200252902817 71.42400588701142 7.718400139616301 69.35040560719473 C 5.414400177649881 67.20000574086973 3.571199788460069 64.74240314160943 2.1887999257211286 61.97760257778564 C 0.8831996420977266 59.136002999658146 0.15359973043563444 56.14080119675609 0 52.99200041157228 L 9.446399920356264 50.80320027515594 C 9.52320007167636 53.41440109375849 10.060799986507917 55.795201817692025 11.059199664850935 57.94560168401703 C 12.057599343193953 60.01920196383372 13.36319924534765 61.78560218100333 14.976000134251436 63.24480233552584 C 16.588799878746105 64.70400249004835 18.47039996212626 65.8176040284463 20.620799621452488 66.58560447116632 C 22.771200425187832 67.35360434168173 25.036798976350237 67.73760036687459 27.417597945227637 67.73760036687459 C 30.02879851247444 67.73760036687459 32.40959900723066 67.35360434168173 34.559998666556886 66.58560447116632 C 36.71039832588311 65.8176040284463 38.5152001652917 64.7424000898515 39.97439960714618 63.36000009404191 C 41.43360133781889 61.977600098232315 42.54719914505868 60.36480248730702 43.315198369441404 58.5216026836291 C 44.15999888955334 56.678402307746566 44.58240105695784 54.68160314031715 44.58240105695784 52.53120327399215 C 44.58240105695784 49.99680261410251 44.12160014903726 47.80800018886772 43.20000062201434 45.96479981298519 C 42.27839880617319 44.04479927838974 41.04959791093047 42.50879991882865 39.51359946216501 41.356800971362446 C 37.97759872458132 40.12800072077409 36.21119867744646 39.206401105037436 34.21439932076043 38.591999835334036 C 32.29439897098537 37.977600854449086 30.297598088420514 37.670399456657904 28.223997436005266 37.670399456657904 C 25.766397171398655 37.670399456657904 23.500798620236253 38.01600036160094 21.42719911223012 38.70720064560804 L 16.703999914991396 30.75839966834482 Z" 
            fill="rgba(0, 0, 0, 1)" 
            stroke="none" 
            stroke-width="0.43928295373916626"
            fill-rule="nonzero" />
</g></svg></div>
<div data-figma-id="7235:2055" data-figma-name="Frame 1235" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="288" style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 144px; height: 144px; position: relative; left: 0px; top: 0px; border-radius: 0px"><svg width="51.37920379638672" height="76.26240539550781" viewBox="0 0 51.37920379638672 76.26240539550781" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="2">
    <path d="M 1.0367999722604826 27.187202891554318 C 0.8064000843886296 26.188804341418887 0.6912000927689886 25.075204227289905 0.6912000927689886 23.846404075046223 C 0.6912000927689886 20.62080453371341 1.2671999554997642 17.587204038652537 2.4191996809613157 14.74560182692418 C 3.5711996925251537 11.827202895856853 5.222399937981818 9.292803583212253 7.372800226596449 7.142403888990376 C 9.523199943006507 4.915205186611262 12.172799321104819 3.1872046148907307 15.321599886770244 1.9584021738287811 C 18.470399308026522 0.6528007246095937 22.041598237612245 0 26.035198201406274 0 C 29.875199002891833 0 33.33120094493192 0.6144012205309748 36.40320021282939 1.8432036615929241 C 39.47520176954515 2.9952025168611 42.04800061281494 4.6080022875275075 44.121599031457045 6.681602973592145 C 46.2719987478671 8.755203659656782 47.88480006105351 11.174404460065528 48.96000220807683 13.939205374818378 C 50.112001075231525 16.627202703777456 50.68800203468773 19.507202893705585 50.68800203468773 22.579204418723922 C 50.68800203468773 27.494405027698647 49.42080236529025 31.872002661360217 46.886403026495294 35.71200113440574 C 44.352001398882045 39.55200189626953 40.93439819837735 42.816002467559805 36.63359876555724 45.50400208533715 L 21.31200040466586 55.29600608802625 C 19.084800534896992 56.75520669796905 17.04960085779029 58.48320307352275 15.206400610406318 60.480002462611886 C 13.363200363022347 62.47680242390558 12.211199969988796 64.81920536056623 11.75040019424509 67.50720555054814 L 51.37920379638672 67.50720555054814 L 51.37920379638672 76.26240539550781 L 0 76.26240539550781 C 0.15360002061533082 70.50240539712127 1.4976001294739034 65.31840406342937 4.03200023120829 60.71040406472014 C 6.566400142207819 56.02560391344453 10.828799879818247 51.72480261765222 16.81919963477443 47.808002847631194 L 30.182399616327064 39.16800380372565 C 37.40160029914533 34.56000380501641 41.0112017849636 29.068802242528747 41.0112017849636 22.694402168020357 C 41.0112017849636 20.851203084063968 40.66560090411411 19.084803008264817 39.974400668293974 17.395201940622904 C 39.359999441423504 15.705600872980991 38.40000114840069 14.208001140429289 37.09440197452838 12.902404268846636 C 35.865601809605735 11.520003811470211 34.291200000894165 10.444804727298697 32.371199600151385 9.676805490453246 C 30.451199199408606 8.908806253607795 28.262399978523717 8.524806635185069 25.804799648678426 8.524806635185069 C 20.736000971088515 8.524806635185069 16.85760028365841 10.09920461295459 14.16959949373669 13.24800056849363 C 11.481599848224118 16.320002093511967 10.137600406937546 20.160002855375755 10.137600406937546 24.768002854084994 C 10.137600406937546 26.22720231961866 10.2528004462409 27.417602967783722 10.483199761908182 28.339204798580184 L 1.0367999722604826 27.187202891554318 Z" 
            fill="rgba(0, 0, 0, 1)" 
            stroke="none" 
            stroke-width="0.43928295373916626"
            fill-rule="nonzero" />
</g></svg></div>
<div data-figma-id="7235:2057" data-figma-name="Frame 1234" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="11.200000762939453" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="576" style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 144px; height: 144px; position: relative; left: 0px; top: 0px; padding-right: 11.200000762939453px; border-radius: 0px"><svg width="27.763200759887695" height="74.64959716796875" viewBox="0 0 27.763200759887695 74.64959716796875" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="1">
    <path d="M 18.316799171732722 74.64959716796875 L 18.316799171732722 20.15999755859375 L 0 20.15999755859375 L 0 14.630397033691407 C 5.222400068544256 14.399995422363283 9.484799947778232 12.9407958984375 12.787200400641348 10.252798461914063 C 16.16640024303896 7.487997436523438 18.316799934672144 4.0703979492187505 19.2383994755409 0 L 27.763200759887695 0 L 27.763200759887695 74.64959716796875 L 18.316799171732722 74.64959716796875 Z" 
            fill="rgba(0, 0, 0, 1)" 
            stroke="none" 
            stroke-width="0.43928295373916626"
            fill-rule="nonzero" />
</g></svg></div></div></div></div>
<div data-figma-id="7335:742" data-figma-name="Property 1=1" data-figma-type="COMPONENT" data-variant-property-1="1" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="16" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.600000262260437" data-layout-positioning="AUTO" data-figma-x="328" data-figma-y="0" data-has-reactions="true" data-reaction-count="1" data-reaction-trigger="{&quot;type&quot;:&quot;AFTER_TIMEOUT&quot;,&quot;timeout&quot;:0.8}" data-reaction-action-type="NODE" data-reaction-transition-type="GENTLE" data-reaction-transition-duration="1.0220937728881836" style="position: relative; top: 0px; left: 0px; display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 16px; box-sizing: border-box; width: 100%; height: 100%; border-radius: 0px"><div data-figma-id="7335:743" data-figma-name="Frame 1233" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="MAX" data-item-spacing="10" data-sizing-horizontal="HUG" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="1000" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="background-color: rgba(44, 129, 165, 1); display: flex; flex-direction: row; justify-content: center; align-items: flex-end; gap: 10px; box-sizing: border-box; width: fit-content; height: 144px; position: relative; left: 0px; top: 0px; border-radius: 1000px"><div data-figma-id="7335:744" data-figma-name="Frame 1232" data-figma-type="FRAME" data-layout-mode="VERTICAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="144.00001525878906" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="-576" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 144.00001525878906px; box-sizing: border-box; width: 144px; height: 720px; position: relative; left: 0px; top: 0px; border-radius: 0px"><div data-figma-id="7335:745" data-figma-name="Frame 1236" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="1.6000001430511475" data-padding-right="0" data-padding-top="3.200000286102295" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="0" style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 144px; height: 144px; position: relative; left: 0px; top: 0px; padding-left: 1.6000001430511475px; padding-top: 3.200000286102295px; border-radius: 0px"><svg width="54.25920104980469" height="76.26240539550781" viewBox="0 0 54.25920104980469 76.26240539550781" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="3">
    <path d="M 16.703999914991396 30.75839966834482 L 39.85919880796148 8.755197493907422 L 2.3039993897618625 8.755197493907422 L 2.3039993897618625 0 L 52.531198217307086 0 L 52.531198217307086 8.639998972451874 L 29.83679946931817 30.067197858458748 C 30.60480098251913 29.913597541032896 31.334398414628136 29.836799289668683 32.025596343281656 29.836799289668683 C 34.71359820625767 29.836799289668683 37.36320132871761 30.335999749098082 39.97439960714618 31.334400667956885 C 42.6624014701222 32.25600028369354 45.043198913120776 33.676799595920116 47.11679727671779 35.59680013051557 C 49.267196936044016 37.51680066511102 50.995197479723394 39.897601389044546 52.30079661893768 42.73920153937665 C 53.6063980469702 45.504001530995836 54.25920104980469 48.729598660195144 54.25920104980469 52.41599941196021 C 54.25920104980469 55.56479905273479 53.6447983133651 58.598399027644604 52.416000469880025 61.51679933668964 C 51.2639993444877 64.35839948702174 49.53600108962655 66.89280338940418 47.23200112766013 69.12000398664672 C 44.928001165693715 71.2704040437066 42.12479850353299 72.99840065292463 38.82239771881444 74.3040007761236 C 35.51999693409589 75.60960089932257 31.756799819093224 76.26240539550781 27.53280179616998 76.26240539550781 C 23.38560049133949 76.26240539550781 19.622399561639767 75.64800469800902 16.243199770010232 74.41920463815553 C 12.940800129700794 73.11360451495656 10.099200252902817 71.42400588701142 7.718400139616301 69.35040560719473 C 5.414400177649881 67.20000574086973 3.571199788460069 64.74240314160943 2.1887999257211286 61.97760257778564 C 0.8831996420977266 59.136002999658146 0.15359973043563444 56.14080119675609 0 52.99200041157228 L 9.446399920356264 50.80320027515594 C 9.52320007167636 53.41440109375849 10.060799986507917 55.795201817692025 11.059199664850935 57.94560168401703 C 12.057599343193953 60.01920196383372 13.36319924534765 61.78560218100333 14.976000134251436 63.24480233552584 C 16.588799878746105 64.70400249004835 18.47039996212626 65.8176040284463 20.620799621452488 66.58560447116632 C 22.771200425187832 67.35360434168173 25.036798976350237 67.73760036687459 27.417597945227637 67.73760036687459 C 30.02879851247444 67.73760036687459 32.40959900723066 67.35360434168173 34.559998666556886 66.58560447116632 C 36.71039832588311 65.8176040284463 38.5152001652917 64.7424000898515 39.97439960714618 63.36000009404191 C 41.43360133781889 61.977600098232315 42.54719914505868 60.36480248730702 43.315198369441404 58.5216026836291 C 44.15999888955334 56.678402307746566 44.58240105695784 54.68160314031715 44.58240105695784 52.53120327399215 C 44.58240105695784 49.99680261410251 44.12160014903726 47.80800018886772 43.20000062201434 45.96479981298519 C 42.27839880617319 44.04479927838974 41.04959791093047 42.50879991882865 39.51359946216501 41.356800971362446 C 37.97759872458132 40.12800072077409 36.21119867744646 39.206401105037436 34.21439932076043 38.591999835334036 C 32.29439897098537 37.977600854449086 30.297598088420514 37.670399456657904 28.223997436005266 37.670399456657904 C 25.766397171398655 37.670399456657904 23.500798620236253 38.01600036160094 21.42719911223012 38.70720064560804 L 16.703999914991396 30.75839966834482 Z" 
            fill="rgba(0, 0, 0, 1)" 
            stroke="none" 
            stroke-width="0.43928295373916626"
            fill-rule="nonzero" />
</g></svg></div>
<div data-figma-id="7335:747" data-figma-name="Frame 1235" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="0" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="288" style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 144px; height: 144px; position: relative; left: 0px; top: 0px; border-radius: 0px"><svg width="51.37920379638672" height="76.26240539550781" viewBox="0 0 51.37920379638672 76.26240539550781" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="2">
    <path d="M 1.0367999722604826 27.187202891554318 C 0.8064000843886296 26.188804341418887 0.6912000927689886 25.075204227289905 0.6912000927689886 23.846404075046223 C 0.6912000927689886 20.62080453371341 1.2671999554997642 17.587204038652537 2.4191996809613157 14.74560182692418 C 3.5711996925251537 11.827202895856853 5.222399937981818 9.292803583212253 7.372800226596449 7.142403888990376 C 9.523199943006507 4.915205186611262 12.172799321104819 3.1872046148907307 15.321599886770244 1.9584021738287811 C 18.470399308026522 0.6528007246095937 22.041598237612245 0 26.035198201406274 0 C 29.875199002891833 0 33.33120094493192 0.6144012205309748 36.40320021282939 1.8432036615929241 C 39.47520176954515 2.9952025168611 42.04800061281494 4.6080022875275075 44.121599031457045 6.681602973592145 C 46.2719987478671 8.755203659656782 47.88480006105351 11.174404460065528 48.96000220807683 13.939205374818378 C 50.112001075231525 16.627202703777456 50.68800203468773 19.507202893705585 50.68800203468773 22.579204418723922 C 50.68800203468773 27.494405027698647 49.42080236529025 31.872002661360217 46.886403026495294 35.71200113440574 C 44.352001398882045 39.55200189626953 40.93439819837735 42.816002467559805 36.63359876555724 45.50400208533715 L 21.31200040466586 55.29600608802625 C 19.084800534896992 56.75520669796905 17.04960085779029 58.48320307352275 15.206400610406318 60.480002462611886 C 13.363200363022347 62.47680242390558 12.211199969988796 64.81920536056623 11.75040019424509 67.50720555054814 L 51.37920379638672 67.50720555054814 L 51.37920379638672 76.26240539550781 L 0 76.26240539550781 C 0.15360002061533082 70.50240539712127 1.4976001294739034 65.31840406342937 4.03200023120829 60.71040406472014 C 6.566400142207819 56.02560391344453 10.828799879818247 51.72480261765222 16.81919963477443 47.808002847631194 L 30.182399616327064 39.16800380372565 C 37.40160029914533 34.56000380501641 41.0112017849636 29.068802242528747 41.0112017849636 22.694402168020357 C 41.0112017849636 20.851203084063968 40.66560090411411 19.084803008264817 39.974400668293974 17.395201940622904 C 39.359999441423504 15.705600872980991 38.40000114840069 14.208001140429289 37.09440197452838 12.902404268846636 C 35.865601809605735 11.520003811470211 34.291200000894165 10.444804727298697 32.371199600151385 9.676805490453246 C 30.451199199408606 8.908806253607795 28.262399978523717 8.524806635185069 25.804799648678426 8.524806635185069 C 20.736000971088515 8.524806635185069 16.85760028365841 10.09920461295459 14.16959949373669 13.24800056849363 C 11.481599848224118 16.320002093511967 10.137600406937546 20.160002855375755 10.137600406937546 24.768002854084994 C 10.137600406937546 26.22720231961866 10.2528004462409 27.417602967783722 10.483199761908182 28.339204798580184 L 1.0367999722604826 27.187202891554318 Z" 
            fill="rgba(0, 0, 0, 1)" 
            stroke="none" 
            stroke-width="0.43928295373916626"
            fill-rule="nonzero" />
</g></svg></div>
<div data-figma-id="7335:749" data-figma-name="Frame 1234" data-figma-type="FRAME" data-layout-mode="HORIZONTAL" data-primary-axis="CENTER" data-counter-axis="CENTER" data-item-spacing="0" data-sizing-horizontal="FIXED" data-sizing-vertical="FIXED" data-padding-left="0" data-padding-right="11.200000762939453" data-padding-top="0" data-padding-bottom="0" data-opacity="1" data-corner-radius="0" data-stroke-weight="1.6000001430511475" data-layout-positioning="AUTO" data-figma-x="0" data-figma-y="576" style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 0px; box-sizing: border-box; width: 144px; height: 144px; position: relative; left: 0px; top: 0px; padding-right: 11.200000762939453px; border-radius: 0px"><svg width="27.763200759887695" height="74.64959716796875" viewBox="0 0 27.763200759887695 74.64959716796875" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="1">
    <path d="M 18.316799171732722 74.64959716796875 L 18.316799171732722 20.15999755859375 L 0 20.15999755859375 L 0 14.630397033691407 C 5.222400068544256 14.399995422363283 9.484799947778232 12.9407958984375 12.787200400641348 10.252798461914063 C 16.16640024303896 7.487997436523438 18.316799934672144 4.0703979492187505 19.2383994755409 0 L 27.763200759887695 0 L 27.763200759887695 74.64959716796875 L 18.316799171732722 74.64959716796875 Z" 
            fill="rgba(0, 0, 0, 1)" 
            stroke="none" 
            stroke-width="0.43928295373916626"
            fill-rule="nonzero" />
</g></svg></div></div></div></div></div></div>

<!-- Debug Panel -->
<div class="debug-panel">
  <h3>🔍 Debug Info</h3>
  <p><strong>Node Count:</strong> <span id="node-count">Loading...</span></p>
  <p><strong>Event Handlers:</strong> <span id="event-status">Loading...</span></p>
  <p><strong>Animations:</strong> <span id="animation-status">Loading...</span></p>
  <p><strong>Console:</strong> <span class="success">Open DevTools → Console</span></p>
</div>

<script>

    // Event handling for interactive elements
    console.log('DEBUG: Event handling JavaScript loaded');
    
    // Global function for testing event handlers
    window.handleFigmaEvent = function(eventType, elementId) {
      console.log('DEBUG: Manual event trigger:', eventType, elementId);
      const element = document.querySelector(`[data-figma-id="${elementId}"]`);
      if (element) {
        if (eventType === 'click') {
          element.click();
        } else if (eventType === 'variant-switch') {
          const variantButton = element.querySelector('[data-variant], [data-variant-property-1]');
          if (variantButton) {
            variantButton.click();
          }
        }
      }
    };
    
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DEBUG: DOMContentLoaded event fired');
      
      // Handle variant switching - instant switching only, no animation
      // This is a simple slideshow-like system that switches between variants instantly
      const variantButtons = document.querySelectorAll('[data-variant], [data-variant-property-1]');
      variantButtons.forEach(button => {
        button.addEventListener('click', function() {
          console.log('DEBUG: Variant switch clicked');
          
          const variant = this.getAttribute('data-variant') || this.getAttribute('data-variant-property-1');
          const targetId = this.getAttribute('data-target');
          
          if (targetId) {
            const target = document.querySelector(`[data-figma-id="${targetId}"]`);
            if (target) {
              console.log('Variant switch:', { variant, targetId, targetName: target.getAttribute('data-figma-name') });
              
              // Find the specific component set that contains this button
              let componentSet = target;
              let buttonElement = this;
              
              // Walk up the DOM tree to find the immediate component set parent
              while (buttonElement && buttonElement.parentElement) {
                buttonElement = buttonElement.parentElement;
                if (buttonElement.getAttribute('data-figma-type') === 'COMPONENT_SET') {
                  componentSet = buttonElement;
                  console.log('Found component set for switching:', {
                    id: componentSet.getAttribute('data-figma-id'),
                    name: componentSet.getAttribute('data-figma-name')
                  });
                  break;
                }
              }
              
              // Get all variants within this specific component set instance
              const allVariants = Array.from(componentSet.children).filter(child => 
                child.getAttribute('data-figma-type') === 'COMPONENT' &&
                (child.getAttribute('data-variant') || child.getAttribute('data-variant-property-1'))
              );
              
              console.log('Found', allVariants.length, 'variants in component set:', componentSet.getAttribute('data-figma-id'));
              
              // INSTANT VARIANT SWITCHING - Hide all variants
              allVariants.forEach(variant => {
                variant.classList.add('variant-hidden');
                variant.classList.remove('variant-active');
                // Ensure all variants maintain their original positioning (relative with 0px)
                variant.style.position = 'relative';
                variant.style.top = '0px';
                variant.style.left = '0px';
                console.log('Hidden variant:', variant.getAttribute('data-figma-id'));
              });
              
              // Show selected variant instantly
              const selectedVariant = allVariants.find(v => 
                v.getAttribute('data-variant') === variant || 
                v.getAttribute('data-variant-property-1') === variant
              );
              
              if (selectedVariant) {
                selectedVariant.classList.add('variant-active');
                selectedVariant.classList.remove('variant-hidden');
                // Ensure selected variant maintains its original positioning
                selectedVariant.style.position = 'relative';
                selectedVariant.style.top = '0px';
                selectedVariant.style.left = '0px';
                console.log('Switched to variant:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));
                
                // Start timeout reactions for the newly active variant
                startTimeoutReactionsForNewlyActiveVariant(selectedVariant);
                startTimeoutReactionsForNestedComponents(selectedVariant);
              } else {
                console.log('Selected variant not found:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));
              }
            }
          }
        });
      });
  
      
      // Handle reactions - click, press, and drag
      const reactionElements = document.querySelectorAll('[data-has-reactions="true"]');
      reactionElements.forEach(element => {
        const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
        const actionType = element.getAttribute('data-reaction-action-type');
        const destinationId = element.getAttribute('data-reaction-destination');
        const transitionType = element.getAttribute('data-reaction-transition-type');
        const transitionDuration = element.getAttribute('data-reaction-transition-duration');
        
        // Handle click, press, and drag reactions
        element.addEventListener('click', function() {
          console.log('DEBUG: Click event triggered on element:', {
            id: this.getAttribute('data-figma-id'),
            name: this.getAttribute('data-figma-name'),
            type: this.getAttribute('data-figma-type'),
            trigger: trigger,
            actionType: actionType,
            destinationId: destinationId,
            transitionType: transitionType,
            transitionDuration: transitionDuration
          });
          
          if (trigger.type === 'ON_CLICK' || trigger.type === 'ON_PRESS') {
            console.log('DEBUG: Processing click reaction for element:', this.getAttribute('data-figma-id'));
            handleReaction(this, destinationId, transitionType, transitionDuration);
          }
        });
        
        // Handle drag reactions
        element.addEventListener('mousedown', function() {
          if (trigger.type === 'ON_DRAG') {
            handleReaction(this, destinationId, transitionType, transitionDuration);
          }
        });
      });
  
      
      // Track which variants have active timers (for preventing duplicate timers during the same activation)
      const activeTimers = new Map(); // elementId -> timeoutId
      
      // Function to start timeout reactions for active variants
      function startTimeoutReactionsForActiveVariants() {
        // Look for both variant-active elements with reactions AND any elements with reactions that don't have variant properties
        const activeVariants = document.querySelectorAll('.variant-active[data-has-reactions="true"]');
        const reactionElements = document.querySelectorAll('[data-has-reactions="true"]');
        
        console.log('DEBUG: Found', activeVariants.length, 'active variants with reactions');
        console.log('DEBUG: Found', reactionElements.length, 'total elements with reactions');
        
        // Process active variants first
        activeVariants.forEach(element => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          const parentComponent = element.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing variant:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for variants that are actually visible (not hidden by CSS)
          const computedStyle = window.getComputedStyle(element);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
            const actionType = element.getAttribute('data-reaction-action-type');
            const destinationId = element.getAttribute('data-reaction-destination');
            const transitionType = element.getAttribute('data-reaction-transition-type');
            const transitionDuration = element.getAttribute('data-reaction-transition-duration');
            
            // Handle timeout reactions only for active variants that don't have an active timer
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId); // Clear the timer when it completes
                handleReaction(element, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
          }
        });
        
        // Also process any reaction elements that don't have variant properties (like 6461:693)
        reactionElements.forEach(element => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          
          // Skip if this element was already processed as a variant
          if (element.classList.contains('variant-active')) {
            return;
          }
          
          // Skip if this element has variant properties (it will be handled by variant logic)
          if (element.hasAttribute('data-variant-property-1')) {
            return;
          }
          
          const parentComponent = element.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing non-variant reaction element:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for elements that are actually visible (not hidden by CSS)
          const computedStyle = window.getComputedStyle(element);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
            const actionType = element.getAttribute('data-reaction-action-type');
            const destinationId = element.getAttribute('data-reaction-destination');
            const transitionType = element.getAttribute('data-reaction-transition-type');
            const transitionDuration = element.getAttribute('data-reaction-transition-duration');
            
            // Handle timeout reactions only for elements that don't have an active timer
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId); // Clear the timer when it completes
                handleReaction(element, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
          }
        });
      }
      
      // Function to start timeout reactions for nested components when their parent becomes visible
      function startTimeoutReactionsForNestedComponents(parentElement) {
        if (!parentElement) return;
        
        // Find all nested components with timeout reactions within the parent
        const nestedComponents = parentElement.querySelectorAll('[data-has-reactions="true"][data-reaction-trigger*="AFTER_TIMEOUT"]');
        
        nestedComponents.forEach(component => {
          const elementId = component.getAttribute('data-figma-id');
          const elementName = component.getAttribute('data-figma-name');
          const parentComponent = component.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing nested component:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for nested components that are actually visible
          const computedStyle = window.getComputedStyle(component);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(component.getAttribute('data-reaction-trigger') || '{}');
            
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId);
                const actionType = component.getAttribute('data-reaction-action-type');
                const destinationId = component.getAttribute('data-reaction-destination');
                const transitionType = component.getAttribute('data-reaction-transition-type');
                const transitionDuration = component.getAttribute('data-reaction-transition-duration');
                handleReaction(component, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');
          }
        });
      }
      
      // Function to start timeout reactions for a specific newly active variant
      function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {
        if (!newlyActiveElement) return;
        
        const elementId = newlyActiveElement.getAttribute('data-figma-id');
        const elementName = newlyActiveElement.getAttribute('data-figma-name');
        const parentComponent = newlyActiveElement.closest('[data-figma-type="COMPONENT_SET"]');
        const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
        
        console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);
        
        // Only start timers for variants that are actually visible (not hidden by CSS)
        const computedStyle = window.getComputedStyle(newlyActiveElement);
        
        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
          const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');
          const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');
          const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');
          const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');
          const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');
          
          // Handle timeout reactions only for active variants that don't have an active timer
          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
            console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
            const timeoutId = setTimeout(() => {
              activeTimers.delete(elementId); // Clear the timer when it completes
              handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);
            }, (trigger.timeout || 0) * 1000);
            activeTimers.set(elementId, timeoutId);
          } else if (activeTimers.has(elementId)) {
            console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');
          }
          
          // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant
          startTimeoutReactionsForNestedComponents(newlyActiveElement);
        } else {
          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
        }
      }
      
      // CRITICAL FIX: Only start timeout reactions for the initial visible variant
      // Instead of starting timers for all variant-active elements immediately,
      // we wait for the first variant transition or user interaction
      function startTimeoutReactionsForInitialVariant() {
        // Find the first visible variant that should start the flow
        // This is typically the first variant in a component set that's marked as active
        const componentSets = document.querySelectorAll('[data-figma-type="COMPONENT_SET"]');
        console.log('DEBUG: Found', componentSets.length, 'component sets');
        
        // Also check for any elements with reactions
        const allReactionElements = document.querySelectorAll('[data-has-reactions="true"]');
        console.log('DEBUG: Found', allReactionElements.length, 'total elements with reactions');
        
        // Log details about reaction elements
        allReactionElements.forEach((element, index) => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
          const computedStyle = window.getComputedStyle(element);
          
          console.log('DEBUG: Reaction element', index + 1, ':', {
            id: elementId,
            name: elementName,
            trigger: trigger,
            display: computedStyle.display,
            visibility: computedStyle.visibility,
            isActive: element.classList.contains('variant-active'),
            isHidden: element.classList.contains('variant-hidden')
          });
        });
        
        componentSets.forEach(componentSet => {
          const componentSetName = componentSet.getAttribute('data-figma-name');
          const activeVariants = componentSet.querySelectorAll('.variant-active[data-has-reactions="true"]');
          console.log('DEBUG: Component set', componentSetName, 'has', activeVariants.length, 'active variants with reactions');
          
          // Only start timers for the first active variant in each component set
          if (activeVariants.length > 0) {
            const firstActiveVariant = activeVariants[0];
            const elementId = firstActiveVariant.getAttribute('data-figma-id');
            const elementName = firstActiveVariant.getAttribute('data-figma-name');
            const computedStyle = window.getComputedStyle(firstActiveVariant);
            
            console.log('DEBUG: Processing initial variant:', elementId, 'name:', elementName, 'in component set:', componentSetName);
            
            // Only start timer if the variant is actually visible
            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
              const trigger = JSON.parse(firstActiveVariant.getAttribute('data-reaction-trigger') || '{}');
              
              // Skip nested components that should only start when their parent becomes visible
              // Allow independent components to start their timers on page load
              // Check if this component set is nested within another component set
              const parentComponentSet = componentSet.closest('[data-figma-type="COMPONENT_SET"]');
              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;
              
              if (isNestedComponent) {
                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');
                return;
              }
              
              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
                console.log('DEBUG: Starting initial timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);
                const timeoutId = setTimeout(() => {
                  console.log('DEBUG: Timeout triggered for element:', elementId, 'name:', elementName);
                  activeTimers.delete(elementId);
                  const actionType = firstActiveVariant.getAttribute('data-reaction-action-type');
                  const destinationId = firstActiveVariant.getAttribute('data-reaction-destination');
                  const transitionType = firstActiveVariant.getAttribute('data-reaction-transition-type');
                  const transitionDuration = firstActiveVariant.getAttribute('data-reaction-transition-duration');
                  console.log('DEBUG: Calling handleReaction with:', {
                    destinationId: destinationId,
                    transitionType: transitionType,
                    transitionDuration: transitionDuration
                  });
                  handleReaction(firstActiveVariant, destinationId, transitionType, transitionDuration);
                }, (trigger.timeout || 0) * 1000);
                activeTimers.set(elementId, timeoutId);
                console.log('DEBUG: Created timeout timer for element:', elementId, 'timeout ID:', timeoutId, 'duration:', (trigger.timeout || 0) * 1000, 'ms');
                
                // CRITICAL FIX: Also start timeout reactions for any nested components within this initial variant
                startTimeoutReactionsForNestedComponents(firstActiveVariant);
              } else {
                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- no timeout trigger or timer already active');
              }
            } else {
              console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
            }
          }
          
          // CRITICAL FIX: Also check for non-variant reaction elements in this component set
          const reactionElements = componentSet.querySelectorAll('[data-has-reactions="true"]');
          reactionElements.forEach(element => {
            const elementId = element.getAttribute('data-figma-id');
            const elementName = element.getAttribute('data-figma-name');
            
            // Skip if this element was already processed as a variant
            if (element.classList.contains('variant-active')) {
              return;
            }
            
            // Skip if this element has variant properties (it will be handled by variant logic)
            if (element.hasAttribute('data-variant-property-1')) {
              return;
            }
            
            const computedStyle = window.getComputedStyle(element);
            
            console.log('DEBUG: Processing initial non-variant reaction element:', elementId, 'name:', elementName, 'in component set:', componentSetName);
            
            // Only start timer if the element is actually visible
            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
              const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
              
              // Skip nested components that should only start when their parent becomes visible
              const parentComponentSet = componentSet.closest('[data-figma-type="COMPONENT_SET"]');
              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;
              
              if (isNestedComponent) {
                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');
                return;
              }
              
              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
                console.log('DEBUG: Starting initial timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);
                const timeoutId = setTimeout(() => {
                  activeTimers.delete(elementId);
                  const actionType = element.getAttribute('data-reaction-action-type');
                  const destinationId = element.getAttribute('data-reaction-destination');
                  const transitionType = element.getAttribute('data-reaction-transition-type');
                  const transitionDuration = element.getAttribute('data-reaction-transition-duration');
                  handleReaction(element, destinationId, transitionType, transitionDuration);
                }, (trigger.timeout || 0) * 1000);
                activeTimers.set(elementId, timeoutId);
                
                // Also start timeout reactions for any nested components within this element
                startTimeoutReactionsForNestedComponents(element);
              } else {
                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- no timeout trigger or timer already active');
              }
            } else {
              console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
            }
          });
        });
      }
      
      // Start timeout reactions for the initial visible variant after a short delay
      // to ensure CSS classes and visibility are properly applied
      console.log('DEBUG: Setting up initial timeout reactions');
      setTimeout(() => {
        console.log('DEBUG: Starting initial timeout reactions');
        startTimeoutReactionsForInitialVariant();
      }, 100);
  
      
      // Helper function to find elements with property changes between variants
      function findElementsWithPropertyChanges(targetVariant, currentVariant) {
        console.log('DEBUG: findElementsWithPropertyChanges called');
        console.log('  Target variant ID:', targetVariant.getAttribute('data-figma-id'), 'Name:', targetVariant.getAttribute('data-figma-name'));
        console.log('  Current variant ID:', currentVariant.getAttribute('data-figma-id'), 'Name:', currentVariant.getAttribute('data-figma-name'));
        
        if (!currentVariant) {
          console.log('DEBUG: No current variant provided, returning empty array');
          return [];
        }
        
        const targetElements = targetVariant.querySelectorAll('[data-figma-id]');
        const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');
        const sourceElementMap = new Map();
        const elementsToAnimate = [];

        console.log('DEBUG: Found', targetElements.length, 'target elements and', sourceElements.length, 'source elements');

        // Build source element map by name
        sourceElements.forEach(function(sourceElement) {
          const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');
          if (sourceName) {
            sourceElementMap.set(sourceName, sourceElement);
            console.log('  Mapped source element:', sourceName, '->', sourceElement.getAttribute('data-figma-id'));
          }
        });

        // Analyze each target element for property changes
        targetElements.forEach(function(element, index) {
          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
          const sourceElement = sourceElementMap.get(targetName);
          
          console.log('DEBUG: Analyzing target element ' + (index + 1) + ':', targetName);
          console.log('  Target element ID:', element.getAttribute('data-figma-id'));
          console.log('  Source element found:', !!sourceElement);
          
          if (sourceElement) {
            console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));
            const changes = detectPropertyChanges(element, sourceElement);
            
            if (changes.hasChanges) {
              elementsToAnimate.push({
                element: sourceElement,  // Use SOURCE element (from copy) instead of target
                sourceElement: sourceElement,
                changes: changes
              });
              console.log('DEBUG: Found element with property changes:', targetName, 'changes:', changes);
            } else {
              console.log('DEBUG: No changes detected for element:', targetName);
            }
          } else {
            console.log('DEBUG: No matching source element found for:', targetName);
          }
        });
        
        console.log('DEBUG: Returning', elementsToAnimate.length, 'elements to animate');
        return elementsToAnimate;
      }

      // Helper function to detect property changes between elements
      function detectPropertyChanges(targetElement, sourceElement) {
        const changes = {
          hasChanges: false,
          positionX: { changed: false, sourceValue: null, targetValue: null },
          positionY: { changed: false, sourceValue: null, targetValue: null },
          backgroundColor: { changed: false, sourceValue: null, targetValue: null },
          color: { changed: false, sourceValue: null, targetValue: null },
          justifyContent: { changed: false, sourceValue: null, targetValue: null },
          alignItems: { changed: false, sourceValue: null, targetValue: null }
        };

        try {
          // Check position changes by comparing the computed styles
          const sourceStyle = window.getComputedStyle(sourceElement);
          const targetStyle = window.getComputedStyle(targetElement);
          
          // Check left position changes - use Figma data attributes for more accurate positioning
          const sourceLeft = parseFloat(sourceStyle.left) || 0;
          const targetLeft = parseFloat(targetStyle.left) || 0;
          
          // Get Figma position data for more accurate target positioning
          const sourceFigmaX = parseFloat(sourceElement.getAttribute('data-figma-x')) || 0;
          const targetFigmaX = parseFloat(targetElement.getAttribute('data-figma-x')) || 0;
          
          // CRITICAL FIX: Check if the source element has a transform applied from a previous animation
          // If so, we need to account for that in the position calculation
          const sourceTransform = sourceStyle.transform;
          let sourceTransformOffset = 0;
          if (sourceTransform && sourceTransform !== 'none') {
            // Extract translateX value from transform matrix
            const matrix = new DOMMatrix(sourceTransform);
            sourceTransformOffset = matrix.m41; // m41 is the translateX value
            console.log('DEBUG: Source element has transform:', sourceTransform, 'translateX offset:', sourceTransformOffset);
          }
          
          // Log detailed information about the elements
          const sourceName = sourceElement.getAttribute('data-figma-name');
          const targetName = targetElement.getAttribute('data-figma-name');
          const sourceId = sourceElement.getAttribute('data-figma-id');
          const targetId = targetElement.getAttribute('data-figma-id');
          
          console.log('DEBUG: Analyzing elements:');
          console.log('  Source:', sourceName, 'ID:', sourceId, 'Left:', sourceLeft, 'FigmaX:', sourceFigmaX);
          console.log('  Target:', targetName, 'ID:', targetId, 'Left:', targetLeft, 'FigmaX:', targetFigmaX);
          
          // Log parent container dimensions
          const sourceContainer = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          const targetContainer = targetElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          
          if (sourceContainer) {
            const sourceContainerRect = sourceContainer.getBoundingClientRect();
            console.log('  Source container dimensions:', sourceContainerRect.width, 'x', sourceContainerRect.height);
          }
          
          if (targetContainer) {
            const targetContainerRect = targetContainer.getBoundingClientRect();
            console.log('  Target container dimensions:', targetContainerRect.width, 'x', targetContainerRect.height);
          }
          
          // Log viewport dimensions
          console.log('  Viewport dimensions:', window.innerWidth, 'x', window.innerHeight);
          
          // Log element dimensions
          const sourceRect = sourceElement.getBoundingClientRect();
          const targetRect = targetElement.getBoundingClientRect();
          console.log('  Source element dimensions:', sourceRect.width, 'x', sourceRect.height);
          console.log('  Target element dimensions:', targetRect.width, 'x', targetRect.height);
          
          // Check if target element is properly rendered
          if (targetRect.width === 0 && targetRect.height === 0) {
            console.log('DEBUG: Target element has zero dimensions, skipping animation');
            return changes;
          }
          
          // CRITICAL FIX: Use current computed position for source if element has been animated
          // This ensures we detect changes from the actual current position, not the original Figma position
          const sourceHasBeenAnimated = sourceElement.style.position === 'absolute' && 
                                       (sourceElement.style.left || sourceElement.style.top);
          
          // Calculate target position by scaling Figma coordinates to actual rendered size
          // Use SOURCE element's parent (copy) for scaling since we're animating the copy
          const sourceContainerForScaling = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          const targetContainerForScaling = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          
          let finalTargetLeft = 0; // Start with 0, will be calculated below
          let finalTargetTop = 0; // Start with 0, will be calculated below
          // Always use computed styles for consistency
          let finalSourceLeft = parseFloat(sourceStyle.left) || 0;
          let finalSourceTop = parseFloat(sourceStyle.top) || 0;
          
          // Add transform offset if present
          finalSourceLeft += sourceTransformOffset;
          
          // Check if the source element has a transform applied from a previous animation
          // If so, we need to account for that in the position calculation
          let sourceTransformYOffset = 0;
          if (sourceTransform && sourceTransform !== 'none') {
            // Extract translateY value from transform matrix
            const matrix = new DOMMatrix(sourceTransform);
            sourceTransformYOffset = matrix.m42; // m42 is the translateY value
            console.log('DEBUG: Source element has transform:', sourceTransform, 'translateY offset:', sourceTransformYOffset);
          }
          
          // Add transform offset if present
          finalSourceTop += sourceTransformYOffset;
          
          // STEP 1-2: Query source and target to observe value differences
          // Check for alignment/justify differences between source and target parents
          const sourceParent = sourceElement.parentElement;
          const targetParent = targetElement.parentElement;
          
          if (sourceParent && targetParent) {
            const sourceParentStyle = window.getComputedStyle(sourceParent);
            const targetParentStyle = window.getComputedStyle(targetParent);
            
            const sourceJustifyContent = sourceParentStyle.justifyContent;
            const targetJustifyContent = targetParentStyle.justifyContent;
            const sourceAlignItems = sourceParentStyle.alignItems;
            const targetAlignItems = targetParentStyle.alignItems;
            
            console.log('DEBUG: Alignment analysis:', {
              sourceJustifyContent,
              targetJustifyContent,
              sourceAlignItems,
              targetAlignItems,
              sourceElementId: sourceElement.getAttribute('data-figma-id'),
              targetElementId: targetElement.getAttribute('data-figma-id')
            });
            
            // STEP 3: If there's an alignment/justify difference, it's ultimately a position change
            const hasJustifyChange = sourceJustifyContent !== targetJustifyContent;
            const hasAlignChange = sourceAlignItems !== targetAlignItems;
            
            if (hasJustifyChange || hasAlignChange) {
              console.log('DEBUG: Alignment/justify change detected - calculating position difference');
              
              // STEP 4: Query the corresponding nodes in source and target to find absolute/computed position
              const sourceRect = sourceElement.getBoundingClientRect();
              const targetRect = targetElement.getBoundingClientRect();
              const sourceParentRect = sourceParent.getBoundingClientRect();
              const targetParentRect = targetParent.getBoundingClientRect();
              
              // Calculate relative positions within their containers
              const sourceRelativeLeft = sourceRect.left - sourceParentRect.left;
              const targetRelativeLeft = targetRect.left - targetParentRect.left;
              const sourceRelativeTop = sourceRect.top - sourceParentRect.top;
              const targetRelativeTop = targetRect.top - targetParentRect.top;
              
              console.log('DEBUG: Position analysis:', {
                sourceRelativeLeft,
                targetRelativeLeft,
                sourceRelativeTop,
                targetRelativeTop,
                xDifference: Math.abs(sourceRelativeLeft - targetRelativeLeft),
                yDifference: Math.abs(sourceRelativeTop - targetRelativeTop)
              });
              
              // STEP 5: Calculate position difference
              const xDifference = targetRelativeLeft - sourceRelativeLeft;
              const yDifference = targetRelativeTop - sourceRelativeTop;
              
              // STEP 6: Set up animation values
              if (Math.abs(xDifference) > 1) {
                finalTargetLeft = finalSourceLeft + xDifference;
                console.log('DEBUG: X position change calculated:', {
                  sourceLeft: finalSourceLeft,
                  targetLeft: finalTargetLeft,
                  difference: xDifference,
                  justifyChange: hasJustifyChange ? (sourceJustifyContent + ' -> ' + targetJustifyContent) : 'none'
                });
              }
              
              if (Math.abs(yDifference) > 1) {
                finalTargetTop = finalSourceTop + yDifference;
                console.log('DEBUG: Y position change calculated:', {
                  sourceTop: finalSourceTop,
                  targetTop: finalTargetTop,
                  difference: yDifference,
                  alignChange: hasAlignChange ? (sourceAlignItems + ' -> ' + targetAlignItems) : 'none'
                });
              }
            } else {
              console.log('DEBUG: No alignment/justify changes detected');
              // Fallback to direct position comparison if no alignment changes
              const sourceRect = sourceElement.getBoundingClientRect();
              const targetRect = targetElement.getBoundingClientRect();
              const sourceParentRect = sourceParent.getBoundingClientRect();
              const targetParentRect = targetParent.getBoundingClientRect();
              
              const sourceRelativeLeft = sourceRect.left - sourceParentRect.left;
              const targetRelativeLeft = targetRect.left - targetParentRect.left;
              const sourceRelativeTop = sourceRect.top - sourceParentRect.top;
              const targetRelativeTop = targetRect.top - targetParentRect.top;
              
              finalTargetLeft = targetRelativeLeft;
              finalTargetTop = targetRelativeTop;
            }
          } else {
            console.log('DEBUG: No parent elements found, using fallback calculation');
            finalTargetLeft = parseFloat(targetStyle.left) || 0;
            finalTargetTop = parseFloat(targetStyle.top) || 0;
          }
          
          console.log('DEBUG: X Position Analysis:');
          console.log('  Source has been animated:', sourceHasBeenAnimated);
          console.log('  Source computed left:', sourceLeft, 'Source Figma X:', sourceFigmaX, 'Transform offset:', sourceTransformOffset, 'Final source left:', finalSourceLeft);
          console.log('  Target computed left:', targetLeft, 'Target Figma X:', targetFigmaX, 'Final target left:', finalTargetLeft);
          
          if (Math.abs(finalSourceLeft - finalTargetLeft) > 1) {
            changes.positionX.changed = true;
            changes.positionX.sourceValue = finalSourceLeft;
            changes.positionX.targetValue = finalTargetLeft;
            changes.hasChanges = true;
            console.log('DEBUG: Position X change detected:', finalSourceLeft, '->', finalTargetLeft, '(scaled from Figma coordinates)');
            console.log('DEBUG: Position X change details:');
            console.log('  Source element rect:', sourceElement.getBoundingClientRect());
            console.log('  Target element rect:', targetElement.getBoundingClientRect());
            console.log('  Source element computed style:', window.getComputedStyle(sourceElement).left);
            console.log('  Target element computed style:', window.getComputedStyle(targetElement).left);
          } else {
            console.log('DEBUG: No X position change detected - difference:', Math.abs(finalSourceLeft - finalTargetLeft));
          }
          
          // Y position calculation is now handled in the X position section above
          // where we calculate both X and Y positions together based on alignment changes
          
          console.log('DEBUG: Y Position Analysis:');
          console.log('  Final source top:', finalSourceTop);
          console.log('  Final target top:', finalTargetTop);
          console.log('  Difference:', Math.abs(finalSourceTop - finalTargetTop));
          
          if (Math.abs(finalSourceTop - finalTargetTop) > 1) {
            changes.positionY.changed = true;
            changes.positionY.sourceValue = finalSourceTop;
            changes.positionY.targetValue = finalTargetTop;
            changes.hasChanges = true;
            console.log('DEBUG: Position Y change detected:', finalSourceTop, '->', finalTargetTop);
          } else {
            console.log('DEBUG: No Y position change detected - difference:', Math.abs(finalSourceTop - finalTargetTop));
          }

          // Check style changes - use more specific comparison
          const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          
          if (sourceBg !== targetBg) {
            changes.backgroundColor.changed = true;
            changes.backgroundColor.sourceValue = sourceBg;
            changes.backgroundColor.targetValue = targetBg;
            changes.hasChanges = true;
            console.log('DEBUG: Background color change detected:', sourceBg, '->', targetBg);
          }
          
          if (sourceStyle.color !== targetStyle.color) {
            changes.color.changed = true;
            changes.color.sourceValue = sourceStyle.color;
            changes.color.targetValue = targetStyle.color;
            changes.hasChanges = true;
            console.log('DEBUG: Color change detected:', sourceStyle.color, '->', targetStyle.color);
          }
          
          if (sourceStyle.justifyContent !== targetStyle.justifyContent) {
            changes.justifyContent.changed = true;
            changes.justifyContent.sourceValue = sourceStyle.justifyContent;
            changes.justifyContent.targetValue = targetStyle.justifyContent;
            changes.hasChanges = true;
          }
          
          if (sourceStyle.alignItems !== targetStyle.alignItems) {
            changes.alignItems.changed = true;
            changes.alignItems.sourceValue = sourceStyle.alignItems;
            changes.alignItems.targetValue = targetStyle.alignItems;
            changes.hasChanges = true;
          }
        } catch (error) {
          console.log('DEBUG: Error detecting property changes:', error);
        }

        return changes;
      }
  
      
      // Global transition lock to prevent multiple simultaneous transitions
      let isTransitionInProgress = false;
      let currentTransitionPromise = null;
      
      // Animation types
      const AnimationType = {
        SIMPLE: 'SIMPLE',
        SIZE: 'SIZE', 
        TRANSFORM: 'TRANSFORM'
      };
      
      // Translation conditions
      const TranslationCondition = {
        ABSOLUTE: 'ABSOLUTE',
        RELATIVE_PADDING: 'RELATIVE_PADDING',
        RELATIVE_ALIGNMENT: 'RELATIVE_ALIGNMENT'
      };
      
      // Helper function to determine animation type for a property
      function getAnimationType(property) {
        const simpleProperties = [
          'opacity', 'color', 'backgroundColor', 'cornerRadius', 'borderRadius',
          'fontSize', 'fontWeight', 'textAlign', 'letterSpacing', 'lineHeight'
        ];
        
        const sizeProperties = [
          'width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'
        ];
        
        const transformProperties = [
          'translateX', 'translateY', 'translateZ', 'rotation', 'scale', 'transform'
        ];
        
        if (simpleProperties.includes(property)) {
          return AnimationType.SIMPLE;
        } else if (sizeProperties.includes(property)) {
          return AnimationType.SIZE;
        } else if (transformProperties.includes(property)) {
          return AnimationType.TRANSFORM;
        }
        
        return AnimationType.SIMPLE;
      }
      
      // Helper function to determine translation condition
      function getTranslationCondition(element, node, parentNode) {
        const ignoreAutoLayout = node.layoutPositioning === 'ABSOLUTE';
        
        const parentHasAutoLayout = parentNode && 
                                   parentNode.type === 'FRAME' && 
                                   parentNode.layoutMode && 
                                   parentNode.layoutMode !== 'NONE';
        
        if (ignoreAutoLayout || !parentHasAutoLayout) {
          return TranslationCondition.ABSOLUTE;
        }
        
        if (parentHasAutoLayout) {
          // For now, default to padding-based relative positioning
          // This could be enhanced to detect which type of relative positioning is needed
          return TranslationCondition.RELATIVE_PADDING;
        }
        
        return TranslationCondition.ABSOLUTE;
      }
      
      // Helper function to detect animation changes
      function detectAnimationChanges(sourceElement, targetElement, sourceNode, targetNode, parentNode) {
        const changes = [];
        
        const sourceStyle = window.getComputedStyle(sourceElement);
        const targetStyle = window.getComputedStyle(targetElement);
        
        // Check simple properties
        const simpleProperties = ['opacity', 'backgroundColor', 'color'];
        simpleProperties.forEach(property => {
          const sourceValue = sourceStyle[property];
          const targetValue = targetStyle[property];
          
          if (sourceValue !== targetValue) {
            changes.push({
              type: AnimationType.SIMPLE,
              property,
              sourceValue,
              targetValue,
              changed: true
            });
          }
        });
        
        // Check size properties
        const sizeProperties = ['width', 'height'];
        sizeProperties.forEach(property => {
          const sourceValue = parseFloat(sourceStyle[property]) || 0;
          const targetValue = parseFloat(targetStyle[property]) || 0;
          
          if (Math.abs(sourceValue - targetValue) > 1) {
            changes.push({
              type: AnimationType.SIZE,
              property,
              sourceValue,
              targetValue,
              changed: true
            });
          }
        });
        
        // Check transform properties based on translation condition
        const translationCondition = getTranslationCondition(sourceElement, sourceNode, parentNode);
        
        console.log('DEBUG: Translation condition detected:', translationCondition);
        
        if (translationCondition === TranslationCondition.ABSOLUTE) {
          // Check left/top changes for absolute positioning
          const sourceLeft = parseFloat(sourceStyle.left) || 0;
          const targetLeft = parseFloat(targetStyle.left) || 0;
          const sourceTop = parseFloat(sourceStyle.top) || 0;
          const targetTop = parseFloat(targetStyle.top) || 0;
          
          if (Math.abs(sourceLeft - targetLeft) > 1) {
            changes.push({
              type: AnimationType.TRANSFORM,
              property: 'translateX',
              sourceValue: sourceLeft,
              targetValue: targetLeft,
              changed: true,
              translationCondition
            });
          }
          
          if (Math.abs(sourceTop - targetTop) > 1) {
            changes.push({
              type: AnimationType.TRANSFORM,
              property: 'translateY',
              sourceValue: sourceTop,
              targetValue: targetTop,
              changed: true,
              translationCondition
            });
          }
        } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {
          // Check parent padding changes
          const sourceParent = sourceElement.parentElement;
          const targetParent = targetElement.parentElement;
          
          if (sourceParent && targetParent) {
            const sourceParentStyle = window.getComputedStyle(sourceParent);
            const targetParentStyle = window.getComputedStyle(targetParent);
            
            const paddingProperties = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'];
            paddingProperties.forEach(property => {
              const sourceValue = parseFloat(sourceParentStyle[property]) || 0;
              const targetValue = parseFloat(targetParentStyle[property]) || 0;
              
              if (Math.abs(sourceValue - targetValue) > 1) {
                changes.push({
                  type: AnimationType.TRANSFORM,
                  property: `parent_${property}`,
                  sourceValue,
                  targetValue,
                  changed: true,
                  translationCondition
                });
              }
            });
          }
        } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {
          // Check parent alignment changes - ENHANCED FOR JUSTIFYCONTENT
          const sourceParent = sourceElement.parentElement;
          const targetParent = targetElement.parentElement;
          
          if (sourceParent && targetParent) {
            const sourceParentStyle = window.getComputedStyle(sourceParent);
            const targetParentStyle = window.getComputedStyle(targetParent);
            
            // Check alignment properties with detailed logging
            const alignmentProperties = ['justifyContent', 'alignItems', 'textAlign', 'verticalAlign'];
            
            console.log('DEBUG: Checking alignment properties for RELATIVE_ALIGNMENT');
            
            alignmentProperties.forEach(property => {
              const sourceValue = sourceParentStyle[property];
              const targetValue = targetParentStyle[property];
              
              console.log(`DEBUG: Parent ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });
              
              if (sourceValue !== targetValue) {
                changes.push({
                  type: AnimationType.TRANSFORM,
                  property: `parent_${property}`,
                  sourceValue: sourceValue || '',
                  targetValue: targetValue || '',
                  changed: true,
                  translationCondition
                });
              }
            });
            
            // Check element's own alignment properties
            alignmentProperties.forEach(property => {
              const sourceValue = sourceStyle[property];
              const targetValue = targetStyle[property];
              
              console.log(`DEBUG: Element ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });
              
              if (sourceValue !== targetValue) {
                changes.push({
                  type: AnimationType.TRANSFORM,
                  property: property,
                  sourceValue: sourceValue || '',
                  targetValue: targetValue || '',
                  changed: true,
                  translationCondition
                });
              }
            });
            
            // Check for flexbox-specific properties
            const flexProperties = ['flexDirection', 'flexWrap', 'alignContent', 'justifyItems'];
            flexProperties.forEach(property => {
              const sourceValue = sourceParentStyle[property];
              const targetValue = targetParentStyle[property];
              
              console.log(`DEBUG: Flex ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });
              
              if (sourceValue !== targetValue) {
                changes.push({
                  type: AnimationType.TRANSFORM,
                  property: `parent_${property}`,
                  sourceValue: sourceValue || '',
                  targetValue: targetValue || '',
                  changed: true,
                  translationCondition
                });
              }
            });
            
            // Check for position changes that might be due to alignment
            // Even if alignment values are the same, the computed position might differ
            const sourceRect = sourceElement.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();
            const sourceParentRect = sourceParent.getBoundingClientRect();
            const targetParentRect = targetParent.getBoundingClientRect();
            
            // Calculate relative positions within their containers
            const sourceRelativeX = sourceRect.left - sourceParentRect.left;
            const targetRelativeX = targetRect.left - targetParentRect.left;
            const sourceRelativeY = sourceRect.top - sourceParentRect.top;
            const targetRelativeY = targetRect.top - targetParentRect.top;
            
            console.log('DEBUG: Relative position analysis:', {
              sourceRelativeX,
              targetRelativeX,
              sourceRelativeY,
              targetRelativeY,
              xDifference: Math.abs(sourceRelativeX - targetRelativeX),
              yDifference: Math.abs(sourceRelativeY - targetRelativeY)
            });
            
            // If there's a significant position difference, it might be due to alignment
            if (Math.abs(sourceRelativeX - targetRelativeX) > 1) {
              changes.push({
                type: AnimationType.TRANSFORM,
                property: 'alignTranslateX',
                sourceValue: sourceRelativeX,
                targetValue: targetRelativeX,
                changed: true,
                translationCondition
              });
            }
            
            if (Math.abs(sourceRelativeY - targetRelativeY) > 1) {
              changes.push({
                type: AnimationType.TRANSFORM,
                property: 'alignTranslateY',
                sourceValue: sourceRelativeY,
                targetValue: targetRelativeY,
                changed: true,
                translationCondition
              });
            }
          }
        }
        
        console.log('DEBUG: Total changes detected:', changes.length, changes);
        return changes;
      }
      
      // Helper function to apply animation changes
      function applyAnimationChange(element, change, duration, easing) {
        const { type, property, targetValue, translationCondition, destination } = change;
        
        console.log('DEBUG: Applying animation change:', { type, property, targetValue, translationCondition });
        
        // Get transition property
        let transitionProperty = property;
        if (type === AnimationType.TRANSFORM) {
          if (translationCondition === TranslationCondition.ABSOLUTE) {
            transitionProperty = property === 'translateX' ? 'left' : 'top';
          } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {
            transitionProperty = property.replace('parent_', '');
          } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {
            if (property === 'alignTranslateX' || property === 'alignTranslateY') {
              transitionProperty = property === 'alignTranslateX' ? 'left' : 'top';
            } else if (property.startsWith('parent_')) {
              // For alignment changes, animate the element's position instead of the parent's alignment
              if (property === 'parent_justifyContent') {
                // Use the target element's actual position from the destination variant
                const sourceElementName = element.getAttribute('data-figma-name');
                const targetElement = destination.querySelector(`[data-figma-name="${sourceElementName}"]`);
                
                if (targetElement) {
                  const targetRect = targetElement.getBoundingClientRect();
                  const parent = element.parentElement;
                  const parentRect = parent.getBoundingClientRect();
                  
                  // Calculate the target position relative to the parent
                  const targetLeft = targetRect.left - parentRect.left;
                  
                  console.log('DEBUG: Calculating justifyContent animation using target position:', {
                    currentLeft: element.getBoundingClientRect().left - parentRect.left,
                    targetLeft: targetLeft,
                    targetElementId: targetElement.getAttribute('data-figma-id'),
                    targetElementName: sourceElementName,
                    justifyContent: targetValue
                  });
                  
                  // Set transition for left position
                  element.style.transition = `left ${duration}s ${easing}`;
                  element.style.left = `${targetLeft}px`;
                  
                  console.log('DEBUG: Applied justifyContent animation via target position:', {
                    property: 'left',
                    transitionProperty: 'left',
                    targetValue: `${targetLeft}px`
                  });
                  
                  return; // Skip the default handling
                } else {
                  console.log('DEBUG: Target element not found in destination by name:', sourceElementName);
                }
              } else if (property === 'parent_alignItems') {
                // Use the target element's actual position from the destination variant
                const sourceElementName = element.getAttribute('data-figma-name');
                const targetElement = destination.querySelector(`[data-figma-name="${sourceElementName}"]`);
                
                if (targetElement) {
                  const targetRect = targetElement.getBoundingClientRect();
                  const parent = element.parentElement;
                  const parentRect = parent.getBoundingClientRect();
                  
                  // Calculate the target position relative to the parent
                  const targetTop = targetRect.top - parentRect.top;
                  
                  console.log('DEBUG: Calculating alignItems animation using target position:', {
                    currentTop: element.getBoundingClientRect().top - parentRect.top,
                    targetTop: targetTop,
                    targetElementId: targetElement.getAttribute('data-figma-id'),
                    targetElementName: sourceElementName,
                    alignItems: targetValue
                  });
                  
                  // Set transition for top position
                  element.style.transition = `top ${duration}s ${easing}`;
                  element.style.top = `${targetTop}px`;
                  
                  console.log('DEBUG: Applied alignItems animation via target position:', {
                    property: 'top',
                    transitionProperty: 'top',
                    targetValue: `${targetTop}px`
                  });
                  
                  return; // Skip the default handling
                } else {
                  console.log('DEBUG: Target element not found in destination by name:', sourceElementName);
                }
              }
              transitionProperty = property.replace('parent_', '');
            } else {
              transitionProperty = property;
            }
          }
        }
        
        // Set up transition
        element.style.transition = `${transitionProperty} ${duration}s ${easing}`;
        
        // Apply the change based on type and condition
        switch (type) {
          case AnimationType.SIMPLE:
            element.style[property] = targetValue;
            break;
            
          case AnimationType.SIZE:
            element.style[property] = `${targetValue}px`;
            break;
            
          case AnimationType.TRANSFORM:
            if (translationCondition === TranslationCondition.ABSOLUTE) {
              if (property === 'translateX') {
                element.style.left = `${targetValue}px`;
              } else if (property === 'translateY') {
                element.style.top = `${targetValue}px`;
              }
            } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {
              if (element.parentElement) {
                const paddingProperty = property.replace('parent_', '');
                element.parentElement.style[paddingProperty] = `${targetValue}px`;
              }
            } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {
              if (property === 'alignTranslateX') {
                element.style.left = `${targetValue}px`;
              } else if (property === 'alignTranslateY') {
                element.style.top = `${targetValue}px`;
              } else if (property.startsWith('parent_')) {
                if (element.parentElement) {
                  const alignmentProperty = property.replace('parent_', '');
                  element.parentElement.style[alignmentProperty] = targetValue;
                }
              } else {
                // Direct property change on the element
                element.style[property] = targetValue;
              }
            }
            break;
        }
        
        console.log('DEBUG: Applied change:', { property, transitionProperty, targetValue });
      }
      
      // Helper function to get easing function
      function getEasingFunction(animationType) {
        switch (animationType) {
          case 'EASE_IN_AND_OUT_BACK':
            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';
          case 'EASE_IN_AND_OUT':
            return 'ease-in-out';
          case 'EASE_IN':
            return 'ease-in';
          case 'EASE_OUT':
            return 'ease-out';
          case 'LINEAR':
            return 'linear';
          case 'BOUNCY':
            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';
          case 'GENTLE':
            return 'ease-in-out';
          case 'SMART_ANIMATE':
            return 'ease-in-out';
          default:
            return 'ease-out';
        }
      }
      
      // Helper function to create element copy
      function createElementCopy(sourceElement) {
        console.log('DEBUG: createElementCopy function called');
        console.log('DEBUG: Creating element copy for:', sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id'));
        
        const copy = sourceElement.cloneNode(true);
        copy.setAttribute('data-figma-id', sourceElement.getAttribute('data-figma-id') + '-copy');
        copy.setAttribute('data-is-animation-copy', 'true');
        
        // Preserve current positions from source element
        const copyElements = copy.querySelectorAll('*');
        copyElements.forEach(element => {
          if (element.hasAttribute('data-figma-id')) {
            const sourceElementId = element.getAttribute('data-figma-id');
            const sourceElementMatch = sourceElement.querySelector(`[data-figma-id="${sourceElementId}"]`);
            
            if (sourceElementMatch) {
              const currentLeft = sourceElementMatch.style.left || window.getComputedStyle(sourceElementMatch).left || '0px';
              const currentTop = sourceElementMatch.style.top || window.getComputedStyle(sourceElementMatch).top || '0px';
              
              element.style.position = 'relative';
              element.style.left = currentLeft;
              element.style.top = currentTop;
              
              element.style.removeProperty('transform');
              element.style.removeProperty('margin');
              element.style.removeProperty('padding');
              
              element.style.setProperty('left', currentLeft, 'important');
              element.style.setProperty('top', currentTop, 'important');
            } else {
              element.style.position = 'relative';
              element.style.left = '0px';
              element.style.top = '0px';
            }
          }
        });
        
        // Position the copy absolutely over the source element
        const sourceRect = sourceElement.getBoundingClientRect();
        const parentRect = sourceElement.parentElement.getBoundingClientRect();
        
        copy.style.position = 'absolute';
        copy.style.top = (sourceRect.top - parentRect.top) + 'px';
        copy.style.left = (sourceRect.left - parentRect.left) + 'px';
        copy.style.transform = 'none';
        copy.style.margin = '0';
        copy.style.padding = '0';
        
        // Set high z-index
        const allElements = document.querySelectorAll('*');
        let maxZIndex = 0;
        allElements.forEach(el => {
          const zIndex = parseInt(window.getComputedStyle(el).zIndex) || 0;
          if (zIndex > maxZIndex) maxZIndex = zIndex;
        });
        
        const copyZIndex = maxZIndex + 1000;
        copy.style.zIndex = copyZIndex.toString();
        copy.style.pointerEvents = 'none';
        copy.style.transform = 'translateZ(0)';
        copy.style.willChange = 'transform, left, top';
        
        // Ensure the copy container doesn't clip its children
        copy.style.overflow = 'visible';
        
        // Ensure the copy and all its children are fully visible
        copy.style.opacity = '1';
        copy.style.visibility = 'visible';
        copy.style.display = 'flex';

        // Ensure all nested elements in the copy are also visible
        const copyChildren = copy.querySelectorAll('*');
        copyChildren.forEach(child => {
          child.style.opacity = '1';
          child.style.visibility = 'visible';
          child.style.overflow = 'visible';
          if (child.style.display === 'none') {
            child.style.display = 'flex';
          }
        });

        // Debug: Log the initial visibility properties of all nodes in the copy
        console.log('DEBUG: Copy element visibility properties:');
        const nodesWithFigmaId = copy.querySelectorAll('[data-figma-id]');
        console.log('DEBUG: Found', nodesWithFigmaId.length, 'nodes with data-figma-id in copy');
        
        nodesWithFigmaId.forEach((node, index) => {
          const figmaName = node.getAttribute('data-figma-name') || 'Unknown';
          console.log('  Node', index + 1, '(' + figmaName + '):');
          console.log('    opacity:', window.getComputedStyle(node).opacity);
          console.log('    display:', window.getComputedStyle(node).display);
          console.log('    visibility:', window.getComputedStyle(node).visibility);
          console.log('    position:', window.getComputedStyle(node).position);
          console.log('    left:', window.getComputedStyle(node).left);
          console.log('    top:', window.getComputedStyle(node).top);
        });
        
        // Log the opacity and display properties of each node in the copy
        console.log('DEBUG: Copy element visibility properties:');
        const copyNodes = copy.querySelectorAll('[data-figma-id]');
        console.log('DEBUG: Found', copyNodes.length, 'nodes with data-figma-id in copy');
        copyNodes.forEach((node, index) => {
          const nodeName = node.getAttribute('data-figma-name') || node.getAttribute('data-figma-id');
          const computedStyle = window.getComputedStyle(node);
          const opacity = computedStyle.opacity;
          const display = computedStyle.display;
          const visibility = computedStyle.visibility;
          const position = computedStyle.position;
          const left = computedStyle.left;
          const top = computedStyle.top;
          
          console.log('  Node ' + (index + 1) + ' (' + nodeName + '):');
          console.log('    opacity: ' + opacity);
          console.log('    display: ' + display);
          console.log('    visibility: ' + visibility);
          console.log('    position: ' + position);
          console.log('    left: ' + left);
          console.log('    top: ' + top);
        });
        
        console.log('DEBUG: Copy creation completed');
        return copy;
      }
      
      // Helper function to update copy content to match destination
      function updateCopyContentToMatchDestination(copy, destination) {
        console.log('DEBUG: Updating copy content to match destination');
        
        // Get all elements in both copy and destination
        const copyElements = copy.querySelectorAll('[data-figma-id]');
        const destinationElements = destination.querySelectorAll('[data-figma-id]');
        
        // Create a map of destination elements by name
        const destinationElementMap = new Map();
        destinationElements.forEach(element => {
          const name = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
          if (name) {
            destinationElementMap.set(name, element);
          }
        });
        
        // Update each copy element's content to match destination
        copyElements.forEach(copyElement => {
          const copyElementName = copyElement.getAttribute('data-figma-name') || copyElement.getAttribute('data-figma-id');
          const destinationElement = destinationElementMap.get(copyElementName);
          
          console.log('DEBUG: Checking content for', copyElementName);
          console.log('  Copy textContent:', copyElement.textContent);
          console.log('  Copy innerHTML:', copyElement.innerHTML.substring(0, 200));
          if (destinationElement) {
            console.log('  Destination textContent:', destinationElement.textContent);
            console.log('  Destination innerHTML:', destinationElement.innerHTML.substring(0, 200));
          }
          
          if (destinationElement) {
            // Update text content
            if (destinationElement.textContent !== copyElement.textContent) {
              const oldText = copyElement.textContent;
              copyElement.textContent = destinationElement.textContent;
              console.log('DEBUG: Updated text content for', copyElementName, 'from', oldText, 'to', destinationElement.textContent);
            }
            
            // Update innerHTML for more complex content
            if (destinationElement.innerHTML !== copyElement.innerHTML) {
              const oldHTML = copyElement.innerHTML;
              copyElement.innerHTML = destinationElement.innerHTML;
              console.log('DEBUG: Updated innerHTML for', copyElementName, 'from', oldHTML.substring(0, 100), 'to', destinationElement.innerHTML.substring(0, 100));
            }
            
            // Update specific attributes that might contain content
            const contentAttributes = ['data-content', 'data-text', 'title', 'alt'];
            contentAttributes.forEach(attr => {
              const destValue = destinationElement.getAttribute(attr);
              const copyValue = copyElement.getAttribute(attr);
              if (destValue !== copyValue && destValue !== null) {
                copyElement.setAttribute(attr, destValue);
                console.log('DEBUG: Updated attribute', attr, 'for', copyElementName, 'to', destValue);
              }
            });
          }
        });
        
        // Log the visibility properties after content update
        console.log('DEBUG: Copy element visibility properties after content update:');
        const copyNodes = copy.querySelectorAll('[data-figma-id]');
        copyNodes.forEach((node, index) => {
          const nodeName = node.getAttribute('data-figma-name') || node.getAttribute('data-figma-id');
          const computedStyle = window.getComputedStyle(node);
          const opacity = computedStyle.opacity;
          const display = computedStyle.display;
          const visibility = computedStyle.visibility;
          const position = computedStyle.position;
          const left = computedStyle.left;
          const top = computedStyle.top;
          
          console.log('  Node ' + (index + 1) + ' (' + nodeName + '):');
          console.log('    opacity: ' + opacity);
          console.log('    display: ' + display);
          console.log('    visibility: ' + visibility);
          console.log('    position: ' + position);
          console.log('    left: ' + left);
          console.log('    top: ' + top);
        });

        // Ensure all elements in the copy are visible after content update
        const allCopyElements = copy.querySelectorAll('*');
        allCopyElements.forEach(element => {
          element.style.opacity = '1';
          element.style.visibility = 'visible';
          element.style.overflow = 'visible';
          if (element.style.display === 'none') {
            element.style.display = 'flex';
          }
        });
      }
      
      // Helper function to animate copy to destination
      function animateCopyToDestination(copy, destination, transitionType, transitionDuration) {
        return new Promise((resolve) => {
          // Update copy content to match destination content
          updateCopyContentToMatchDestination(copy, destination);
          
          // Find elements with property changes
          const elementsToAnimate = findElementsWithPropertyChanges(destination, copy);
          
          const easingFunction = getEasingFunction(transitionType);
          const duration = parseFloat(transitionDuration || '0.3');
          
          if (elementsToAnimate.length > 0) {
            console.log('DEBUG: Animating copy with', elementsToAnimate.length, 'elements using modular system');
            
            // Setup animation for each element using the changes already detected
            elementsToAnimate.forEach(({ element, sourceElement, changes }) => {
              console.log('DEBUG: Processing element with changes:', changes);
              
              // Convert the detected changes to animation changes
              const animationChanges = [];
              
              // Handle position changes
              if (changes.positionX && changes.positionX.changed) {
                animationChanges.push({
                  type: AnimationType.TRANSFORM,
                  property: 'translateX',
                  sourceValue: changes.positionX.sourceValue,
                  targetValue: changes.positionX.targetValue,
                  changed: true,
                  translationCondition: TranslationCondition.ABSOLUTE
                });
              }
              
              if (changes.positionY && changes.positionY.changed) {
                animationChanges.push({
                  type: AnimationType.TRANSFORM,
                  property: 'translateY',
                  sourceValue: changes.positionY.sourceValue,
                  targetValue: changes.positionY.targetValue,
                  changed: true,
                  translationCondition: TranslationCondition.ABSOLUTE
                });
              }
              
              // Handle color changes
              if (changes.backgroundColor && changes.backgroundColor.changed) {
                animationChanges.push({
                  type: AnimationType.SIMPLE,
                  property: 'backgroundColor',
                  sourceValue: changes.backgroundColor.sourceValue,
                  targetValue: changes.backgroundColor.targetValue,
                  changed: true
                });
              }
              
              if (changes.color && changes.color.changed) {
                animationChanges.push({
                  type: AnimationType.SIMPLE,
                  property: 'color',
                  sourceValue: changes.color.sourceValue,
                  targetValue: changes.color.targetValue,
                  changed: true
                });
              }
              
              // Handle alignment changes
              if (changes.justifyContent && changes.justifyContent.changed) {
                // Calculate the position difference that the alignment change creates
                const parent = element.parentElement;
                if (parent) {
                  const parentRect = parent.getBoundingClientRect();
                  const elementRect = element.getBoundingClientRect();
                  const elementWidth = elementRect.width;
                  
                  // Calculate current position relative to parent
                  const currentLeft = elementRect.left - parentRect.left;
                  
                  // Calculate target position based on alignment change
                  let targetLeft = currentLeft;
                  if (changes.justifyContent.targetValue === 'flex-end') {
                    targetLeft = parentRect.width - elementWidth;
                  } else if (changes.justifyContent.targetValue === 'center') {
                    targetLeft = (parentRect.width - elementWidth) / 2;
                  } else if (changes.justifyContent.targetValue === 'flex-start') {
                    targetLeft = 0;
                  }
                  
                  // Only animate if there's actually a position difference
                  if (Math.abs(currentLeft - targetLeft) > 1) {
                    console.log('DEBUG: Calculating justifyContent position animation:', {
                      currentLeft: currentLeft,
                      targetLeft: targetLeft,
                      justifyContent: changes.justifyContent.targetValue,
                      parentWidth: parentRect.width,
                      elementWidth: elementWidth
                    });
                    
                    // Animate the position, NOT the alignment
                    element.style.transition = `left ${duration}s ${easingFunction}`;
                    element.style.left = `${targetLeft}px`;
                    
                    console.log('DEBUG: Applied justifyContent position animation:', {
                      property: 'left',
                      transitionProperty: 'left',
                      targetValue: `${targetLeft}px`
                    });
                  } else {
                    console.log('DEBUG: JustifyContent change detected but no position difference - skipping animation');
                  }
                  
                  // Don't add to animationChanges array since we're handling it directly
                  return;
                }
              }
              
              if (changes.alignItems && changes.alignItems.changed) {
                // Calculate the position difference that the alignment change creates
                const parent = element.parentElement;
                if (parent) {
                  const parentRect = parent.getBoundingClientRect();
                  const elementRect = element.getBoundingClientRect();
                  const elementHeight = elementRect.height;
                  
                  // Calculate current position relative to parent
                  const currentTop = elementRect.top - parentRect.top;
                  
                  // Calculate target position based on alignment change
                  let targetTop = currentTop;
                  if (changes.alignItems.targetValue === 'flex-end') {
                    targetTop = parentRect.height - elementHeight;
                  } else if (changes.alignItems.targetValue === 'center') {
                    targetTop = (parentRect.height - elementHeight) / 2;
                  } else if (changes.alignItems.targetValue === 'flex-start') {
                    targetTop = 0;
                  }
                  
                  // Only animate if there's actually a position difference
                  if (Math.abs(currentTop - targetTop) > 1) {
                    console.log('DEBUG: Calculating alignItems position animation:', {
                      currentTop: currentTop,
                      targetTop: targetTop,
                      alignItems: changes.alignItems.targetValue,
                      parentHeight: parentRect.height,
                      elementHeight: elementHeight
                    });
                    
                    // Animate the position, NOT the alignment
                    element.style.transition = `top ${duration}s ${easingFunction}`;
                    element.style.top = `${targetTop}px`;
                    
                    console.log('DEBUG: Applied alignItems position animation:', {
                      property: 'top',
                      transitionProperty: 'top',
                      targetValue: `${targetTop}px`
                    });
                  } else {
                    console.log('DEBUG: AlignItems change detected but no position difference - skipping animation');
                  }
                  
                  // Don't add to animationChanges array since we're handling it directly
                  return;
                }
              }
              
              // Note: justifyContent and alignItems changes are handled directly above
              // and only applied if there's an actual position difference
              
              console.log('DEBUG: Converted to animation changes:', animationChanges);
              
                          // Apply each change
            animationChanges.forEach(change => {
              applyAnimationChange(element, change, duration, easingFunction);
            });
          });
          
          // Force reflow
          copy.offsetHeight;
          
          // Log which elements are being animated and their transition properties
          console.log('DEBUG: Elements being animated:');
          elementsToAnimate.forEach(({ element }, index) => {
            const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
            const computedStyle = window.getComputedStyle(element);
            console.log('  Element ' + (index + 1) + ' (' + elementName + '):');
            console.log('    transition: ' + computedStyle.transition);
            console.log('    transform: ' + computedStyle.transform);
            console.log('    left: ' + computedStyle.left);
            console.log('    top: ' + computedStyle.top);
            console.log('    opacity: ' + computedStyle.opacity);
            console.log('    visibility: ' + computedStyle.visibility);
            console.log('    display: ' + computedStyle.display);
          });
          
          // Log the visibility properties after applying animations
          console.log('DEBUG: Copy element visibility properties after applying animations:');
          const copyNodes = copy.querySelectorAll('[data-figma-id]');
          copyNodes.forEach((node, index) => {
            const nodeName = node.getAttribute('data-figma-name') || node.getAttribute('data-figma-id');
            const computedStyle = window.getComputedStyle(node);
            const opacity = computedStyle.opacity;
            const display = computedStyle.display;
            const visibility = computedStyle.visibility;
            const position = computedStyle.position;
            const left = computedStyle.left;
            const top = computedStyle.top;
            const transform = computedStyle.transform;
            
            console.log('  Node ' + (index + 1) + ' (' + nodeName + '):');
            console.log('    opacity: ' + opacity);
            console.log('    display: ' + display);
            console.log('    visibility: ' + visibility);
            console.log('    position: ' + position);
            console.log('    left: ' + left);
            console.log('    top: ' + top);
            console.log('    transform: ' + transform);
          });
            
            // Apply target values
            requestAnimationFrame(() => {
              elementsToAnimate.forEach(({ element, sourceElement, changes }) => {
                // Convert the detected changes to animation changes (same as above)
                const animationChanges = [];
                
                if (changes.positionX && changes.positionX.changed) {
                  animationChanges.push({
                    type: AnimationType.TRANSFORM,
                    property: 'translateX',
                    sourceValue: changes.positionX.sourceValue,
                    targetValue: changes.positionX.targetValue,
                    changed: true,
                    translationCondition: TranslationCondition.ABSOLUTE
                  });
                }
                
                if (changes.positionY && changes.positionY.changed) {
                  animationChanges.push({
                    type: AnimationType.TRANSFORM,
                    property: 'translateY',
                    sourceValue: changes.positionY.sourceValue,
                    targetValue: changes.positionY.targetValue,
                    changed: true,
                    translationCondition: TranslationCondition.ABSOLUTE
                  });
                }
                
                if (changes.backgroundColor && changes.backgroundColor.changed) {
                  animationChanges.push({
                    type: AnimationType.SIMPLE,
                    property: 'backgroundColor',
                    sourceValue: changes.backgroundColor.sourceValue,
                    targetValue: changes.backgroundColor.targetValue,
                    changed: true
                  });
                }
                
                if (changes.color && changes.color.changed) {
                  animationChanges.push({
                    type: AnimationType.SIMPLE,
                    property: 'color',
                    sourceValue: changes.color.sourceValue,
                    targetValue: changes.color.targetValue,
                    changed: true
                  });
                }
                
                // Note: justifyContent and alignItems changes are handled directly above
                // and only applied if there's an actual position difference
                
                animationChanges.forEach(change => {
                  applyAnimationChange(element, change, duration, easingFunction);
                });
              });
            });
            
            // Monitor animation progress using transition end events
            let completedAnimations = 0;
            const totalAnimations = elementsToAnimate.length;
            
            console.log('DEBUG: Setting up animation monitoring for', totalAnimations, 'elements');
            
            // Track which elements have actually been animated and their transition properties
            const animatedElements = new Set();
            const transitionProperties = new Map(); // Track which properties are being transitioned
            
            // Also track which elements have been processed to avoid double-counting
            const processedElements = new Set();
            
            // Log what transitions we expect to see
            elementsToAnimate.forEach(({ element, changes }, index) => {
              const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
              console.log('DEBUG: Expecting transitions for element', index + 1, '(', elementName, '):');
              
              const elementProperties = [];
              
              if (changes.positionX && changes.positionX.changed) {
                console.log('  - positionX transition (left/top)');
                elementProperties.push('left', 'top');
              }
              if (changes.positionY && changes.positionY.changed) {
                console.log('  - positionY transition (left/top)');
                elementProperties.push('left', 'top');
              }
              if (changes.backgroundColor && changes.backgroundColor.changed) {
                console.log('  - backgroundColor transition');
                elementProperties.push('background-color');
              }
              if (changes.color && changes.color.changed) {
                console.log('  - color transition');
                elementProperties.push('color');
              }
              if (changes.justifyContent && changes.justifyContent.changed) {
                console.log('  - justifyContent transition (left)');
                elementProperties.push('left');
              }
              if (changes.alignItems && changes.alignItems.changed) {
                console.log('  - alignItems transition (top)');
                elementProperties.push('top');
              }
              
              // Remove duplicates and set the properties
              const uniqueProperties = [...new Set(elementProperties)];
              transitionProperties.set(element, uniqueProperties);
              console.log('DEBUG: Final transition properties for element', elementName, ':', uniqueProperties);
            });
            
            const onTransitionEnd = (event) => {
              const targetElement = event.target;
              const propertyName = event.propertyName;
              
              console.log('DEBUG: Transition end event fired for:', targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'), 'property:', propertyName);
              
              // Find which element this transition belongs to
              const animatedElement = elementsToAnimate.find(({ element }) => 
                targetElement === element || element.contains(targetElement)
              );
              
              if (animatedElement) {
                const elementKey = animatedElement.element;
                const expectedProperties = transitionProperties.get(elementKey) || [];
                
                console.log('DEBUG: Found matching animated element, expected properties:', expectedProperties);
                
                // Check if this is a property we're expecting to transition
                if (expectedProperties.includes(propertyName)) {
                  // Remove this property from the expected list
                  const updatedProperties = expectedProperties.filter(p => p !== propertyName);
                  transitionProperties.set(elementKey, updatedProperties);
                  
                  console.log('DEBUG: Property', propertyName, 'transition completed, remaining properties for this element:', updatedProperties);
                  
                  // If all properties for this element have completed, mark the element as done
                  if (updatedProperties.length === 0 && !animatedElements.has(elementKey)) {
                    animatedElements.add(elementKey);
                    completedAnimations++;
                    console.log('DEBUG: All transitions completed for element:', completedAnimations, '/', totalAnimations, 'for element:', targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'));
                    
                    if (completedAnimations >= totalAnimations) {
                      console.log('DEBUG: All animations completed');
                      copy.removeEventListener('transitionend', onTransitionEnd);
                      copy.removeEventListener('transitionend', onCopyTransitionEnd);
                      childElements.forEach(child => {
                        child.removeEventListener('transitionend', onTransitionEnd);
                      });
                      clearTimeout(fallbackTimeout);
                      clearInterval(intervalId);
                      resolve();
                    }
                  }
                } else {
                  console.log('DEBUG: Ignoring transition for unexpected property:', propertyName);
                }
              } else {
                // Check if this is a child element that might be part of an animated element
                const parentAnimatedElement = elementsToAnimate.find(({ element }) => 
                  element.contains(targetElement)
                );
                
                if (parentAnimatedElement && !processedElements.has(targetElement)) {
                  processedElements.add(targetElement);
                  console.log('DEBUG: Child element transition detected, marking parent as potentially complete');
                  
                  // For child elements, we'll use a simpler approach - just count unique elements
                  const elementKey = parentAnimatedElement.element;
                  if (!animatedElements.has(elementKey)) {
                    animatedElements.add(elementKey);
                    completedAnimations++;
                    console.log('DEBUG: Child transition completed for element:', completedAnimations, '/', totalAnimations, 'for element:', targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'));
                    
                    if (completedAnimations >= totalAnimations) {
                      console.log('DEBUG: All animations completed via child transitions');
                      copy.removeEventListener('transitionend', onTransitionEnd);
                      copy.removeEventListener('transitionend', onCopyTransitionEnd);
                      childElements.forEach(child => {
                        child.removeEventListener('transitionend', onTransitionEnd);
                      });
                      clearTimeout(fallbackTimeout);
                      clearInterval(intervalId);
                      resolve();
                    }
                  }
                } else {
                  console.log('DEBUG: Transition end event for element not in our animation list');
                }
              }
            };
            
            // Add a more aggressive monitoring approach - check if animations are actually complete
            const checkAnimationProgress = () => {
              console.log('DEBUG: Position check running...');
              let actuallyCompleted = 0;
              elementsToAnimate.forEach(({ element, changes }) => {
                const computedStyle = window.getComputedStyle(element);
                const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
                
                // Check if the element has reached its target position
                let isComplete = false;
                
                if (changes.positionY && changes.positionY.changed) {
                  const currentTop = parseFloat(computedStyle.top) || 0;
                  const targetTop = changes.positionY.targetValue;
                  const difference = Math.abs(currentTop - targetTop);
                  
                  console.log('DEBUG: Position check for', elementName, 'currentTop:', currentTop, 'targetTop:', targetTop, 'difference:', difference);
                  
                  if (difference < 5) { // Allow for small rounding differences
                    isComplete = true;
                    console.log('DEBUG: Element', elementName, 'position animation appears complete:', currentTop, '->', targetTop);
                  }
                }
                
                if (changes.positionX && changes.positionX.changed) {
                  const currentLeft = parseFloat(computedStyle.left) || 0;
                  const targetLeft = changes.positionX.targetValue;
                  const difference = Math.abs(currentLeft - targetLeft);
                  
                  console.log('DEBUG: Position check for', elementName, 'currentLeft:', currentLeft, 'targetLeft:', targetLeft, 'difference:', difference);
                  
                  if (difference < 5) { // Allow for small rounding differences
                    isComplete = true;
                    console.log('DEBUG: Element', elementName, 'position animation appears complete:', currentLeft, '->', targetLeft);
                  }
                }
                
                if (isComplete && !animatedElements.has(element)) {
                  animatedElements.add(element);
                  actuallyCompleted++;
                  console.log('DEBUG: Element', elementName, 'marked as complete via position check');
                }
              });
              
              if (actuallyCompleted > 0) {
                completedAnimations += actuallyCompleted;
                console.log('DEBUG: Position check completed animations:', completedAnimations, '/', totalAnimations);
                
                if (completedAnimations >= totalAnimations) {
                  console.log('DEBUG: All animations completed via position check');
                  copy.removeEventListener('transitionend', onTransitionEnd);
                  copy.removeEventListener('transitionend', onCopyTransitionEnd);
                  childElements.forEach(child => {
                    child.removeEventListener('transitionend', onTransitionEnd);
                  });
                  clearTimeout(fallbackTimeout);
                  clearInterval(progressCheckInterval);
                  resolve();
                }
              }
            };
            
            // Set up periodic position checking
            const progressCheckInterval = setInterval(checkAnimationProgress, 100); // Check every 100ms
            console.log('DEBUG: Position-based monitoring interval set up');
            
            // Store the interval ID so we can clear it later
            const intervalId = progressCheckInterval;
            
            // Also listen for transitions on the copy element itself
            const onCopyTransitionEnd = (event) => {
              const propertyName = event.propertyName;
              console.log('DEBUG: Copy transition end event fired for property:', propertyName);
              
              // Find which element this transition belongs to by checking if the copy itself is being animated
              const animatedElement = elementsToAnimate.find(({ element }) => 
                element === copy
              );
              
              if (animatedElement) {
                const elementKey = animatedElement.element;
                const expectedProperties = transitionProperties.get(elementKey) || [];
                
                console.log('DEBUG: Found matching animated element (copy), expected properties:', expectedProperties);
                
                // Check if this is a property we're expecting to transition
                if (expectedProperties.includes(propertyName)) {
                  // Remove this property from the expected list
                  const updatedProperties = expectedProperties.filter(p => p !== propertyName);
                  transitionProperties.set(elementKey, updatedProperties);
                  
                  console.log('DEBUG: Property', propertyName, 'transition completed on copy, remaining properties for this element:', updatedProperties);
                  
                  // If all properties for this element have completed, mark the element as done
                  if (updatedProperties.length === 0 && !animatedElements.has(elementKey)) {
                    animatedElements.add(elementKey);
                    completedAnimations++;
                    console.log('DEBUG: All transitions completed for copy element:', completedAnimations, '/', totalAnimations);
                    
                    if (completedAnimations >= totalAnimations) {
                      console.log('DEBUG: All animations completed');
                      copy.removeEventListener('transitionend', onTransitionEnd);
                      copy.removeEventListener('transitionend', onCopyTransitionEnd);
                      childElements.forEach(child => {
                        child.removeEventListener('transitionend', onTransitionEnd);
                      });
                      clearTimeout(fallbackTimeout);
                      clearInterval(intervalId);
                      resolve();
                    }
                  }
                } else {
                  console.log('DEBUG: Ignoring copy transition for unexpected property:', propertyName);
                }
              } else {
                console.log('DEBUG: Copy transition end event but copy not in animation list');
              }
            };
            
            // Add transition end listener to the copy element and all its children
            copy.addEventListener('transitionend', onTransitionEnd);
            copy.addEventListener('transitionend', onCopyTransitionEnd);
            
            // Also listen for transitions on child elements that might be animated
            const childElements = copy.querySelectorAll('*');
            childElements.forEach(child => {
              child.addEventListener('transitionend', onTransitionEnd);
            });
            
            // Fallback timeout in case transition events don't fire
            const fallbackTimeout = setTimeout(() => {
              console.log('DEBUG: Animation fallback timeout reached');
              console.log('DEBUG: Completed animations:', completedAnimations, '/', totalAnimations);
              console.log('DEBUG: Remaining transition properties:', Array.from(transitionProperties.entries()));
              
              // Check if animations are actually complete by examining the computed styles
              let actuallyCompleted = 0;
              elementsToAnimate.forEach(({ element, changes }) => {
                const computedStyle = window.getComputedStyle(element);
                const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
                
                console.log('DEBUG: Checking if element', elementName, 'animation is actually complete:');
                console.log('  transition:', computedStyle.transition);
                console.log('  transform:', computedStyle.transform);
                console.log('  left:', computedStyle.left);
                console.log('  top:', computedStyle.top);
                
                // If transition is 'none' or empty, animation is likely complete
                if (!computedStyle.transition || computedStyle.transition === 'none' || computedStyle.transition === 'all 0s ease 0s') {
                  actuallyCompleted++;
                  console.log('DEBUG: Element', elementName, 'appears to be complete (no active transition)');
                }
              });
              
              console.log('DEBUG: Actually completed animations:', actuallyCompleted, '/', totalAnimations);
              
              copy.removeEventListener('transitionend', onTransitionEnd);
              copy.removeEventListener('transitionend', onCopyTransitionEnd);
              childElements.forEach(child => {
                child.removeEventListener('transitionend', onTransitionEnd);
              });
              clearInterval(intervalId);
              resolve();
            }, parseFloat(transitionDuration || '0.3') * 1000 + 2000); // Add 2s buffer for more reliability
          } else {
            resolve();
          }
        });
      }
      
      // Helper function to get node data from element (placeholder)
      function getNodeDataFromElement(element) {
        // This would need to be implemented to extract Figma node data from DOM elements
        // For now, return a basic structure
        return {
          type: element.getAttribute('data-figma-type') || 'UNKNOWN',
          layoutPositioning: element.getAttribute('data-layout-positioning') || 'AUTO',
          layoutMode: element.getAttribute('data-layout-mode') || 'NONE'
        };
      }
      
      // Helper function to find elements with property changes
      function findElementsWithPropertyChanges(targetVariant, currentVariant) {
        console.log('DEBUG: findElementsWithPropertyChanges called');
        console.log('  Target variant ID:', targetVariant.getAttribute('data-figma-id'), 'Name:', targetVariant.getAttribute('data-figma-name'));
        console.log('  Current variant ID:', currentVariant.getAttribute('data-figma-id'), 'Name:', currentVariant.getAttribute('data-figma-name'));
        
        if (!currentVariant) {
          console.log('DEBUG: No current variant provided, returning empty array');
          return [];
        }
        
        const targetElements = targetVariant.querySelectorAll('[data-figma-id]');
        const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');
        const sourceElementMap = new Map();
        const elementsToAnimate = [];

        console.log('DEBUG: Found', targetElements.length, 'target elements and', sourceElements.length, 'source elements');

        // Build source element map by name
        sourceElements.forEach(function(sourceElement) {
          const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');
          if (sourceName) {
            sourceElementMap.set(sourceName, sourceElement);
            console.log('  Mapped source element:', sourceName, '->', sourceElement.getAttribute('data-figma-id'));
          }
        });

        // Analyze each target element for property changes
        targetElements.forEach(function(element, index) {
          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
          const sourceElement = sourceElementMap.get(targetName);
          
          console.log('DEBUG: Analyzing target element ' + (index + 1) + ':', targetName);
          console.log('  Target element ID:', element.getAttribute('data-figma-id'));
          console.log('  Source element found:', !!sourceElement);
          
          if (sourceElement) {
            console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));
            const changes = detectPropertyChanges(element, sourceElement);
            
            if (changes.hasChanges) {
              elementsToAnimate.push({
                element: sourceElement,  // Use SOURCE element (from copy) instead of target
                sourceElement: sourceElement,
                changes: changes
              });
              console.log('DEBUG: Found element with property changes:', targetName, 'changes:', changes);
            } else {
              console.log('DEBUG: No changes detected for element:', targetName);
            }
          } else {
            console.log('DEBUG: No matching source element found for:', targetName);
          }
        });
        
        console.log('DEBUG: Returning', elementsToAnimate.length, 'elements to animate');
        return elementsToAnimate;
      }

      // Helper function to detect property changes between elements
      function detectPropertyChanges(targetElement, sourceElement) {
        const changes = {
          hasChanges: false,
          positionX: { changed: false, sourceValue: null, targetValue: null },
          positionY: { changed: false, sourceValue: null, targetValue: null },
          backgroundColor: { changed: false, sourceValue: null, targetValue: null },
          color: { changed: false, sourceValue: null, targetValue: null },
          justifyContent: { changed: false, sourceValue: null, targetValue: null },
          alignItems: { changed: false, sourceValue: null, targetValue: null }
        };

        try {
          const sourceStyle = window.getComputedStyle(sourceElement);
          const targetStyle = window.getComputedStyle(targetElement);
          
          // STEP 1: Check if the node has position changes using bounding rectangles (accounts for flexbox alignment)
          const sourceRect = sourceElement.getBoundingClientRect();
          const targetRect = targetElement.getBoundingClientRect();
          
          // Get parent rectangles for relative positioning
          const sourceParent = sourceElement.parentElement;
          const targetParent = targetElement.parentElement;
          const sourceParentRect = sourceParent ? sourceParent.getBoundingClientRect() : { left: 0, top: 0 };
          const targetParentRect = targetParent ? targetParent.getBoundingClientRect() : { left: 0, top: 0 };
          
          // Calculate relative positions within their containers
          const sourceLeft = sourceRect.left - sourceParentRect.left;
          const targetLeft = targetRect.left - targetParentRect.left;
          const sourceTop = sourceRect.top - sourceParentRect.top;
          const targetTop = targetRect.top - targetParentRect.top;
          
          // STEP 2: Check if the node has ignore auto layout enabled
          const ignoreAutoLayout = sourceElement.getAttribute('data-layout-positioning') === 'ABSOLUTE';
          
          // STEP 3: Check if the node's parent has auto layout
          const parentHasAutoLayout = sourceParent && targetParent && 
            sourceParent.getAttribute('data-layout-mode') && 
            sourceParent.getAttribute('data-layout-mode') !== 'NONE';
          
          console.log('DEBUG: 3-Point Analysis for', sourceElement.getAttribute('data-figma-name'), {
            hasPositionChange: Math.abs(sourceLeft - targetLeft) > 1 || Math.abs(sourceTop - targetTop) > 1,
            ignoreAutoLayout: ignoreAutoLayout,
            parentHasAutoLayout: parentHasAutoLayout,
            sourceLeft: sourceLeft,
            targetLeft: targetLeft,
            sourceTop: sourceTop,
            targetTop: targetTop
          });
          
          // Determine if this node should be animated based on the 3-point logic
          let shouldAnimatePosition = false;
          let animationType = 'ABSOLUTE';
          
          if (Math.abs(sourceLeft - targetLeft) > 1 || Math.abs(sourceTop - targetTop) > 1) {
            // Node has position changes
            if (ignoreAutoLayout) {
              // Node ignores auto layout - animate absolutely
              shouldAnimatePosition = true;
              animationType = 'ABSOLUTE';
              console.log('DEBUG: Node has position changes and ignores auto layout - animating absolutely');
            } else if (!parentHasAutoLayout) {
              // Node's parent doesn't have auto layout - animate absolutely
              shouldAnimatePosition = true;
              animationType = 'ABSOLUTE';
              console.log('DEBUG: Node has position changes and parent has no auto layout - animating absolutely');
            } else {
              // Node has position changes and parent has auto layout - ANIMATE the node
              // The node moves due to parent's alignment changes, so we animate it smoothly
              shouldAnimatePosition = true;
              animationType = 'ABSOLUTE';
              console.log('DEBUG: Node has position changes and parent has auto layout - ANIMATING (node moves due to parent alignment)');
            }
          } else {
            // No position changes - no animation needed
            shouldAnimatePosition = false;
            console.log('DEBUG: No position changes detected - no animation needed');
          }
          
          // Apply position changes if animation is needed
          if (shouldAnimatePosition) {
            if (Math.abs(sourceLeft - targetLeft) > 1) {
              changes.positionX.changed = true;
              changes.positionX.sourceValue = sourceLeft;
              changes.positionX.targetValue = targetLeft;
              changes.hasChanges = true;
              console.log('DEBUG: Position X change detected:', sourceLeft, '->', targetLeft, '(', animationType, ')');
            }
            
            if (Math.abs(sourceTop - targetTop) > 1) {
              changes.positionY.changed = true;
              changes.positionY.sourceValue = sourceTop;
              changes.positionY.targetValue = targetTop;
              changes.hasChanges = true;
              console.log('DEBUG: Position Y change detected:', sourceTop, '->', targetTop, '(', animationType, ')');
            }
          }

          // Check style changes (non-position)
          const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          
          if (sourceBg !== targetBg) {
            changes.backgroundColor.changed = true;
            changes.backgroundColor.sourceValue = sourceBg;
            changes.backgroundColor.targetValue = targetBg;
            changes.hasChanges = true;
            console.log('DEBUG: Background color change detected:', sourceBg, '->', targetBg);
          }
          
          if (sourceStyle.color !== targetStyle.color) {
            changes.color.changed = true;
            changes.color.sourceValue = sourceStyle.color;
            changes.color.targetValue = targetStyle.color;
            changes.hasChanges = true;
            console.log('DEBUG: Color change detected:', sourceStyle.color, '->', targetStyle.color);
          }
          
          // Only mark alignment changes as requiring animation if there's an actual position difference
          if (sourceStyle.justifyContent !== targetStyle.justifyContent) {
            changes.justifyContent.changed = true;
            changes.justifyContent.sourceValue = sourceStyle.justifyContent;
            changes.justifyContent.targetValue = targetStyle.justifyContent;
            
            // Only set hasChanges if there's an actual position difference to animate
            if (shouldAnimatePosition) {
              changes.hasChanges = true;
            }
          }
          
          if (sourceStyle.alignItems !== targetStyle.alignItems) {
            changes.alignItems.changed = true;
            changes.alignItems.sourceValue = sourceStyle.alignItems;
            changes.alignItems.targetValue = targetStyle.alignItems;
            
            // Only set hasChanges if there's an actual position difference to animate
            if (shouldAnimatePosition) {
              changes.hasChanges = true;
            }
          }
        } catch (error) {
          console.log('DEBUG: Error detecting property changes:', error);
        }

        // Debug: Log what caused hasChanges to be true
        if (changes.hasChanges) {
          console.log('DEBUG: hasChanges is true for', sourceElement.getAttribute('data-figma-name'), 'due to:');
          if (changes.positionX.changed) console.log('  - positionX change');
          if (changes.positionY.changed) console.log('  - positionY change');
          if (changes.backgroundColor.changed) console.log('  - backgroundColor change');
          if (changes.color.changed) console.log('  - color change');
          if (changes.justifyContent.changed) console.log('  - justifyContent change');
          if (changes.alignItems.changed) console.log('  - alignItems change');
        }

        return changes;
      }
      
      // Helper function to handle animated variant switching
      async function handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration) {
        console.log('DEBUG: Starting modular animated variant switch');
        console.log('DEBUG: About to create element copy');
        
        // Create a copy of the source variant
        const sourceCopy = createElementCopy(sourceElement);
        console.log('DEBUG: Element copy created successfully');
        
        // Insert the copy into the DOM
        const sourceParent = sourceElement.parentElement;
        sourceParent.appendChild(sourceCopy);
        console.log('DEBUG: Copy inserted into DOM');
        
        // Log the copy's position and visibility after insertion
        const copyRect = sourceCopy.getBoundingClientRect();
        const copyStyle = window.getComputedStyle(sourceCopy);
        console.log('DEBUG: Copy after insertion:');
        console.log('  position: ' + copyStyle.position);
        console.log('  top: ' + copyStyle.top);
        console.log('  left: ' + copyStyle.left);
        console.log('  z-index: ' + copyStyle.zIndex);
        console.log('  opacity: ' + copyStyle.opacity);
        console.log('  visibility: ' + copyStyle.visibility);
        console.log('  display: ' + copyStyle.display);
        console.log('  bounding rect: ' + copyRect);
        
        // Hide the original source element and all other variants
        sourceElement.style.opacity = '0';
        sourceElement.style.visibility = 'hidden';
        
        allVariants.forEach(variant => {
          if (variant !== sourceElement) {
            variant.style.opacity = '0';
            variant.style.visibility = 'hidden';
          }
        });
        
        // Prepare the destination variant but keep it hidden for now
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        destination.style.visibility = 'hidden';
        destination.style.opacity = '0';
        
        // Force reflow
        destination.offsetHeight;
        
        // Animate the copy to match the destination
        await animateCopyToDestination(sourceCopy, destination, transitionType, transitionDuration);
        
        console.log('DEBUG: Animation completed, transitioning to destination variant');
        
        // Animation complete - restore normal behavior
        sourceCopy.remove();
        
        // Hide the original source element permanently
        sourceElement.style.opacity = '0';
        sourceElement.style.visibility = 'hidden';
        sourceElement.classList.add('variant-hidden');
        sourceElement.classList.remove('variant-active');
        
        // Properly activate the destination variant
        destination.style.visibility = 'visible';
        destination.style.opacity = '1';
        destination.style.display = 'flex';
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        
        // Ensure destination has proper positioning
        destination.style.position = 'relative';
        destination.style.top = '0px';
        destination.style.left = '0px';
        
        // Ensure all nested elements in the destination are also visible
        const destinationChildren = destination.querySelectorAll('*');
        destinationChildren.forEach(child => {
          child.style.opacity = '1';
          child.style.visibility = 'visible';
          if (child.style.display === 'none') {
            child.style.display = 'flex';
          }
        });
        
        // Hide all other variants
        allVariants.forEach(variant => {
          if (variant !== destination) {
            variant.classList.add('variant-hidden');
            variant.classList.remove('variant-active');
            variant.style.position = 'relative';
            variant.style.top = '0px';
            variant.style.left = '0px';
            variant.style.opacity = '0';
            variant.style.visibility = 'hidden';
          }
        });
        
        // Start timeout reactions
        startTimeoutReactionsForNewlyActiveVariant(destination);
        startTimeoutReactionsForNestedComponents(destination);
      }
      
      // Helper function to perform instant variant switch
      function performInstantVariantSwitch(allVariants, destination) {
        console.log('DEBUG: Performing instant variant switch');
        
        // Hide all variants
        allVariants.forEach(variant => {
          variant.classList.add('variant-hidden');
          variant.classList.remove('variant-active');
          variant.style.position = 'relative';
          variant.style.top = '0px';
          variant.style.left = '0px';
        });
        
        // Show destination variant
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        destination.style.position = 'relative';
        destination.style.top = '0px';
        destination.style.left = '0px';
        
        // Start timeout reactions
        startTimeoutReactionsForNewlyActiveVariant(destination);
        startTimeoutReactionsForNestedComponents(destination);
      }
      
      // Main reaction handler function
      function handleReaction(sourceElement, destinationId, transitionType, transitionDuration) {
        console.log('DEBUG: Modular handleReaction called');
        console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));
        console.log('  Destination ID:', destinationId);
        console.log('  Transition type:', transitionType, 'Duration:', transitionDuration);
        
        // Prevent multiple simultaneous transitions
        if (isTransitionInProgress) {
          console.log('DEBUG: Transition already in progress, skipping');
          return;
        }
        
        // Set transition lock
        isTransitionInProgress = true;
        
        // Safety timeout
        const safetyTimeout = setTimeout(() => {
          if (isTransitionInProgress) {
            console.log('WARNING: Transition lock stuck, forcing release');
            isTransitionInProgress = false;
            currentTransitionPromise = null;
          }
        }, 10000); // Increased to 10 seconds
        
        if (destinationId) {
          const destination = document.querySelector(`[data-figma-id="${destinationId}"]`);
          
          if (!destination) {
            console.log('ERROR: Destination element not found:', destinationId);
            clearTimeout(safetyTimeout);
            isTransitionInProgress = false;
            return;
          }
          
          // Check if this is a variant switch within a component set
          const sourceComponentSet = sourceElement.closest('[data-figma-type="COMPONENT_SET"]');
          const destinationComponentSet = destination.closest('[data-figma-type="COMPONENT_SET"]');
          
          if (sourceComponentSet && destinationComponentSet && sourceComponentSet === destinationComponentSet) {
            // This is a variant switch
            const componentSet = sourceComponentSet;
            const allVariants = Array.from(componentSet.children).filter(child => 
              child.getAttribute('data-figma-type') === 'COMPONENT'
            );
            
            const isAnimated = transitionType === 'SMART_ANIMATE' || 
                              transitionType === 'BOUNCY' || 
                              transitionType === 'EASE_IN_AND_OUT' || 
                              transitionType === 'EASE_IN' || 
                              transitionType === 'EASE_OUT' || 
                              transitionType === 'LINEAR' || 
                              transitionType === 'GENTLE';
            
            if (isAnimated) {
              console.log('DEBUG: Using modular animated variant switching');
              currentTransitionPromise = handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration)
                .then(() => {
                  clearTimeout(safetyTimeout);
                  isTransitionInProgress = false;
                  currentTransitionPromise = null;
                })
                .catch((error) => {
                  console.error('Modular animation error:', error);
                  clearTimeout(safetyTimeout);
                  isTransitionInProgress = false;
                  currentTransitionPromise = null;
                });
            } else {
              console.log('DEBUG: Using instant variant switching');
              performInstantVariantSwitch(allVariants, destination);
              clearTimeout(safetyTimeout);
              isTransitionInProgress = false;
              currentTransitionPromise = null;
            }
                      } else {
              // This is a regular transition (not variant switching)
              if (transitionType === 'DISSOLVE') {
                sourceElement.style.opacity = '0';
                setTimeout(() => {
                  sourceElement.style.opacity = '1';
                  destination.classList.add('variant-active');
                  destination.classList.remove('variant-hidden');
                  destination.style.opacity = '1';
                  
                  startTimeoutReactionsForNewlyActiveVariant(destination);
                  startTimeoutReactionsForNestedComponents(destination);
                  
                  clearTimeout(safetyTimeout);
                  isTransitionInProgress = false;
                  currentTransitionPromise = null;
                }, parseFloat(transitionDuration || '300'));
              } else {
                sourceElement.style.opacity = '1';
                destination.classList.add('variant-active');
                destination.classList.remove('variant-hidden');
                destination.style.opacity = '1';
                
                startTimeoutReactionsForNewlyActiveVariant(destination);
                startTimeoutReactionsForNestedComponents(destination);
                
                clearTimeout(safetyTimeout);
                isTransitionInProgress = false;
                currentTransitionPromise = null;
              }
            }
        } else {
          clearTimeout(safetyTimeout);
          isTransitionInProgress = false;
          currentTransitionPromise = null;
        }
      }
      
      // Make function globally available
      window.handleReaction = handleReaction;
    
      
      // Initialize component set variants - handle both single and multiple variants
      // Handle both COMPONENT_SET and COMPONENT elements that contain variants
      // With the new 1:1 structure, this will handle nested component sets correctly
      const componentSets = document.querySelectorAll('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
      componentSets.forEach(componentSet => {
        // Find all COMPONENT children - these are the variants
        // Some may have explicit variant attributes, others are variants by hierarchy
        const variants = componentSet.querySelectorAll('[data-figma-type="COMPONENT"]');
        
        // Handle both single and multiple variants
        if (variants.length >= 1) {
          console.log('Initializing component set/instance with', variants.length, 'variants:', {
            componentSetId: componentSet.getAttribute('data-figma-id'),
            componentSetName: componentSet.getAttribute('data-figma-name'),
            componentSetType: componentSet.getAttribute('data-figma-type'),
            parentType: componentSet.parentElement?.getAttribute('data-figma-type'),
            parentId: componentSet.parentElement?.getAttribute('data-figma-id'),
            variantIds: Array.from(variants).map(v => v.getAttribute('data-figma-id'))
          });
          
          // Reset opacity for all variants to ensure clean initial state
          variants.forEach(variant => {
            variant.style.opacity = '1'; // Ensure all variants start with opacity 1
          });
          
          // For single components, just make them visible
          if (variants.length === 1) {
            const singleVariant = variants[0];
            singleVariant.classList.add('variant-active');
            singleVariant.classList.remove('variant-hidden');
            console.log('Set single variant as active:', singleVariant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
          } else {
            // For multiple variants, the FIRST variant should be active initially (where reactions are)
            // This ensures the animation starts from the variant with reactions
            variants.forEach((variant, index) => {
              if (index === 0) {
                variant.classList.add('variant-active');
                variant.classList.remove('variant-hidden');
                console.log('Set first variant as active (with reactions):', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
              } else {
                variant.classList.add('variant-hidden');
                variant.classList.remove('variant-active');
                console.log('Set variant as hidden:', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
              }
            });
          }
        }
      });
  
      console.log('DEBUG: All event handlers initialized');
    });
    
    // Also run immediately if DOM is already loaded
    if (document.readyState === 'loading') {
      console.log('DEBUG: DOM still loading, waiting for DOMContentLoaded');
    } else {
      console.log('DEBUG: DOM already loaded, running handlers immediately');
      
      // Handle variant switching - instant switching only, no animation
      // This is a simple slideshow-like system that switches between variants instantly
      const variantButtons = document.querySelectorAll('[data-variant], [data-variant-property-1]');
      variantButtons.forEach(button => {
        button.addEventListener('click', function() {
          console.log('DEBUG: Variant switch clicked');
          
          const variant = this.getAttribute('data-variant') || this.getAttribute('data-variant-property-1');
          const targetId = this.getAttribute('data-target');
          
          if (targetId) {
            const target = document.querySelector(`[data-figma-id="${targetId}"]`);
            if (target) {
              console.log('Variant switch:', { variant, targetId, targetName: target.getAttribute('data-figma-name') });
              
              // Find the specific component set that contains this button
              let componentSet = target;
              let buttonElement = this;
              
              // Walk up the DOM tree to find the immediate component set parent
              while (buttonElement && buttonElement.parentElement) {
                buttonElement = buttonElement.parentElement;
                if (buttonElement.getAttribute('data-figma-type') === 'COMPONENT_SET') {
                  componentSet = buttonElement;
                  console.log('Found component set for switching:', {
                    id: componentSet.getAttribute('data-figma-id'),
                    name: componentSet.getAttribute('data-figma-name')
                  });
                  break;
                }
              }
              
              // Get all variants within this specific component set instance
              const allVariants = Array.from(componentSet.children).filter(child => 
                child.getAttribute('data-figma-type') === 'COMPONENT' &&
                (child.getAttribute('data-variant') || child.getAttribute('data-variant-property-1'))
              );
              
              console.log('Found', allVariants.length, 'variants in component set:', componentSet.getAttribute('data-figma-id'));
              
              // INSTANT VARIANT SWITCHING - Hide all variants
              allVariants.forEach(variant => {
                variant.classList.add('variant-hidden');
                variant.classList.remove('variant-active');
                // Ensure all variants maintain their original positioning (relative with 0px)
                variant.style.position = 'relative';
                variant.style.top = '0px';
                variant.style.left = '0px';
                console.log('Hidden variant:', variant.getAttribute('data-figma-id'));
              });
              
              // Show selected variant instantly
              const selectedVariant = allVariants.find(v => 
                v.getAttribute('data-variant') === variant || 
                v.getAttribute('data-variant-property-1') === variant
              );
              
              if (selectedVariant) {
                selectedVariant.classList.add('variant-active');
                selectedVariant.classList.remove('variant-hidden');
                // Ensure selected variant maintains its original positioning
                selectedVariant.style.position = 'relative';
                selectedVariant.style.top = '0px';
                selectedVariant.style.left = '0px';
                console.log('Switched to variant:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));
                
                // Start timeout reactions for the newly active variant
                startTimeoutReactionsForNewlyActiveVariant(selectedVariant);
                startTimeoutReactionsForNestedComponents(selectedVariant);
              } else {
                console.log('Selected variant not found:', variant, 'in component set:', componentSet.getAttribute('data-figma-id'));
              }
            }
          }
        });
      });
  
      
      // Handle reactions - click, press, and drag
      const reactionElements = document.querySelectorAll('[data-has-reactions="true"]');
      reactionElements.forEach(element => {
        const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
        const actionType = element.getAttribute('data-reaction-action-type');
        const destinationId = element.getAttribute('data-reaction-destination');
        const transitionType = element.getAttribute('data-reaction-transition-type');
        const transitionDuration = element.getAttribute('data-reaction-transition-duration');
        
        // Handle click, press, and drag reactions
        element.addEventListener('click', function() {
          console.log('DEBUG: Click event triggered on element:', {
            id: this.getAttribute('data-figma-id'),
            name: this.getAttribute('data-figma-name'),
            type: this.getAttribute('data-figma-type'),
            trigger: trigger,
            actionType: actionType,
            destinationId: destinationId,
            transitionType: transitionType,
            transitionDuration: transitionDuration
          });
          
          if (trigger.type === 'ON_CLICK' || trigger.type === 'ON_PRESS') {
            console.log('DEBUG: Processing click reaction for element:', this.getAttribute('data-figma-id'));
            handleReaction(this, destinationId, transitionType, transitionDuration);
          }
        });
        
        // Handle drag reactions
        element.addEventListener('mousedown', function() {
          if (trigger.type === 'ON_DRAG') {
            handleReaction(this, destinationId, transitionType, transitionDuration);
          }
        });
      });
  
      
      // Track which variants have active timers (for preventing duplicate timers during the same activation)
      const activeTimers = new Map(); // elementId -> timeoutId
      
      // Function to start timeout reactions for active variants
      function startTimeoutReactionsForActiveVariants() {
        // Look for both variant-active elements with reactions AND any elements with reactions that don't have variant properties
        const activeVariants = document.querySelectorAll('.variant-active[data-has-reactions="true"]');
        const reactionElements = document.querySelectorAll('[data-has-reactions="true"]');
        
        console.log('DEBUG: Found', activeVariants.length, 'active variants with reactions');
        console.log('DEBUG: Found', reactionElements.length, 'total elements with reactions');
        
        // Process active variants first
        activeVariants.forEach(element => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          const parentComponent = element.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing variant:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for variants that are actually visible (not hidden by CSS)
          const computedStyle = window.getComputedStyle(element);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
            const actionType = element.getAttribute('data-reaction-action-type');
            const destinationId = element.getAttribute('data-reaction-destination');
            const transitionType = element.getAttribute('data-reaction-transition-type');
            const transitionDuration = element.getAttribute('data-reaction-transition-duration');
            
            // Handle timeout reactions only for active variants that don't have an active timer
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId); // Clear the timer when it completes
                handleReaction(element, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
          }
        });
        
        // Also process any reaction elements that don't have variant properties (like 6461:693)
        reactionElements.forEach(element => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          
          // Skip if this element was already processed as a variant
          if (element.classList.contains('variant-active')) {
            return;
          }
          
          // Skip if this element has variant properties (it will be handled by variant logic)
          if (element.hasAttribute('data-variant-property-1')) {
            return;
          }
          
          const parentComponent = element.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing non-variant reaction element:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for elements that are actually visible (not hidden by CSS)
          const computedStyle = window.getComputedStyle(element);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
            const actionType = element.getAttribute('data-reaction-action-type');
            const destinationId = element.getAttribute('data-reaction-destination');
            const transitionType = element.getAttribute('data-reaction-transition-type');
            const transitionDuration = element.getAttribute('data-reaction-transition-duration');
            
            // Handle timeout reactions only for elements that don't have an active timer
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId); // Clear the timer when it completes
                handleReaction(element, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
          }
        });
      }
      
      // Function to start timeout reactions for nested components when their parent becomes visible
      function startTimeoutReactionsForNestedComponents(parentElement) {
        if (!parentElement) return;
        
        // Find all nested components with timeout reactions within the parent
        const nestedComponents = parentElement.querySelectorAll('[data-has-reactions="true"][data-reaction-trigger*="AFTER_TIMEOUT"]');
        
        nestedComponents.forEach(component => {
          const elementId = component.getAttribute('data-figma-id');
          const elementName = component.getAttribute('data-figma-name');
          const parentComponent = component.closest('[data-figma-type="COMPONENT_SET"]');
          const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
          
          console.log('DEBUG: Processing nested component:', elementId, 'name:', elementName, 'parent:', parentName);
          
          // Only start timers for nested components that are actually visible
          const computedStyle = window.getComputedStyle(component);
          
          if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
            const trigger = JSON.parse(component.getAttribute('data-reaction-trigger') || '{}');
            
            if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
              console.log('DEBUG: Starting timeout reaction for nested component:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
              const timeoutId = setTimeout(() => {
                activeTimers.delete(elementId);
                const actionType = component.getAttribute('data-reaction-action-type');
                const destinationId = component.getAttribute('data-reaction-destination');
                const transitionType = component.getAttribute('data-reaction-transition-type');
                const transitionDuration = component.getAttribute('data-reaction-transition-duration');
                handleReaction(component, destinationId, transitionType, transitionDuration);
              }, (trigger.timeout || 0) * 1000);
              activeTimers.set(elementId, timeoutId);
            } else if (activeTimers.has(elementId)) {
              console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- timer already active');
            }
          } else {
            console.log('DEBUG: Skipping nested component', elementId, 'name:', elementName, '- not visible');
          }
        });
      }
      
      // Function to start timeout reactions for a specific newly active variant
      function startTimeoutReactionsForNewlyActiveVariant(newlyActiveElement) {
        if (!newlyActiveElement) return;
        
        const elementId = newlyActiveElement.getAttribute('data-figma-id');
        const elementName = newlyActiveElement.getAttribute('data-figma-name');
        const parentComponent = newlyActiveElement.closest('[data-figma-type="COMPONENT_SET"]');
        const parentName = parentComponent ? parentComponent.getAttribute('data-figma-name') : 'none';
        
        console.log('DEBUG: Processing newly active variant:', elementId, 'name:', elementName, 'parent:', parentName);
        
        // Only start timers for variants that are actually visible (not hidden by CSS)
        const computedStyle = window.getComputedStyle(newlyActiveElement);
        
        if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
          const trigger = JSON.parse(newlyActiveElement.getAttribute('data-reaction-trigger') || '{}');
          const actionType = newlyActiveElement.getAttribute('data-reaction-action-type');
          const destinationId = newlyActiveElement.getAttribute('data-reaction-destination');
          const transitionType = newlyActiveElement.getAttribute('data-reaction-transition-type');
          const transitionDuration = newlyActiveElement.getAttribute('data-reaction-transition-duration');
          
          // Handle timeout reactions only for active variants that don't have an active timer
          if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
            console.log('DEBUG: Starting timeout reaction for newly active variant:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'parent:', parentName);
            const timeoutId = setTimeout(() => {
              activeTimers.delete(elementId); // Clear the timer when it completes
              handleReaction(newlyActiveElement, destinationId, transitionType, transitionDuration);
            }, (trigger.timeout || 0) * 1000);
            activeTimers.set(elementId, timeoutId);
          } else if (activeTimers.has(elementId)) {
            console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- timer already active');
          }
          
          // CRITICAL FIX: Also start timeout reactions for any nested components within this newly active variant
          startTimeoutReactionsForNestedComponents(newlyActiveElement);
        } else {
          console.log('DEBUG: Skipping newly active variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
        }
      }
      
      // CRITICAL FIX: Only start timeout reactions for the initial visible variant
      // Instead of starting timers for all variant-active elements immediately,
      // we wait for the first variant transition or user interaction
      function startTimeoutReactionsForInitialVariant() {
        // Find the first visible variant that should start the flow
        // This is typically the first variant in a component set that's marked as active
        const componentSets = document.querySelectorAll('[data-figma-type="COMPONENT_SET"]');
        console.log('DEBUG: Found', componentSets.length, 'component sets');
        
        // Also check for any elements with reactions
        const allReactionElements = document.querySelectorAll('[data-has-reactions="true"]');
        console.log('DEBUG: Found', allReactionElements.length, 'total elements with reactions');
        
        // Log details about reaction elements
        allReactionElements.forEach((element, index) => {
          const elementId = element.getAttribute('data-figma-id');
          const elementName = element.getAttribute('data-figma-name');
          const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
          const computedStyle = window.getComputedStyle(element);
          
          console.log('DEBUG: Reaction element', index + 1, ':', {
            id: elementId,
            name: elementName,
            trigger: trigger,
            display: computedStyle.display,
            visibility: computedStyle.visibility,
            isActive: element.classList.contains('variant-active'),
            isHidden: element.classList.contains('variant-hidden')
          });
        });
        
        componentSets.forEach(componentSet => {
          const componentSetName = componentSet.getAttribute('data-figma-name');
          const activeVariants = componentSet.querySelectorAll('.variant-active[data-has-reactions="true"]');
          console.log('DEBUG: Component set', componentSetName, 'has', activeVariants.length, 'active variants with reactions');
          
          // Only start timers for the first active variant in each component set
          if (activeVariants.length > 0) {
            const firstActiveVariant = activeVariants[0];
            const elementId = firstActiveVariant.getAttribute('data-figma-id');
            const elementName = firstActiveVariant.getAttribute('data-figma-name');
            const computedStyle = window.getComputedStyle(firstActiveVariant);
            
            console.log('DEBUG: Processing initial variant:', elementId, 'name:', elementName, 'in component set:', componentSetName);
            
            // Only start timer if the variant is actually visible
            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
              const trigger = JSON.parse(firstActiveVariant.getAttribute('data-reaction-trigger') || '{}');
              
              // Skip nested components that should only start when their parent becomes visible
              // Allow independent components to start their timers on page load
              // Check if this component set is nested within another component set
              const parentComponentSet = componentSet.closest('[data-figma-type="COMPONENT_SET"]');
              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;
              
              if (isNestedComponent) {
                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');
                return;
              }
              
              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
                console.log('DEBUG: Starting initial timeout reaction for:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);
                const timeoutId = setTimeout(() => {
                  console.log('DEBUG: Timeout triggered for element:', elementId, 'name:', elementName);
                  activeTimers.delete(elementId);
                  const actionType = firstActiveVariant.getAttribute('data-reaction-action-type');
                  const destinationId = firstActiveVariant.getAttribute('data-reaction-destination');
                  const transitionType = firstActiveVariant.getAttribute('data-reaction-transition-type');
                  const transitionDuration = firstActiveVariant.getAttribute('data-reaction-transition-duration');
                  console.log('DEBUG: Calling handleReaction with:', {
                    destinationId: destinationId,
                    transitionType: transitionType,
                    transitionDuration: transitionDuration
                  });
                  handleReaction(firstActiveVariant, destinationId, transitionType, transitionDuration);
                }, (trigger.timeout || 0) * 1000);
                activeTimers.set(elementId, timeoutId);
                console.log('DEBUG: Created timeout timer for element:', elementId, 'timeout ID:', timeoutId, 'duration:', (trigger.timeout || 0) * 1000, 'ms');
                
                // CRITICAL FIX: Also start timeout reactions for any nested components within this initial variant
                startTimeoutReactionsForNestedComponents(firstActiveVariant);
              } else {
                console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- no timeout trigger or timer already active');
              }
            } else {
              console.log('DEBUG: Skipping initial variant', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
            }
          }
          
          // CRITICAL FIX: Also check for non-variant reaction elements in this component set
          const reactionElements = componentSet.querySelectorAll('[data-has-reactions="true"]');
          reactionElements.forEach(element => {
            const elementId = element.getAttribute('data-figma-id');
            const elementName = element.getAttribute('data-figma-name');
            
            // Skip if this element was already processed as a variant
            if (element.classList.contains('variant-active')) {
              return;
            }
            
            // Skip if this element has variant properties (it will be handled by variant logic)
            if (element.hasAttribute('data-variant-property-1')) {
              return;
            }
            
            const computedStyle = window.getComputedStyle(element);
            
            console.log('DEBUG: Processing initial non-variant reaction element:', elementId, 'name:', elementName, 'in component set:', componentSetName);
            
            // Only start timer if the element is actually visible
            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
              const trigger = JSON.parse(element.getAttribute('data-reaction-trigger') || '{}');
              
              // Skip nested components that should only start when their parent becomes visible
              const parentComponentSet = componentSet.closest('[data-figma-type="COMPONENT_SET"]');
              const isNestedComponent = parentComponentSet && parentComponentSet !== componentSet;
              
              if (isNestedComponent) {
                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- nested component, will start when parent becomes visible');
                return;
              }
              
              if (trigger.type === 'AFTER_TIMEOUT' && !activeTimers.has(elementId)) {
                console.log('DEBUG: Starting initial timeout reaction for non-variant element:', elementId, 'name:', elementName, 'timeout:', trigger.timeout, 'in component set:', componentSetName);
                const timeoutId = setTimeout(() => {
                  activeTimers.delete(elementId);
                  const actionType = element.getAttribute('data-reaction-action-type');
                  const destinationId = element.getAttribute('data-reaction-destination');
                  const transitionType = element.getAttribute('data-reaction-transition-type');
                  const transitionDuration = element.getAttribute('data-reaction-transition-duration');
                  handleReaction(element, destinationId, transitionType, transitionDuration);
                }, (trigger.timeout || 0) * 1000);
                activeTimers.set(elementId, timeoutId);
                
                // Also start timeout reactions for any nested components within this element
                startTimeoutReactionsForNestedComponents(element);
              } else {
                console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- no timeout trigger or timer already active');
              }
            } else {
              console.log('DEBUG: Skipping initial non-variant element', elementId, 'name:', elementName, '- not visible (display:', computedStyle.display, 'visibility:', computedStyle.visibility, ')');
            }
          });
        });
      }
      
      // Start timeout reactions for the initial visible variant after a short delay
      // to ensure CSS classes and visibility are properly applied
      console.log('DEBUG: Setting up initial timeout reactions');
      setTimeout(() => {
        console.log('DEBUG: Starting initial timeout reactions');
        startTimeoutReactionsForInitialVariant();
      }, 100);
  
      
      // Helper function to find elements with property changes between variants
      function findElementsWithPropertyChanges(targetVariant, currentVariant) {
        console.log('DEBUG: findElementsWithPropertyChanges called');
        console.log('  Target variant ID:', targetVariant.getAttribute('data-figma-id'), 'Name:', targetVariant.getAttribute('data-figma-name'));
        console.log('  Current variant ID:', currentVariant.getAttribute('data-figma-id'), 'Name:', currentVariant.getAttribute('data-figma-name'));
        
        if (!currentVariant) {
          console.log('DEBUG: No current variant provided, returning empty array');
          return [];
        }
        
        const targetElements = targetVariant.querySelectorAll('[data-figma-id]');
        const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');
        const sourceElementMap = new Map();
        const elementsToAnimate = [];

        console.log('DEBUG: Found', targetElements.length, 'target elements and', sourceElements.length, 'source elements');

        // Build source element map by name
        sourceElements.forEach(function(sourceElement) {
          const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');
          if (sourceName) {
            sourceElementMap.set(sourceName, sourceElement);
            console.log('  Mapped source element:', sourceName, '->', sourceElement.getAttribute('data-figma-id'));
          }
        });

        // Analyze each target element for property changes
        targetElements.forEach(function(element, index) {
          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
          const sourceElement = sourceElementMap.get(targetName);
          
          console.log('DEBUG: Analyzing target element ' + (index + 1) + ':', targetName);
          console.log('  Target element ID:', element.getAttribute('data-figma-id'));
          console.log('  Source element found:', !!sourceElement);
          
          if (sourceElement) {
            console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));
            const changes = detectPropertyChanges(element, sourceElement);
            
            if (changes.hasChanges) {
              elementsToAnimate.push({
                element: sourceElement,  // Use SOURCE element (from copy) instead of target
                sourceElement: sourceElement,
                changes: changes
              });
              console.log('DEBUG: Found element with property changes:', targetName, 'changes:', changes);
            } else {
              console.log('DEBUG: No changes detected for element:', targetName);
            }
          } else {
            console.log('DEBUG: No matching source element found for:', targetName);
          }
        });
        
        console.log('DEBUG: Returning', elementsToAnimate.length, 'elements to animate');
        return elementsToAnimate;
      }

      // Helper function to detect property changes between elements
      function detectPropertyChanges(targetElement, sourceElement) {
        const changes = {
          hasChanges: false,
          positionX: { changed: false, sourceValue: null, targetValue: null },
          positionY: { changed: false, sourceValue: null, targetValue: null },
          backgroundColor: { changed: false, sourceValue: null, targetValue: null },
          color: { changed: false, sourceValue: null, targetValue: null },
          justifyContent: { changed: false, sourceValue: null, targetValue: null },
          alignItems: { changed: false, sourceValue: null, targetValue: null }
        };

        try {
          // Check position changes by comparing the computed styles
          const sourceStyle = window.getComputedStyle(sourceElement);
          const targetStyle = window.getComputedStyle(targetElement);
          
          // Check left position changes - use Figma data attributes for more accurate positioning
          const sourceLeft = parseFloat(sourceStyle.left) || 0;
          const targetLeft = parseFloat(targetStyle.left) || 0;
          
          // Get Figma position data for more accurate target positioning
          const sourceFigmaX = parseFloat(sourceElement.getAttribute('data-figma-x')) || 0;
          const targetFigmaX = parseFloat(targetElement.getAttribute('data-figma-x')) || 0;
          
          // CRITICAL FIX: Check if the source element has a transform applied from a previous animation
          // If so, we need to account for that in the position calculation
          const sourceTransform = sourceStyle.transform;
          let sourceTransformOffset = 0;
          if (sourceTransform && sourceTransform !== 'none') {
            // Extract translateX value from transform matrix
            const matrix = new DOMMatrix(sourceTransform);
            sourceTransformOffset = matrix.m41; // m41 is the translateX value
            console.log('DEBUG: Source element has transform:', sourceTransform, 'translateX offset:', sourceTransformOffset);
          }
          
          // Log detailed information about the elements
          const sourceName = sourceElement.getAttribute('data-figma-name');
          const targetName = targetElement.getAttribute('data-figma-name');
          const sourceId = sourceElement.getAttribute('data-figma-id');
          const targetId = targetElement.getAttribute('data-figma-id');
          
          console.log('DEBUG: Analyzing elements:');
          console.log('  Source:', sourceName, 'ID:', sourceId, 'Left:', sourceLeft, 'FigmaX:', sourceFigmaX);
          console.log('  Target:', targetName, 'ID:', targetId, 'Left:', targetLeft, 'FigmaX:', targetFigmaX);
          
          // Log parent container dimensions
          const sourceContainer = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          const targetContainer = targetElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          
          if (sourceContainer) {
            const sourceContainerRect = sourceContainer.getBoundingClientRect();
            console.log('  Source container dimensions:', sourceContainerRect.width, 'x', sourceContainerRect.height);
          }
          
          if (targetContainer) {
            const targetContainerRect = targetContainer.getBoundingClientRect();
            console.log('  Target container dimensions:', targetContainerRect.width, 'x', targetContainerRect.height);
          }
          
          // Log viewport dimensions
          console.log('  Viewport dimensions:', window.innerWidth, 'x', window.innerHeight);
          
          // Log element dimensions
          const sourceRect = sourceElement.getBoundingClientRect();
          const targetRect = targetElement.getBoundingClientRect();
          console.log('  Source element dimensions:', sourceRect.width, 'x', sourceRect.height);
          console.log('  Target element dimensions:', targetRect.width, 'x', targetRect.height);
          
          // Check if target element is properly rendered
          if (targetRect.width === 0 && targetRect.height === 0) {
            console.log('DEBUG: Target element has zero dimensions, skipping animation');
            return changes;
          }
          
          // CRITICAL FIX: Use current computed position for source if element has been animated
          // This ensures we detect changes from the actual current position, not the original Figma position
          const sourceHasBeenAnimated = sourceElement.style.position === 'absolute' && 
                                       (sourceElement.style.left || sourceElement.style.top);
          
          // Calculate target position by scaling Figma coordinates to actual rendered size
          // Use SOURCE element's parent (copy) for scaling since we're animating the copy
          const sourceContainerForScaling = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          const targetContainerForScaling = sourceElement.closest('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
          
          let finalTargetLeft = 0; // Start with 0, will be calculated below
          let finalTargetTop = 0; // Start with 0, will be calculated below
          // Always use computed styles for consistency
          let finalSourceLeft = parseFloat(sourceStyle.left) || 0;
          let finalSourceTop = parseFloat(sourceStyle.top) || 0;
          
          // Add transform offset if present
          finalSourceLeft += sourceTransformOffset;
          
          // Check if the source element has a transform applied from a previous animation
          // If so, we need to account for that in the position calculation
          let sourceTransformYOffset = 0;
          if (sourceTransform && sourceTransform !== 'none') {
            // Extract translateY value from transform matrix
            const matrix = new DOMMatrix(sourceTransform);
            sourceTransformYOffset = matrix.m42; // m42 is the translateY value
            console.log('DEBUG: Source element has transform:', sourceTransform, 'translateY offset:', sourceTransformYOffset);
          }
          
          // Add transform offset if present
          finalSourceTop += sourceTransformYOffset;
          
          // STEP 1-2: Query source and target to observe value differences
          // Check for alignment/justify differences between source and target parents
          const sourceParent = sourceElement.parentElement;
          const targetParent = targetElement.parentElement;
          
          if (sourceParent && targetParent) {
            const sourceParentStyle = window.getComputedStyle(sourceParent);
            const targetParentStyle = window.getComputedStyle(targetParent);
            
            const sourceJustifyContent = sourceParentStyle.justifyContent;
            const targetJustifyContent = targetParentStyle.justifyContent;
            const sourceAlignItems = sourceParentStyle.alignItems;
            const targetAlignItems = targetParentStyle.alignItems;
            
            console.log('DEBUG: Alignment analysis:', {
              sourceJustifyContent,
              targetJustifyContent,
              sourceAlignItems,
              targetAlignItems,
              sourceElementId: sourceElement.getAttribute('data-figma-id'),
              targetElementId: targetElement.getAttribute('data-figma-id')
            });
            
            // STEP 3: If there's an alignment/justify difference, it's ultimately a position change
            const hasJustifyChange = sourceJustifyContent !== targetJustifyContent;
            const hasAlignChange = sourceAlignItems !== targetAlignItems;
            
            if (hasJustifyChange || hasAlignChange) {
              console.log('DEBUG: Alignment/justify change detected - calculating position difference');
              
              // STEP 4: Query the corresponding nodes in source and target to find absolute/computed position
              const sourceRect = sourceElement.getBoundingClientRect();
              const targetRect = targetElement.getBoundingClientRect();
              const sourceParentRect = sourceParent.getBoundingClientRect();
              const targetParentRect = targetParent.getBoundingClientRect();
              
              // Calculate relative positions within their containers
              const sourceRelativeLeft = sourceRect.left - sourceParentRect.left;
              const targetRelativeLeft = targetRect.left - targetParentRect.left;
              const sourceRelativeTop = sourceRect.top - sourceParentRect.top;
              const targetRelativeTop = targetRect.top - targetParentRect.top;
              
              console.log('DEBUG: Position analysis:', {
                sourceRelativeLeft,
                targetRelativeLeft,
                sourceRelativeTop,
                targetRelativeTop,
                xDifference: Math.abs(sourceRelativeLeft - targetRelativeLeft),
                yDifference: Math.abs(sourceRelativeTop - targetRelativeTop)
              });
              
              // STEP 5: Calculate position difference
              const xDifference = targetRelativeLeft - sourceRelativeLeft;
              const yDifference = targetRelativeTop - sourceRelativeTop;
              
              // STEP 6: Set up animation values
              if (Math.abs(xDifference) > 1) {
                finalTargetLeft = finalSourceLeft + xDifference;
                console.log('DEBUG: X position change calculated:', {
                  sourceLeft: finalSourceLeft,
                  targetLeft: finalTargetLeft,
                  difference: xDifference,
                  justifyChange: hasJustifyChange ? (sourceJustifyContent + ' -> ' + targetJustifyContent) : 'none'
                });
              }
              
              if (Math.abs(yDifference) > 1) {
                finalTargetTop = finalSourceTop + yDifference;
                console.log('DEBUG: Y position change calculated:', {
                  sourceTop: finalSourceTop,
                  targetTop: finalTargetTop,
                  difference: yDifference,
                  alignChange: hasAlignChange ? (sourceAlignItems + ' -> ' + targetAlignItems) : 'none'
                });
              }
            } else {
              console.log('DEBUG: No alignment/justify changes detected');
              // Fallback to direct position comparison if no alignment changes
              const sourceRect = sourceElement.getBoundingClientRect();
              const targetRect = targetElement.getBoundingClientRect();
              const sourceParentRect = sourceParent.getBoundingClientRect();
              const targetParentRect = targetParent.getBoundingClientRect();
              
              const sourceRelativeLeft = sourceRect.left - sourceParentRect.left;
              const targetRelativeLeft = targetRect.left - targetParentRect.left;
              const sourceRelativeTop = sourceRect.top - sourceParentRect.top;
              const targetRelativeTop = targetRect.top - targetParentRect.top;
              
              finalTargetLeft = targetRelativeLeft;
              finalTargetTop = targetRelativeTop;
            }
          } else {
            console.log('DEBUG: No parent elements found, using fallback calculation');
            finalTargetLeft = parseFloat(targetStyle.left) || 0;
            finalTargetTop = parseFloat(targetStyle.top) || 0;
          }
          
          console.log('DEBUG: X Position Analysis:');
          console.log('  Source has been animated:', sourceHasBeenAnimated);
          console.log('  Source computed left:', sourceLeft, 'Source Figma X:', sourceFigmaX, 'Transform offset:', sourceTransformOffset, 'Final source left:', finalSourceLeft);
          console.log('  Target computed left:', targetLeft, 'Target Figma X:', targetFigmaX, 'Final target left:', finalTargetLeft);
          
          if (Math.abs(finalSourceLeft - finalTargetLeft) > 1) {
            changes.positionX.changed = true;
            changes.positionX.sourceValue = finalSourceLeft;
            changes.positionX.targetValue = finalTargetLeft;
            changes.hasChanges = true;
            console.log('DEBUG: Position X change detected:', finalSourceLeft, '->', finalTargetLeft, '(scaled from Figma coordinates)');
            console.log('DEBUG: Position X change details:');
            console.log('  Source element rect:', sourceElement.getBoundingClientRect());
            console.log('  Target element rect:', targetElement.getBoundingClientRect());
            console.log('  Source element computed style:', window.getComputedStyle(sourceElement).left);
            console.log('  Target element computed style:', window.getComputedStyle(targetElement).left);
          } else {
            console.log('DEBUG: No X position change detected - difference:', Math.abs(finalSourceLeft - finalTargetLeft));
          }
          
          // Y position calculation is now handled in the X position section above
          // where we calculate both X and Y positions together based on alignment changes
          
          console.log('DEBUG: Y Position Analysis:');
          console.log('  Final source top:', finalSourceTop);
          console.log('  Final target top:', finalTargetTop);
          console.log('  Difference:', Math.abs(finalSourceTop - finalTargetTop));
          
          if (Math.abs(finalSourceTop - finalTargetTop) > 1) {
            changes.positionY.changed = true;
            changes.positionY.sourceValue = finalSourceTop;
            changes.positionY.targetValue = finalTargetTop;
            changes.hasChanges = true;
            console.log('DEBUG: Position Y change detected:', finalSourceTop, '->', finalTargetTop);
          } else {
            console.log('DEBUG: No Y position change detected - difference:', Math.abs(finalSourceTop - finalTargetTop));
          }

          // Check style changes - use more specific comparison
          const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          
          if (sourceBg !== targetBg) {
            changes.backgroundColor.changed = true;
            changes.backgroundColor.sourceValue = sourceBg;
            changes.backgroundColor.targetValue = targetBg;
            changes.hasChanges = true;
            console.log('DEBUG: Background color change detected:', sourceBg, '->', targetBg);
          }
          
          if (sourceStyle.color !== targetStyle.color) {
            changes.color.changed = true;
            changes.color.sourceValue = sourceStyle.color;
            changes.color.targetValue = targetStyle.color;
            changes.hasChanges = true;
            console.log('DEBUG: Color change detected:', sourceStyle.color, '->', targetStyle.color);
          }
          
          if (sourceStyle.justifyContent !== targetStyle.justifyContent) {
            changes.justifyContent.changed = true;
            changes.justifyContent.sourceValue = sourceStyle.justifyContent;
            changes.justifyContent.targetValue = targetStyle.justifyContent;
            changes.hasChanges = true;
          }
          
          if (sourceStyle.alignItems !== targetStyle.alignItems) {
            changes.alignItems.changed = true;
            changes.alignItems.sourceValue = sourceStyle.alignItems;
            changes.alignItems.targetValue = targetStyle.alignItems;
            changes.hasChanges = true;
          }
        } catch (error) {
          console.log('DEBUG: Error detecting property changes:', error);
        }

        return changes;
      }
  
      
      // Global transition lock to prevent multiple simultaneous transitions
      let isTransitionInProgress = false;
      let currentTransitionPromise = null;
      
      // Animation types
      const AnimationType = {
        SIMPLE: 'SIMPLE',
        SIZE: 'SIZE', 
        TRANSFORM: 'TRANSFORM'
      };
      
      // Translation conditions
      const TranslationCondition = {
        ABSOLUTE: 'ABSOLUTE',
        RELATIVE_PADDING: 'RELATIVE_PADDING',
        RELATIVE_ALIGNMENT: 'RELATIVE_ALIGNMENT'
      };
      
      // Helper function to determine animation type for a property
      function getAnimationType(property) {
        const simpleProperties = [
          'opacity', 'color', 'backgroundColor', 'cornerRadius', 'borderRadius',
          'fontSize', 'fontWeight', 'textAlign', 'letterSpacing', 'lineHeight'
        ];
        
        const sizeProperties = [
          'width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'
        ];
        
        const transformProperties = [
          'translateX', 'translateY', 'translateZ', 'rotation', 'scale', 'transform'
        ];
        
        if (simpleProperties.includes(property)) {
          return AnimationType.SIMPLE;
        } else if (sizeProperties.includes(property)) {
          return AnimationType.SIZE;
        } else if (transformProperties.includes(property)) {
          return AnimationType.TRANSFORM;
        }
        
        return AnimationType.SIMPLE;
      }
      
      // Helper function to determine translation condition
      function getTranslationCondition(element, node, parentNode) {
        const ignoreAutoLayout = node.layoutPositioning === 'ABSOLUTE';
        
        const parentHasAutoLayout = parentNode && 
                                   parentNode.type === 'FRAME' && 
                                   parentNode.layoutMode && 
                                   parentNode.layoutMode !== 'NONE';
        
        if (ignoreAutoLayout || !parentHasAutoLayout) {
          return TranslationCondition.ABSOLUTE;
        }
        
        if (parentHasAutoLayout) {
          // For now, default to padding-based relative positioning
          // This could be enhanced to detect which type of relative positioning is needed
          return TranslationCondition.RELATIVE_PADDING;
        }
        
        return TranslationCondition.ABSOLUTE;
      }
      
      // Helper function to detect animation changes
      function detectAnimationChanges(sourceElement, targetElement, sourceNode, targetNode, parentNode) {
        const changes = [];
        
        const sourceStyle = window.getComputedStyle(sourceElement);
        const targetStyle = window.getComputedStyle(targetElement);
        
        // Check simple properties
        const simpleProperties = ['opacity', 'backgroundColor', 'color'];
        simpleProperties.forEach(property => {
          const sourceValue = sourceStyle[property];
          const targetValue = targetStyle[property];
          
          if (sourceValue !== targetValue) {
            changes.push({
              type: AnimationType.SIMPLE,
              property,
              sourceValue,
              targetValue,
              changed: true
            });
          }
        });
        
        // Check size properties
        const sizeProperties = ['width', 'height'];
        sizeProperties.forEach(property => {
          const sourceValue = parseFloat(sourceStyle[property]) || 0;
          const targetValue = parseFloat(targetStyle[property]) || 0;
          
          if (Math.abs(sourceValue - targetValue) > 1) {
            changes.push({
              type: AnimationType.SIZE,
              property,
              sourceValue,
              targetValue,
              changed: true
            });
          }
        });
        
        // Check transform properties based on translation condition
        const translationCondition = getTranslationCondition(sourceElement, sourceNode, parentNode);
        
        console.log('DEBUG: Translation condition detected:', translationCondition);
        
        if (translationCondition === TranslationCondition.ABSOLUTE) {
          // Check left/top changes for absolute positioning
          const sourceLeft = parseFloat(sourceStyle.left) || 0;
          const targetLeft = parseFloat(targetStyle.left) || 0;
          const sourceTop = parseFloat(sourceStyle.top) || 0;
          const targetTop = parseFloat(targetStyle.top) || 0;
          
          if (Math.abs(sourceLeft - targetLeft) > 1) {
            changes.push({
              type: AnimationType.TRANSFORM,
              property: 'translateX',
              sourceValue: sourceLeft,
              targetValue: targetLeft,
              changed: true,
              translationCondition
            });
          }
          
          if (Math.abs(sourceTop - targetTop) > 1) {
            changes.push({
              type: AnimationType.TRANSFORM,
              property: 'translateY',
              sourceValue: sourceTop,
              targetValue: targetTop,
              changed: true,
              translationCondition
            });
          }
        } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {
          // Check parent padding changes
          const sourceParent = sourceElement.parentElement;
          const targetParent = targetElement.parentElement;
          
          if (sourceParent && targetParent) {
            const sourceParentStyle = window.getComputedStyle(sourceParent);
            const targetParentStyle = window.getComputedStyle(targetParent);
            
            const paddingProperties = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'];
            paddingProperties.forEach(property => {
              const sourceValue = parseFloat(sourceParentStyle[property]) || 0;
              const targetValue = parseFloat(targetParentStyle[property]) || 0;
              
              if (Math.abs(sourceValue - targetValue) > 1) {
                changes.push({
                  type: AnimationType.TRANSFORM,
                  property: `parent_${property}`,
                  sourceValue,
                  targetValue,
                  changed: true,
                  translationCondition
                });
              }
            });
          }
        } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {
          // Check parent alignment changes - ENHANCED FOR JUSTIFYCONTENT
          const sourceParent = sourceElement.parentElement;
          const targetParent = targetElement.parentElement;
          
          if (sourceParent && targetParent) {
            const sourceParentStyle = window.getComputedStyle(sourceParent);
            const targetParentStyle = window.getComputedStyle(targetParent);
            
            // Check alignment properties with detailed logging
            const alignmentProperties = ['justifyContent', 'alignItems', 'textAlign', 'verticalAlign'];
            
            console.log('DEBUG: Checking alignment properties for RELATIVE_ALIGNMENT');
            
            alignmentProperties.forEach(property => {
              const sourceValue = sourceParentStyle[property];
              const targetValue = targetParentStyle[property];
              
              console.log(`DEBUG: Parent ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });
              
              if (sourceValue !== targetValue) {
                changes.push({
                  type: AnimationType.TRANSFORM,
                  property: `parent_${property}`,
                  sourceValue: sourceValue || '',
                  targetValue: targetValue || '',
                  changed: true,
                  translationCondition
                });
              }
            });
            
            // Check element's own alignment properties
            alignmentProperties.forEach(property => {
              const sourceValue = sourceStyle[property];
              const targetValue = targetStyle[property];
              
              console.log(`DEBUG: Element ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });
              
              if (sourceValue !== targetValue) {
                changes.push({
                  type: AnimationType.TRANSFORM,
                  property: property,
                  sourceValue: sourceValue || '',
                  targetValue: targetValue || '',
                  changed: true,
                  translationCondition
                });
              }
            });
            
            // Check for flexbox-specific properties
            const flexProperties = ['flexDirection', 'flexWrap', 'alignContent', 'justifyItems'];
            flexProperties.forEach(property => {
              const sourceValue = sourceParentStyle[property];
              const targetValue = targetParentStyle[property];
              
              console.log(`DEBUG: Flex ${property}:`, { sourceValue, targetValue, changed: sourceValue !== targetValue });
              
              if (sourceValue !== targetValue) {
                changes.push({
                  type: AnimationType.TRANSFORM,
                  property: `parent_${property}`,
                  sourceValue: sourceValue || '',
                  targetValue: targetValue || '',
                  changed: true,
                  translationCondition
                });
              }
            });
            
            // Check for position changes that might be due to alignment
            // Even if alignment values are the same, the computed position might differ
            const sourceRect = sourceElement.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();
            const sourceParentRect = sourceParent.getBoundingClientRect();
            const targetParentRect = targetParent.getBoundingClientRect();
            
            // Calculate relative positions within their containers
            const sourceRelativeX = sourceRect.left - sourceParentRect.left;
            const targetRelativeX = targetRect.left - targetParentRect.left;
            const sourceRelativeY = sourceRect.top - sourceParentRect.top;
            const targetRelativeY = targetRect.top - targetParentRect.top;
            
            console.log('DEBUG: Relative position analysis:', {
              sourceRelativeX,
              targetRelativeX,
              sourceRelativeY,
              targetRelativeY,
              xDifference: Math.abs(sourceRelativeX - targetRelativeX),
              yDifference: Math.abs(sourceRelativeY - targetRelativeY)
            });
            
            // If there's a significant position difference, it might be due to alignment
            if (Math.abs(sourceRelativeX - targetRelativeX) > 1) {
              changes.push({
                type: AnimationType.TRANSFORM,
                property: 'alignTranslateX',
                sourceValue: sourceRelativeX,
                targetValue: targetRelativeX,
                changed: true,
                translationCondition
              });
            }
            
            if (Math.abs(sourceRelativeY - targetRelativeY) > 1) {
              changes.push({
                type: AnimationType.TRANSFORM,
                property: 'alignTranslateY',
                sourceValue: sourceRelativeY,
                targetValue: targetRelativeY,
                changed: true,
                translationCondition
              });
            }
          }
        }
        
        console.log('DEBUG: Total changes detected:', changes.length, changes);
        return changes;
      }
      
      // Helper function to apply animation changes
      function applyAnimationChange(element, change, duration, easing) {
        const { type, property, targetValue, translationCondition, destination } = change;
        
        console.log('DEBUG: Applying animation change:', { type, property, targetValue, translationCondition });
        
        // Get transition property
        let transitionProperty = property;
        if (type === AnimationType.TRANSFORM) {
          if (translationCondition === TranslationCondition.ABSOLUTE) {
            transitionProperty = property === 'translateX' ? 'left' : 'top';
          } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {
            transitionProperty = property.replace('parent_', '');
          } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {
            if (property === 'alignTranslateX' || property === 'alignTranslateY') {
              transitionProperty = property === 'alignTranslateX' ? 'left' : 'top';
            } else if (property.startsWith('parent_')) {
              // For alignment changes, animate the element's position instead of the parent's alignment
              if (property === 'parent_justifyContent') {
                // Use the target element's actual position from the destination variant
                const sourceElementName = element.getAttribute('data-figma-name');
                const targetElement = destination.querySelector(`[data-figma-name="${sourceElementName}"]`);
                
                if (targetElement) {
                  const targetRect = targetElement.getBoundingClientRect();
                  const parent = element.parentElement;
                  const parentRect = parent.getBoundingClientRect();
                  
                  // Calculate the target position relative to the parent
                  const targetLeft = targetRect.left - parentRect.left;
                  
                  console.log('DEBUG: Calculating justifyContent animation using target position:', {
                    currentLeft: element.getBoundingClientRect().left - parentRect.left,
                    targetLeft: targetLeft,
                    targetElementId: targetElement.getAttribute('data-figma-id'),
                    targetElementName: sourceElementName,
                    justifyContent: targetValue
                  });
                  
                  // Set transition for left position
                  element.style.transition = `left ${duration}s ${easing}`;
                  element.style.left = `${targetLeft}px`;
                  
                  console.log('DEBUG: Applied justifyContent animation via target position:', {
                    property: 'left',
                    transitionProperty: 'left',
                    targetValue: `${targetLeft}px`
                  });
                  
                  return; // Skip the default handling
                } else {
                  console.log('DEBUG: Target element not found in destination by name:', sourceElementName);
                }
              } else if (property === 'parent_alignItems') {
                // Use the target element's actual position from the destination variant
                const sourceElementName = element.getAttribute('data-figma-name');
                const targetElement = destination.querySelector(`[data-figma-name="${sourceElementName}"]`);
                
                if (targetElement) {
                  const targetRect = targetElement.getBoundingClientRect();
                  const parent = element.parentElement;
                  const parentRect = parent.getBoundingClientRect();
                  
                  // Calculate the target position relative to the parent
                  const targetTop = targetRect.top - parentRect.top;
                  
                  console.log('DEBUG: Calculating alignItems animation using target position:', {
                    currentTop: element.getBoundingClientRect().top - parentRect.top,
                    targetTop: targetTop,
                    targetElementId: targetElement.getAttribute('data-figma-id'),
                    targetElementName: sourceElementName,
                    alignItems: targetValue
                  });
                  
                  // Set transition for top position
                  element.style.transition = `top ${duration}s ${easing}`;
                  element.style.top = `${targetTop}px`;
                  
                  console.log('DEBUG: Applied alignItems animation via target position:', {
                    property: 'top',
                    transitionProperty: 'top',
                    targetValue: `${targetTop}px`
                  });
                  
                  return; // Skip the default handling
                } else {
                  console.log('DEBUG: Target element not found in destination by name:', sourceElementName);
                }
              }
              transitionProperty = property.replace('parent_', '');
            } else {
              transitionProperty = property;
            }
          }
        }
        
        // Set up transition
        element.style.transition = `${transitionProperty} ${duration}s ${easing}`;
        
        // Apply the change based on type and condition
        switch (type) {
          case AnimationType.SIMPLE:
            element.style[property] = targetValue;
            break;
            
          case AnimationType.SIZE:
            element.style[property] = `${targetValue}px`;
            break;
            
          case AnimationType.TRANSFORM:
            if (translationCondition === TranslationCondition.ABSOLUTE) {
              if (property === 'translateX') {
                element.style.left = `${targetValue}px`;
              } else if (property === 'translateY') {
                element.style.top = `${targetValue}px`;
              }
            } else if (translationCondition === TranslationCondition.RELATIVE_PADDING) {
              if (element.parentElement) {
                const paddingProperty = property.replace('parent_', '');
                element.parentElement.style[paddingProperty] = `${targetValue}px`;
              }
            } else if (translationCondition === TranslationCondition.RELATIVE_ALIGNMENT) {
              if (property === 'alignTranslateX') {
                element.style.left = `${targetValue}px`;
              } else if (property === 'alignTranslateY') {
                element.style.top = `${targetValue}px`;
              } else if (property.startsWith('parent_')) {
                if (element.parentElement) {
                  const alignmentProperty = property.replace('parent_', '');
                  element.parentElement.style[alignmentProperty] = targetValue;
                }
              } else {
                // Direct property change on the element
                element.style[property] = targetValue;
              }
            }
            break;
        }
        
        console.log('DEBUG: Applied change:', { property, transitionProperty, targetValue });
      }
      
      // Helper function to get easing function
      function getEasingFunction(animationType) {
        switch (animationType) {
          case 'EASE_IN_AND_OUT_BACK':
            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';
          case 'EASE_IN_AND_OUT':
            return 'ease-in-out';
          case 'EASE_IN':
            return 'ease-in';
          case 'EASE_OUT':
            return 'ease-out';
          case 'LINEAR':
            return 'linear';
          case 'BOUNCY':
            return 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';
          case 'GENTLE':
            return 'ease-in-out';
          case 'SMART_ANIMATE':
            return 'ease-in-out';
          default:
            return 'ease-out';
        }
      }
      
      // Helper function to create element copy
      function createElementCopy(sourceElement) {
        console.log('DEBUG: createElementCopy function called');
        console.log('DEBUG: Creating element copy for:', sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id'));
        
        const copy = sourceElement.cloneNode(true);
        copy.setAttribute('data-figma-id', sourceElement.getAttribute('data-figma-id') + '-copy');
        copy.setAttribute('data-is-animation-copy', 'true');
        
        // Preserve current positions from source element
        const copyElements = copy.querySelectorAll('*');
        copyElements.forEach(element => {
          if (element.hasAttribute('data-figma-id')) {
            const sourceElementId = element.getAttribute('data-figma-id');
            const sourceElementMatch = sourceElement.querySelector(`[data-figma-id="${sourceElementId}"]`);
            
            if (sourceElementMatch) {
              const currentLeft = sourceElementMatch.style.left || window.getComputedStyle(sourceElementMatch).left || '0px';
              const currentTop = sourceElementMatch.style.top || window.getComputedStyle(sourceElementMatch).top || '0px';
              
              element.style.position = 'relative';
              element.style.left = currentLeft;
              element.style.top = currentTop;
              
              element.style.removeProperty('transform');
              element.style.removeProperty('margin');
              element.style.removeProperty('padding');
              
              element.style.setProperty('left', currentLeft, 'important');
              element.style.setProperty('top', currentTop, 'important');
            } else {
              element.style.position = 'relative';
              element.style.left = '0px';
              element.style.top = '0px';
            }
          }
        });
        
        // Position the copy absolutely over the source element
        const sourceRect = sourceElement.getBoundingClientRect();
        const parentRect = sourceElement.parentElement.getBoundingClientRect();
        
        copy.style.position = 'absolute';
        copy.style.top = (sourceRect.top - parentRect.top) + 'px';
        copy.style.left = (sourceRect.left - parentRect.left) + 'px';
        copy.style.transform = 'none';
        copy.style.margin = '0';
        copy.style.padding = '0';
        
        // Set high z-index
        const allElements = document.querySelectorAll('*');
        let maxZIndex = 0;
        allElements.forEach(el => {
          const zIndex = parseInt(window.getComputedStyle(el).zIndex) || 0;
          if (zIndex > maxZIndex) maxZIndex = zIndex;
        });
        
        const copyZIndex = maxZIndex + 1000;
        copy.style.zIndex = copyZIndex.toString();
        copy.style.pointerEvents = 'none';
        copy.style.transform = 'translateZ(0)';
        copy.style.willChange = 'transform, left, top';
        
        // Ensure the copy container doesn't clip its children
        copy.style.overflow = 'visible';
        
        // Ensure the copy and all its children are fully visible
        copy.style.opacity = '1';
        copy.style.visibility = 'visible';
        copy.style.display = 'flex';

        // Ensure all nested elements in the copy are also visible
        const copyChildren = copy.querySelectorAll('*');
        copyChildren.forEach(child => {
          child.style.opacity = '1';
          child.style.visibility = 'visible';
          child.style.overflow = 'visible';
          if (child.style.display === 'none') {
            child.style.display = 'flex';
          }
        });

        // Debug: Log the initial visibility properties of all nodes in the copy
        console.log('DEBUG: Copy element visibility properties:');
        const nodesWithFigmaId = copy.querySelectorAll('[data-figma-id]');
        console.log('DEBUG: Found', nodesWithFigmaId.length, 'nodes with data-figma-id in copy');
        
        nodesWithFigmaId.forEach((node, index) => {
          const figmaName = node.getAttribute('data-figma-name') || 'Unknown';
          console.log('  Node', index + 1, '(' + figmaName + '):');
          console.log('    opacity:', window.getComputedStyle(node).opacity);
          console.log('    display:', window.getComputedStyle(node).display);
          console.log('    visibility:', window.getComputedStyle(node).visibility);
          console.log('    position:', window.getComputedStyle(node).position);
          console.log('    left:', window.getComputedStyle(node).left);
          console.log('    top:', window.getComputedStyle(node).top);
        });
        
        // Log the opacity and display properties of each node in the copy
        console.log('DEBUG: Copy element visibility properties:');
        const copyNodes = copy.querySelectorAll('[data-figma-id]');
        console.log('DEBUG: Found', copyNodes.length, 'nodes with data-figma-id in copy');
        copyNodes.forEach((node, index) => {
          const nodeName = node.getAttribute('data-figma-name') || node.getAttribute('data-figma-id');
          const computedStyle = window.getComputedStyle(node);
          const opacity = computedStyle.opacity;
          const display = computedStyle.display;
          const visibility = computedStyle.visibility;
          const position = computedStyle.position;
          const left = computedStyle.left;
          const top = computedStyle.top;
          
          console.log('  Node ' + (index + 1) + ' (' + nodeName + '):');
          console.log('    opacity: ' + opacity);
          console.log('    display: ' + display);
          console.log('    visibility: ' + visibility);
          console.log('    position: ' + position);
          console.log('    left: ' + left);
          console.log('    top: ' + top);
        });
        
        console.log('DEBUG: Copy creation completed');
        return copy;
      }
      
      // Helper function to update copy content to match destination
      function updateCopyContentToMatchDestination(copy, destination) {
        console.log('DEBUG: Updating copy content to match destination');
        
        // Get all elements in both copy and destination
        const copyElements = copy.querySelectorAll('[data-figma-id]');
        const destinationElements = destination.querySelectorAll('[data-figma-id]');
        
        // Create a map of destination elements by name
        const destinationElementMap = new Map();
        destinationElements.forEach(element => {
          const name = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
          if (name) {
            destinationElementMap.set(name, element);
          }
        });
        
        // Update each copy element's content to match destination
        copyElements.forEach(copyElement => {
          const copyElementName = copyElement.getAttribute('data-figma-name') || copyElement.getAttribute('data-figma-id');
          const destinationElement = destinationElementMap.get(copyElementName);
          
          console.log('DEBUG: Checking content for', copyElementName);
          console.log('  Copy textContent:', copyElement.textContent);
          console.log('  Copy innerHTML:', copyElement.innerHTML.substring(0, 200));
          if (destinationElement) {
            console.log('  Destination textContent:', destinationElement.textContent);
            console.log('  Destination innerHTML:', destinationElement.innerHTML.substring(0, 200));
          }
          
          if (destinationElement) {
            // Update text content
            if (destinationElement.textContent !== copyElement.textContent) {
              const oldText = copyElement.textContent;
              copyElement.textContent = destinationElement.textContent;
              console.log('DEBUG: Updated text content for', copyElementName, 'from', oldText, 'to', destinationElement.textContent);
            }
            
            // Update innerHTML for more complex content
            if (destinationElement.innerHTML !== copyElement.innerHTML) {
              const oldHTML = copyElement.innerHTML;
              copyElement.innerHTML = destinationElement.innerHTML;
              console.log('DEBUG: Updated innerHTML for', copyElementName, 'from', oldHTML.substring(0, 100), 'to', destinationElement.innerHTML.substring(0, 100));
            }
            
            // Update specific attributes that might contain content
            const contentAttributes = ['data-content', 'data-text', 'title', 'alt'];
            contentAttributes.forEach(attr => {
              const destValue = destinationElement.getAttribute(attr);
              const copyValue = copyElement.getAttribute(attr);
              if (destValue !== copyValue && destValue !== null) {
                copyElement.setAttribute(attr, destValue);
                console.log('DEBUG: Updated attribute', attr, 'for', copyElementName, 'to', destValue);
              }
            });
          }
        });
        
        // Log the visibility properties after content update
        console.log('DEBUG: Copy element visibility properties after content update:');
        const copyNodes = copy.querySelectorAll('[data-figma-id]');
        copyNodes.forEach((node, index) => {
          const nodeName = node.getAttribute('data-figma-name') || node.getAttribute('data-figma-id');
          const computedStyle = window.getComputedStyle(node);
          const opacity = computedStyle.opacity;
          const display = computedStyle.display;
          const visibility = computedStyle.visibility;
          const position = computedStyle.position;
          const left = computedStyle.left;
          const top = computedStyle.top;
          
          console.log('  Node ' + (index + 1) + ' (' + nodeName + '):');
          console.log('    opacity: ' + opacity);
          console.log('    display: ' + display);
          console.log('    visibility: ' + visibility);
          console.log('    position: ' + position);
          console.log('    left: ' + left);
          console.log('    top: ' + top);
        });

        // Ensure all elements in the copy are visible after content update
        const allCopyElements = copy.querySelectorAll('*');
        allCopyElements.forEach(element => {
          element.style.opacity = '1';
          element.style.visibility = 'visible';
          element.style.overflow = 'visible';
          if (element.style.display === 'none') {
            element.style.display = 'flex';
          }
        });
      }
      
      // Helper function to animate copy to destination
      function animateCopyToDestination(copy, destination, transitionType, transitionDuration) {
        return new Promise((resolve) => {
          // Update copy content to match destination content
          updateCopyContentToMatchDestination(copy, destination);
          
          // Find elements with property changes
          const elementsToAnimate = findElementsWithPropertyChanges(destination, copy);
          
          const easingFunction = getEasingFunction(transitionType);
          const duration = parseFloat(transitionDuration || '0.3');
          
          if (elementsToAnimate.length > 0) {
            console.log('DEBUG: Animating copy with', elementsToAnimate.length, 'elements using modular system');
            
            // Setup animation for each element using the changes already detected
            elementsToAnimate.forEach(({ element, sourceElement, changes }) => {
              console.log('DEBUG: Processing element with changes:', changes);
              
              // Convert the detected changes to animation changes
              const animationChanges = [];
              
              // Handle position changes
              if (changes.positionX && changes.positionX.changed) {
                animationChanges.push({
                  type: AnimationType.TRANSFORM,
                  property: 'translateX',
                  sourceValue: changes.positionX.sourceValue,
                  targetValue: changes.positionX.targetValue,
                  changed: true,
                  translationCondition: TranslationCondition.ABSOLUTE
                });
              }
              
              if (changes.positionY && changes.positionY.changed) {
                animationChanges.push({
                  type: AnimationType.TRANSFORM,
                  property: 'translateY',
                  sourceValue: changes.positionY.sourceValue,
                  targetValue: changes.positionY.targetValue,
                  changed: true,
                  translationCondition: TranslationCondition.ABSOLUTE
                });
              }
              
              // Handle color changes
              if (changes.backgroundColor && changes.backgroundColor.changed) {
                animationChanges.push({
                  type: AnimationType.SIMPLE,
                  property: 'backgroundColor',
                  sourceValue: changes.backgroundColor.sourceValue,
                  targetValue: changes.backgroundColor.targetValue,
                  changed: true
                });
              }
              
              if (changes.color && changes.color.changed) {
                animationChanges.push({
                  type: AnimationType.SIMPLE,
                  property: 'color',
                  sourceValue: changes.color.sourceValue,
                  targetValue: changes.color.targetValue,
                  changed: true
                });
              }
              
              // Handle alignment changes
              if (changes.justifyContent && changes.justifyContent.changed) {
                // Calculate the position difference that the alignment change creates
                const parent = element.parentElement;
                if (parent) {
                  const parentRect = parent.getBoundingClientRect();
                  const elementRect = element.getBoundingClientRect();
                  const elementWidth = elementRect.width;
                  
                  // Calculate current position relative to parent
                  const currentLeft = elementRect.left - parentRect.left;
                  
                  // Calculate target position based on alignment change
                  let targetLeft = currentLeft;
                  if (changes.justifyContent.targetValue === 'flex-end') {
                    targetLeft = parentRect.width - elementWidth;
                  } else if (changes.justifyContent.targetValue === 'center') {
                    targetLeft = (parentRect.width - elementWidth) / 2;
                  } else if (changes.justifyContent.targetValue === 'flex-start') {
                    targetLeft = 0;
                  }
                  
                  // Only animate if there's actually a position difference
                  if (Math.abs(currentLeft - targetLeft) > 1) {
                    console.log('DEBUG: Calculating justifyContent position animation:', {
                      currentLeft: currentLeft,
                      targetLeft: targetLeft,
                      justifyContent: changes.justifyContent.targetValue,
                      parentWidth: parentRect.width,
                      elementWidth: elementWidth
                    });
                    
                    // Animate the position, NOT the alignment
                    element.style.transition = `left ${duration}s ${easingFunction}`;
                    element.style.left = `${targetLeft}px`;
                    
                    console.log('DEBUG: Applied justifyContent position animation:', {
                      property: 'left',
                      transitionProperty: 'left',
                      targetValue: `${targetLeft}px`
                    });
                  } else {
                    console.log('DEBUG: JustifyContent change detected but no position difference - skipping animation');
                  }
                  
                  // Don't add to animationChanges array since we're handling it directly
                  return;
                }
              }
              
              if (changes.alignItems && changes.alignItems.changed) {
                // Calculate the position difference that the alignment change creates
                const parent = element.parentElement;
                if (parent) {
                  const parentRect = parent.getBoundingClientRect();
                  const elementRect = element.getBoundingClientRect();
                  const elementHeight = elementRect.height;
                  
                  // Calculate current position relative to parent
                  const currentTop = elementRect.top - parentRect.top;
                  
                  // Calculate target position based on alignment change
                  let targetTop = currentTop;
                  if (changes.alignItems.targetValue === 'flex-end') {
                    targetTop = parentRect.height - elementHeight;
                  } else if (changes.alignItems.targetValue === 'center') {
                    targetTop = (parentRect.height - elementHeight) / 2;
                  } else if (changes.alignItems.targetValue === 'flex-start') {
                    targetTop = 0;
                  }
                  
                  // Only animate if there's actually a position difference
                  if (Math.abs(currentTop - targetTop) > 1) {
                    console.log('DEBUG: Calculating alignItems position animation:', {
                      currentTop: currentTop,
                      targetTop: targetTop,
                      alignItems: changes.alignItems.targetValue,
                      parentHeight: parentRect.height,
                      elementHeight: elementHeight
                    });
                    
                    // Animate the position, NOT the alignment
                    element.style.transition = `top ${duration}s ${easingFunction}`;
                    element.style.top = `${targetTop}px`;
                    
                    console.log('DEBUG: Applied alignItems position animation:', {
                      property: 'top',
                      transitionProperty: 'top',
                      targetValue: `${targetTop}px`
                    });
                  } else {
                    console.log('DEBUG: AlignItems change detected but no position difference - skipping animation');
                  }
                  
                  // Don't add to animationChanges array since we're handling it directly
                  return;
                }
              }
              
              // Note: justifyContent and alignItems changes are handled directly above
              // and only applied if there's an actual position difference
              
              console.log('DEBUG: Converted to animation changes:', animationChanges);
              
                          // Apply each change
            animationChanges.forEach(change => {
              applyAnimationChange(element, change, duration, easingFunction);
            });
          });
          
          // Force reflow
          copy.offsetHeight;
          
          // Log which elements are being animated and their transition properties
          console.log('DEBUG: Elements being animated:');
          elementsToAnimate.forEach(({ element }, index) => {
            const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
            const computedStyle = window.getComputedStyle(element);
            console.log('  Element ' + (index + 1) + ' (' + elementName + '):');
            console.log('    transition: ' + computedStyle.transition);
            console.log('    transform: ' + computedStyle.transform);
            console.log('    left: ' + computedStyle.left);
            console.log('    top: ' + computedStyle.top);
            console.log('    opacity: ' + computedStyle.opacity);
            console.log('    visibility: ' + computedStyle.visibility);
            console.log('    display: ' + computedStyle.display);
          });
          
          // Log the visibility properties after applying animations
          console.log('DEBUG: Copy element visibility properties after applying animations:');
          const copyNodes = copy.querySelectorAll('[data-figma-id]');
          copyNodes.forEach((node, index) => {
            const nodeName = node.getAttribute('data-figma-name') || node.getAttribute('data-figma-id');
            const computedStyle = window.getComputedStyle(node);
            const opacity = computedStyle.opacity;
            const display = computedStyle.display;
            const visibility = computedStyle.visibility;
            const position = computedStyle.position;
            const left = computedStyle.left;
            const top = computedStyle.top;
            const transform = computedStyle.transform;
            
            console.log('  Node ' + (index + 1) + ' (' + nodeName + '):');
            console.log('    opacity: ' + opacity);
            console.log('    display: ' + display);
            console.log('    visibility: ' + visibility);
            console.log('    position: ' + position);
            console.log('    left: ' + left);
            console.log('    top: ' + top);
            console.log('    transform: ' + transform);
          });
            
            // Apply target values
            requestAnimationFrame(() => {
              elementsToAnimate.forEach(({ element, sourceElement, changes }) => {
                // Convert the detected changes to animation changes (same as above)
                const animationChanges = [];
                
                if (changes.positionX && changes.positionX.changed) {
                  animationChanges.push({
                    type: AnimationType.TRANSFORM,
                    property: 'translateX',
                    sourceValue: changes.positionX.sourceValue,
                    targetValue: changes.positionX.targetValue,
                    changed: true,
                    translationCondition: TranslationCondition.ABSOLUTE
                  });
                }
                
                if (changes.positionY && changes.positionY.changed) {
                  animationChanges.push({
                    type: AnimationType.TRANSFORM,
                    property: 'translateY',
                    sourceValue: changes.positionY.sourceValue,
                    targetValue: changes.positionY.targetValue,
                    changed: true,
                    translationCondition: TranslationCondition.ABSOLUTE
                  });
                }
                
                if (changes.backgroundColor && changes.backgroundColor.changed) {
                  animationChanges.push({
                    type: AnimationType.SIMPLE,
                    property: 'backgroundColor',
                    sourceValue: changes.backgroundColor.sourceValue,
                    targetValue: changes.backgroundColor.targetValue,
                    changed: true
                  });
                }
                
                if (changes.color && changes.color.changed) {
                  animationChanges.push({
                    type: AnimationType.SIMPLE,
                    property: 'color',
                    sourceValue: changes.color.sourceValue,
                    targetValue: changes.color.targetValue,
                    changed: true
                  });
                }
                
                // Note: justifyContent and alignItems changes are handled directly above
                // and only applied if there's an actual position difference
                
                animationChanges.forEach(change => {
                  applyAnimationChange(element, change, duration, easingFunction);
                });
              });
            });
            
            // Monitor animation progress using transition end events
            let completedAnimations = 0;
            const totalAnimations = elementsToAnimate.length;
            
            console.log('DEBUG: Setting up animation monitoring for', totalAnimations, 'elements');
            
            // Track which elements have actually been animated and their transition properties
            const animatedElements = new Set();
            const transitionProperties = new Map(); // Track which properties are being transitioned
            
            // Also track which elements have been processed to avoid double-counting
            const processedElements = new Set();
            
            // Log what transitions we expect to see
            elementsToAnimate.forEach(({ element, changes }, index) => {
              const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
              console.log('DEBUG: Expecting transitions for element', index + 1, '(', elementName, '):');
              
              const elementProperties = [];
              
              if (changes.positionX && changes.positionX.changed) {
                console.log('  - positionX transition (left/top)');
                elementProperties.push('left', 'top');
              }
              if (changes.positionY && changes.positionY.changed) {
                console.log('  - positionY transition (left/top)');
                elementProperties.push('left', 'top');
              }
              if (changes.backgroundColor && changes.backgroundColor.changed) {
                console.log('  - backgroundColor transition');
                elementProperties.push('background-color');
              }
              if (changes.color && changes.color.changed) {
                console.log('  - color transition');
                elementProperties.push('color');
              }
              if (changes.justifyContent && changes.justifyContent.changed) {
                console.log('  - justifyContent transition (left)');
                elementProperties.push('left');
              }
              if (changes.alignItems && changes.alignItems.changed) {
                console.log('  - alignItems transition (top)');
                elementProperties.push('top');
              }
              
              // Remove duplicates and set the properties
              const uniqueProperties = [...new Set(elementProperties)];
              transitionProperties.set(element, uniqueProperties);
              console.log('DEBUG: Final transition properties for element', elementName, ':', uniqueProperties);
            });
            
            const onTransitionEnd = (event) => {
              const targetElement = event.target;
              const propertyName = event.propertyName;
              
              console.log('DEBUG: Transition end event fired for:', targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'), 'property:', propertyName);
              
              // Find which element this transition belongs to
              const animatedElement = elementsToAnimate.find(({ element }) => 
                targetElement === element || element.contains(targetElement)
              );
              
              if (animatedElement) {
                const elementKey = animatedElement.element;
                const expectedProperties = transitionProperties.get(elementKey) || [];
                
                console.log('DEBUG: Found matching animated element, expected properties:', expectedProperties);
                
                // Check if this is a property we're expecting to transition
                if (expectedProperties.includes(propertyName)) {
                  // Remove this property from the expected list
                  const updatedProperties = expectedProperties.filter(p => p !== propertyName);
                  transitionProperties.set(elementKey, updatedProperties);
                  
                  console.log('DEBUG: Property', propertyName, 'transition completed, remaining properties for this element:', updatedProperties);
                  
                  // If all properties for this element have completed, mark the element as done
                  if (updatedProperties.length === 0 && !animatedElements.has(elementKey)) {
                    animatedElements.add(elementKey);
                    completedAnimations++;
                    console.log('DEBUG: All transitions completed for element:', completedAnimations, '/', totalAnimations, 'for element:', targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'));
                    
                    if (completedAnimations >= totalAnimations) {
                      console.log('DEBUG: All animations completed');
                      copy.removeEventListener('transitionend', onTransitionEnd);
                      copy.removeEventListener('transitionend', onCopyTransitionEnd);
                      childElements.forEach(child => {
                        child.removeEventListener('transitionend', onTransitionEnd);
                      });
                      clearTimeout(fallbackTimeout);
                      clearInterval(intervalId);
                      resolve();
                    }
                  }
                } else {
                  console.log('DEBUG: Ignoring transition for unexpected property:', propertyName);
                }
              } else {
                // Check if this is a child element that might be part of an animated element
                const parentAnimatedElement = elementsToAnimate.find(({ element }) => 
                  element.contains(targetElement)
                );
                
                if (parentAnimatedElement && !processedElements.has(targetElement)) {
                  processedElements.add(targetElement);
                  console.log('DEBUG: Child element transition detected, marking parent as potentially complete');
                  
                  // For child elements, we'll use a simpler approach - just count unique elements
                  const elementKey = parentAnimatedElement.element;
                  if (!animatedElements.has(elementKey)) {
                    animatedElements.add(elementKey);
                    completedAnimations++;
                    console.log('DEBUG: Child transition completed for element:', completedAnimations, '/', totalAnimations, 'for element:', targetElement.getAttribute('data-figma-name') || targetElement.getAttribute('data-figma-id'));
                    
                    if (completedAnimations >= totalAnimations) {
                      console.log('DEBUG: All animations completed via child transitions');
                      copy.removeEventListener('transitionend', onTransitionEnd);
                      copy.removeEventListener('transitionend', onCopyTransitionEnd);
                      childElements.forEach(child => {
                        child.removeEventListener('transitionend', onTransitionEnd);
                      });
                      clearTimeout(fallbackTimeout);
                      clearInterval(intervalId);
                      resolve();
                    }
                  }
                } else {
                  console.log('DEBUG: Transition end event for element not in our animation list');
                }
              }
            };
            
            // Add a more aggressive monitoring approach - check if animations are actually complete
            const checkAnimationProgress = () => {
              console.log('DEBUG: Position check running...');
              let actuallyCompleted = 0;
              elementsToAnimate.forEach(({ element, changes }) => {
                const computedStyle = window.getComputedStyle(element);
                const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
                
                // Check if the element has reached its target position
                let isComplete = false;
                
                if (changes.positionY && changes.positionY.changed) {
                  const currentTop = parseFloat(computedStyle.top) || 0;
                  const targetTop = changes.positionY.targetValue;
                  const difference = Math.abs(currentTop - targetTop);
                  
                  console.log('DEBUG: Position check for', elementName, 'currentTop:', currentTop, 'targetTop:', targetTop, 'difference:', difference);
                  
                  if (difference < 5) { // Allow for small rounding differences
                    isComplete = true;
                    console.log('DEBUG: Element', elementName, 'position animation appears complete:', currentTop, '->', targetTop);
                  }
                }
                
                if (changes.positionX && changes.positionX.changed) {
                  const currentLeft = parseFloat(computedStyle.left) || 0;
                  const targetLeft = changes.positionX.targetValue;
                  const difference = Math.abs(currentLeft - targetLeft);
                  
                  console.log('DEBUG: Position check for', elementName, 'currentLeft:', currentLeft, 'targetLeft:', targetLeft, 'difference:', difference);
                  
                  if (difference < 5) { // Allow for small rounding differences
                    isComplete = true;
                    console.log('DEBUG: Element', elementName, 'position animation appears complete:', currentLeft, '->', targetLeft);
                  }
                }
                
                if (isComplete && !animatedElements.has(element)) {
                  animatedElements.add(element);
                  actuallyCompleted++;
                  console.log('DEBUG: Element', elementName, 'marked as complete via position check');
                }
              });
              
              if (actuallyCompleted > 0) {
                completedAnimations += actuallyCompleted;
                console.log('DEBUG: Position check completed animations:', completedAnimations, '/', totalAnimations);
                
                if (completedAnimations >= totalAnimations) {
                  console.log('DEBUG: All animations completed via position check');
                  copy.removeEventListener('transitionend', onTransitionEnd);
                  copy.removeEventListener('transitionend', onCopyTransitionEnd);
                  childElements.forEach(child => {
                    child.removeEventListener('transitionend', onTransitionEnd);
                  });
                  clearTimeout(fallbackTimeout);
                  clearInterval(progressCheckInterval);
                  resolve();
                }
              }
            };
            
            // Set up periodic position checking
            const progressCheckInterval = setInterval(checkAnimationProgress, 100); // Check every 100ms
            console.log('DEBUG: Position-based monitoring interval set up');
            
            // Store the interval ID so we can clear it later
            const intervalId = progressCheckInterval;
            
            // Also listen for transitions on the copy element itself
            const onCopyTransitionEnd = (event) => {
              const propertyName = event.propertyName;
              console.log('DEBUG: Copy transition end event fired for property:', propertyName);
              
              // Find which element this transition belongs to by checking if the copy itself is being animated
              const animatedElement = elementsToAnimate.find(({ element }) => 
                element === copy
              );
              
              if (animatedElement) {
                const elementKey = animatedElement.element;
                const expectedProperties = transitionProperties.get(elementKey) || [];
                
                console.log('DEBUG: Found matching animated element (copy), expected properties:', expectedProperties);
                
                // Check if this is a property we're expecting to transition
                if (expectedProperties.includes(propertyName)) {
                  // Remove this property from the expected list
                  const updatedProperties = expectedProperties.filter(p => p !== propertyName);
                  transitionProperties.set(elementKey, updatedProperties);
                  
                  console.log('DEBUG: Property', propertyName, 'transition completed on copy, remaining properties for this element:', updatedProperties);
                  
                  // If all properties for this element have completed, mark the element as done
                  if (updatedProperties.length === 0 && !animatedElements.has(elementKey)) {
                    animatedElements.add(elementKey);
                    completedAnimations++;
                    console.log('DEBUG: All transitions completed for copy element:', completedAnimations, '/', totalAnimations);
                    
                    if (completedAnimations >= totalAnimations) {
                      console.log('DEBUG: All animations completed');
                      copy.removeEventListener('transitionend', onTransitionEnd);
                      copy.removeEventListener('transitionend', onCopyTransitionEnd);
                      childElements.forEach(child => {
                        child.removeEventListener('transitionend', onTransitionEnd);
                      });
                      clearTimeout(fallbackTimeout);
                      clearInterval(intervalId);
                      resolve();
                    }
                  }
                } else {
                  console.log('DEBUG: Ignoring copy transition for unexpected property:', propertyName);
                }
              } else {
                console.log('DEBUG: Copy transition end event but copy not in animation list');
              }
            };
            
            // Add transition end listener to the copy element and all its children
            copy.addEventListener('transitionend', onTransitionEnd);
            copy.addEventListener('transitionend', onCopyTransitionEnd);
            
            // Also listen for transitions on child elements that might be animated
            const childElements = copy.querySelectorAll('*');
            childElements.forEach(child => {
              child.addEventListener('transitionend', onTransitionEnd);
            });
            
            // Fallback timeout in case transition events don't fire
            const fallbackTimeout = setTimeout(() => {
              console.log('DEBUG: Animation fallback timeout reached');
              console.log('DEBUG: Completed animations:', completedAnimations, '/', totalAnimations);
              console.log('DEBUG: Remaining transition properties:', Array.from(transitionProperties.entries()));
              
              // Check if animations are actually complete by examining the computed styles
              let actuallyCompleted = 0;
              elementsToAnimate.forEach(({ element, changes }) => {
                const computedStyle = window.getComputedStyle(element);
                const elementName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
                
                console.log('DEBUG: Checking if element', elementName, 'animation is actually complete:');
                console.log('  transition:', computedStyle.transition);
                console.log('  transform:', computedStyle.transform);
                console.log('  left:', computedStyle.left);
                console.log('  top:', computedStyle.top);
                
                // If transition is 'none' or empty, animation is likely complete
                if (!computedStyle.transition || computedStyle.transition === 'none' || computedStyle.transition === 'all 0s ease 0s') {
                  actuallyCompleted++;
                  console.log('DEBUG: Element', elementName, 'appears to be complete (no active transition)');
                }
              });
              
              console.log('DEBUG: Actually completed animations:', actuallyCompleted, '/', totalAnimations);
              
              copy.removeEventListener('transitionend', onTransitionEnd);
              copy.removeEventListener('transitionend', onCopyTransitionEnd);
              childElements.forEach(child => {
                child.removeEventListener('transitionend', onTransitionEnd);
              });
              clearInterval(intervalId);
              resolve();
            }, parseFloat(transitionDuration || '0.3') * 1000 + 2000); // Add 2s buffer for more reliability
          } else {
            resolve();
          }
        });
      }
      
      // Helper function to get node data from element (placeholder)
      function getNodeDataFromElement(element) {
        // This would need to be implemented to extract Figma node data from DOM elements
        // For now, return a basic structure
        return {
          type: element.getAttribute('data-figma-type') || 'UNKNOWN',
          layoutPositioning: element.getAttribute('data-layout-positioning') || 'AUTO',
          layoutMode: element.getAttribute('data-layout-mode') || 'NONE'
        };
      }
      
      // Helper function to find elements with property changes
      function findElementsWithPropertyChanges(targetVariant, currentVariant) {
        console.log('DEBUG: findElementsWithPropertyChanges called');
        console.log('  Target variant ID:', targetVariant.getAttribute('data-figma-id'), 'Name:', targetVariant.getAttribute('data-figma-name'));
        console.log('  Current variant ID:', currentVariant.getAttribute('data-figma-id'), 'Name:', currentVariant.getAttribute('data-figma-name'));
        
        if (!currentVariant) {
          console.log('DEBUG: No current variant provided, returning empty array');
          return [];
        }
        
        const targetElements = targetVariant.querySelectorAll('[data-figma-id]');
        const sourceElements = currentVariant.querySelectorAll('[data-figma-id]');
        const sourceElementMap = new Map();
        const elementsToAnimate = [];

        console.log('DEBUG: Found', targetElements.length, 'target elements and', sourceElements.length, 'source elements');

        // Build source element map by name
        sourceElements.forEach(function(sourceElement) {
          const sourceName = sourceElement.getAttribute('data-figma-name') || sourceElement.getAttribute('data-figma-id');
          if (sourceName) {
            sourceElementMap.set(sourceName, sourceElement);
            console.log('  Mapped source element:', sourceName, '->', sourceElement.getAttribute('data-figma-id'));
          }
        });

        // Analyze each target element for property changes
        targetElements.forEach(function(element, index) {
          const targetName = element.getAttribute('data-figma-name') || element.getAttribute('data-figma-id');
          const sourceElement = sourceElementMap.get(targetName);
          
          console.log('DEBUG: Analyzing target element ' + (index + 1) + ':', targetName);
          console.log('  Target element ID:', element.getAttribute('data-figma-id'));
          console.log('  Source element found:', !!sourceElement);
          
          if (sourceElement) {
            console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));
            const changes = detectPropertyChanges(element, sourceElement);
            
            if (changes.hasChanges) {
              elementsToAnimate.push({
                element: sourceElement,  // Use SOURCE element (from copy) instead of target
                sourceElement: sourceElement,
                changes: changes
              });
              console.log('DEBUG: Found element with property changes:', targetName, 'changes:', changes);
            } else {
              console.log('DEBUG: No changes detected for element:', targetName);
            }
          } else {
            console.log('DEBUG: No matching source element found for:', targetName);
          }
        });
        
        console.log('DEBUG: Returning', elementsToAnimate.length, 'elements to animate');
        return elementsToAnimate;
      }

      // Helper function to detect property changes between elements
      function detectPropertyChanges(targetElement, sourceElement) {
        const changes = {
          hasChanges: false,
          positionX: { changed: false, sourceValue: null, targetValue: null },
          positionY: { changed: false, sourceValue: null, targetValue: null },
          backgroundColor: { changed: false, sourceValue: null, targetValue: null },
          color: { changed: false, sourceValue: null, targetValue: null },
          justifyContent: { changed: false, sourceValue: null, targetValue: null },
          alignItems: { changed: false, sourceValue: null, targetValue: null }
        };

        try {
          const sourceStyle = window.getComputedStyle(sourceElement);
          const targetStyle = window.getComputedStyle(targetElement);
          
          // STEP 1: Check if the node has position changes using bounding rectangles (accounts for flexbox alignment)
          const sourceRect = sourceElement.getBoundingClientRect();
          const targetRect = targetElement.getBoundingClientRect();
          
          // Get parent rectangles for relative positioning
          const sourceParent = sourceElement.parentElement;
          const targetParent = targetElement.parentElement;
          const sourceParentRect = sourceParent ? sourceParent.getBoundingClientRect() : { left: 0, top: 0 };
          const targetParentRect = targetParent ? targetParent.getBoundingClientRect() : { left: 0, top: 0 };
          
          // Calculate relative positions within their containers
          const sourceLeft = sourceRect.left - sourceParentRect.left;
          const targetLeft = targetRect.left - targetParentRect.left;
          const sourceTop = sourceRect.top - sourceParentRect.top;
          const targetTop = targetRect.top - targetParentRect.top;
          
          // STEP 2: Check if the node has ignore auto layout enabled
          const ignoreAutoLayout = sourceElement.getAttribute('data-layout-positioning') === 'ABSOLUTE';
          
          // STEP 3: Check if the node's parent has auto layout
          const parentHasAutoLayout = sourceParent && targetParent && 
            sourceParent.getAttribute('data-layout-mode') && 
            sourceParent.getAttribute('data-layout-mode') !== 'NONE';
          
          console.log('DEBUG: 3-Point Analysis for', sourceElement.getAttribute('data-figma-name'), {
            hasPositionChange: Math.abs(sourceLeft - targetLeft) > 1 || Math.abs(sourceTop - targetTop) > 1,
            ignoreAutoLayout: ignoreAutoLayout,
            parentHasAutoLayout: parentHasAutoLayout,
            sourceLeft: sourceLeft,
            targetLeft: targetLeft,
            sourceTop: sourceTop,
            targetTop: targetTop
          });
          
          // Determine if this node should be animated based on the 3-point logic
          let shouldAnimatePosition = false;
          let animationType = 'ABSOLUTE';
          
          if (Math.abs(sourceLeft - targetLeft) > 1 || Math.abs(sourceTop - targetTop) > 1) {
            // Node has position changes
            if (ignoreAutoLayout) {
              // Node ignores auto layout - animate absolutely
              shouldAnimatePosition = true;
              animationType = 'ABSOLUTE';
              console.log('DEBUG: Node has position changes and ignores auto layout - animating absolutely');
            } else if (!parentHasAutoLayout) {
              // Node's parent doesn't have auto layout - animate absolutely
              shouldAnimatePosition = true;
              animationType = 'ABSOLUTE';
              console.log('DEBUG: Node has position changes and parent has no auto layout - animating absolutely');
            } else {
              // Node has position changes and parent has auto layout - ANIMATE the node
              // The node moves due to parent's alignment changes, so we animate it smoothly
              shouldAnimatePosition = true;
              animationType = 'ABSOLUTE';
              console.log('DEBUG: Node has position changes and parent has auto layout - ANIMATING (node moves due to parent alignment)');
            }
          } else {
            // No position changes - no animation needed
            shouldAnimatePosition = false;
            console.log('DEBUG: No position changes detected - no animation needed');
          }
          
          // Apply position changes if animation is needed
          if (shouldAnimatePosition) {
            if (Math.abs(sourceLeft - targetLeft) > 1) {
              changes.positionX.changed = true;
              changes.positionX.sourceValue = sourceLeft;
              changes.positionX.targetValue = targetLeft;
              changes.hasChanges = true;
              console.log('DEBUG: Position X change detected:', sourceLeft, '->', targetLeft, '(', animationType, ')');
            }
            
            if (Math.abs(sourceTop - targetTop) > 1) {
              changes.positionY.changed = true;
              changes.positionY.sourceValue = sourceTop;
              changes.positionY.targetValue = targetTop;
              changes.hasChanges = true;
              console.log('DEBUG: Position Y change detected:', sourceTop, '->', targetTop, '(', animationType, ')');
            }
          }

          // Check style changes (non-position)
          const sourceBg = sourceStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          const targetBg = targetStyle.backgroundColor || 'rgba(0, 0, 0, 0)';
          
          if (sourceBg !== targetBg) {
            changes.backgroundColor.changed = true;
            changes.backgroundColor.sourceValue = sourceBg;
            changes.backgroundColor.targetValue = targetBg;
            changes.hasChanges = true;
            console.log('DEBUG: Background color change detected:', sourceBg, '->', targetBg);
          }
          
          if (sourceStyle.color !== targetStyle.color) {
            changes.color.changed = true;
            changes.color.sourceValue = sourceStyle.color;
            changes.color.targetValue = targetStyle.color;
            changes.hasChanges = true;
            console.log('DEBUG: Color change detected:', sourceStyle.color, '->', targetStyle.color);
          }
          
          // Only mark alignment changes as requiring animation if there's an actual position difference
          if (sourceStyle.justifyContent !== targetStyle.justifyContent) {
            changes.justifyContent.changed = true;
            changes.justifyContent.sourceValue = sourceStyle.justifyContent;
            changes.justifyContent.targetValue = targetStyle.justifyContent;
            
            // Only set hasChanges if there's an actual position difference to animate
            if (shouldAnimatePosition) {
              changes.hasChanges = true;
            }
          }
          
          if (sourceStyle.alignItems !== targetStyle.alignItems) {
            changes.alignItems.changed = true;
            changes.alignItems.sourceValue = sourceStyle.alignItems;
            changes.alignItems.targetValue = targetStyle.alignItems;
            
            // Only set hasChanges if there's an actual position difference to animate
            if (shouldAnimatePosition) {
              changes.hasChanges = true;
            }
          }
        } catch (error) {
          console.log('DEBUG: Error detecting property changes:', error);
        }

        // Debug: Log what caused hasChanges to be true
        if (changes.hasChanges) {
          console.log('DEBUG: hasChanges is true for', sourceElement.getAttribute('data-figma-name'), 'due to:');
          if (changes.positionX.changed) console.log('  - positionX change');
          if (changes.positionY.changed) console.log('  - positionY change');
          if (changes.backgroundColor.changed) console.log('  - backgroundColor change');
          if (changes.color.changed) console.log('  - color change');
          if (changes.justifyContent.changed) console.log('  - justifyContent change');
          if (changes.alignItems.changed) console.log('  - alignItems change');
        }

        return changes;
      }
      
      // Helper function to handle animated variant switching
      async function handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration) {
        console.log('DEBUG: Starting modular animated variant switch');
        console.log('DEBUG: About to create element copy');
        
        // Create a copy of the source variant
        const sourceCopy = createElementCopy(sourceElement);
        console.log('DEBUG: Element copy created successfully');
        
        // Insert the copy into the DOM
        const sourceParent = sourceElement.parentElement;
        sourceParent.appendChild(sourceCopy);
        console.log('DEBUG: Copy inserted into DOM');
        
        // Log the copy's position and visibility after insertion
        const copyRect = sourceCopy.getBoundingClientRect();
        const copyStyle = window.getComputedStyle(sourceCopy);
        console.log('DEBUG: Copy after insertion:');
        console.log('  position: ' + copyStyle.position);
        console.log('  top: ' + copyStyle.top);
        console.log('  left: ' + copyStyle.left);
        console.log('  z-index: ' + copyStyle.zIndex);
        console.log('  opacity: ' + copyStyle.opacity);
        console.log('  visibility: ' + copyStyle.visibility);
        console.log('  display: ' + copyStyle.display);
        console.log('  bounding rect: ' + copyRect);
        
        // Hide the original source element and all other variants
        sourceElement.style.opacity = '0';
        sourceElement.style.visibility = 'hidden';
        
        allVariants.forEach(variant => {
          if (variant !== sourceElement) {
            variant.style.opacity = '0';
            variant.style.visibility = 'hidden';
          }
        });
        
        // Prepare the destination variant but keep it hidden for now
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        destination.style.visibility = 'hidden';
        destination.style.opacity = '0';
        
        // Force reflow
        destination.offsetHeight;
        
        // Animate the copy to match the destination
        await animateCopyToDestination(sourceCopy, destination, transitionType, transitionDuration);
        
        console.log('DEBUG: Animation completed, transitioning to destination variant');
        
        // Animation complete - restore normal behavior
        sourceCopy.remove();
        
        // Hide the original source element permanently
        sourceElement.style.opacity = '0';
        sourceElement.style.visibility = 'hidden';
        sourceElement.classList.add('variant-hidden');
        sourceElement.classList.remove('variant-active');
        
        // Properly activate the destination variant
        destination.style.visibility = 'visible';
        destination.style.opacity = '1';
        destination.style.display = 'flex';
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        
        // Ensure destination has proper positioning
        destination.style.position = 'relative';
        destination.style.top = '0px';
        destination.style.left = '0px';
        
        // Ensure all nested elements in the destination are also visible
        const destinationChildren = destination.querySelectorAll('*');
        destinationChildren.forEach(child => {
          child.style.opacity = '1';
          child.style.visibility = 'visible';
          if (child.style.display === 'none') {
            child.style.display = 'flex';
          }
        });
        
        // Hide all other variants
        allVariants.forEach(variant => {
          if (variant !== destination) {
            variant.classList.add('variant-hidden');
            variant.classList.remove('variant-active');
            variant.style.position = 'relative';
            variant.style.top = '0px';
            variant.style.left = '0px';
            variant.style.opacity = '0';
            variant.style.visibility = 'hidden';
          }
        });
        
        // Start timeout reactions
        startTimeoutReactionsForNewlyActiveVariant(destination);
        startTimeoutReactionsForNestedComponents(destination);
      }
      
      // Helper function to perform instant variant switch
      function performInstantVariantSwitch(allVariants, destination) {
        console.log('DEBUG: Performing instant variant switch');
        
        // Hide all variants
        allVariants.forEach(variant => {
          variant.classList.add('variant-hidden');
          variant.classList.remove('variant-active');
          variant.style.position = 'relative';
          variant.style.top = '0px';
          variant.style.left = '0px';
        });
        
        // Show destination variant
        destination.classList.add('variant-active');
        destination.classList.remove('variant-hidden');
        destination.style.position = 'relative';
        destination.style.top = '0px';
        destination.style.left = '0px';
        
        // Start timeout reactions
        startTimeoutReactionsForNewlyActiveVariant(destination);
        startTimeoutReactionsForNestedComponents(destination);
      }
      
      // Main reaction handler function
      function handleReaction(sourceElement, destinationId, transitionType, transitionDuration) {
        console.log('DEBUG: Modular handleReaction called');
        console.log('  Source element ID:', sourceElement.getAttribute('data-figma-id'));
        console.log('  Destination ID:', destinationId);
        console.log('  Transition type:', transitionType, 'Duration:', transitionDuration);
        
        // Prevent multiple simultaneous transitions
        if (isTransitionInProgress) {
          console.log('DEBUG: Transition already in progress, skipping');
          return;
        }
        
        // Set transition lock
        isTransitionInProgress = true;
        
        // Safety timeout
        const safetyTimeout = setTimeout(() => {
          if (isTransitionInProgress) {
            console.log('WARNING: Transition lock stuck, forcing release');
            isTransitionInProgress = false;
            currentTransitionPromise = null;
          }
        }, 10000); // Increased to 10 seconds
        
        if (destinationId) {
          const destination = document.querySelector(`[data-figma-id="${destinationId}"]`);
          
          if (!destination) {
            console.log('ERROR: Destination element not found:', destinationId);
            clearTimeout(safetyTimeout);
            isTransitionInProgress = false;
            return;
          }
          
          // Check if this is a variant switch within a component set
          const sourceComponentSet = sourceElement.closest('[data-figma-type="COMPONENT_SET"]');
          const destinationComponentSet = destination.closest('[data-figma-type="COMPONENT_SET"]');
          
          if (sourceComponentSet && destinationComponentSet && sourceComponentSet === destinationComponentSet) {
            // This is a variant switch
            const componentSet = sourceComponentSet;
            const allVariants = Array.from(componentSet.children).filter(child => 
              child.getAttribute('data-figma-type') === 'COMPONENT'
            );
            
            const isAnimated = transitionType === 'SMART_ANIMATE' || 
                              transitionType === 'BOUNCY' || 
                              transitionType === 'EASE_IN_AND_OUT' || 
                              transitionType === 'EASE_IN' || 
                              transitionType === 'EASE_OUT' || 
                              transitionType === 'LINEAR' || 
                              transitionType === 'GENTLE';
            
            if (isAnimated) {
              console.log('DEBUG: Using modular animated variant switching');
              currentTransitionPromise = handleAnimatedVariantSwitch(sourceElement, destination, allVariants, transitionType, transitionDuration)
                .then(() => {
                  clearTimeout(safetyTimeout);
                  isTransitionInProgress = false;
                  currentTransitionPromise = null;
                })
                .catch((error) => {
                  console.error('Modular animation error:', error);
                  clearTimeout(safetyTimeout);
                  isTransitionInProgress = false;
                  currentTransitionPromise = null;
                });
            } else {
              console.log('DEBUG: Using instant variant switching');
              performInstantVariantSwitch(allVariants, destination);
              clearTimeout(safetyTimeout);
              isTransitionInProgress = false;
              currentTransitionPromise = null;
            }
                      } else {
              // This is a regular transition (not variant switching)
              if (transitionType === 'DISSOLVE') {
                sourceElement.style.opacity = '0';
                setTimeout(() => {
                  sourceElement.style.opacity = '1';
                  destination.classList.add('variant-active');
                  destination.classList.remove('variant-hidden');
                  destination.style.opacity = '1';
                  
                  startTimeoutReactionsForNewlyActiveVariant(destination);
                  startTimeoutReactionsForNestedComponents(destination);
                  
                  clearTimeout(safetyTimeout);
                  isTransitionInProgress = false;
                  currentTransitionPromise = null;
                }, parseFloat(transitionDuration || '300'));
              } else {
                sourceElement.style.opacity = '1';
                destination.classList.add('variant-active');
                destination.classList.remove('variant-hidden');
                destination.style.opacity = '1';
                
                startTimeoutReactionsForNewlyActiveVariant(destination);
                startTimeoutReactionsForNestedComponents(destination);
                
                clearTimeout(safetyTimeout);
                isTransitionInProgress = false;
                currentTransitionPromise = null;
              }
            }
        } else {
          clearTimeout(safetyTimeout);
          isTransitionInProgress = false;
          currentTransitionPromise = null;
        }
      }
      
      // Make function globally available
      window.handleReaction = handleReaction;
    
      
      // Initialize component set variants - handle both single and multiple variants
      // Handle both COMPONENT_SET and COMPONENT elements that contain variants
      // With the new 1:1 structure, this will handle nested component sets correctly
      const componentSets = document.querySelectorAll('[data-figma-type="COMPONENT_SET"], [data-figma-type="COMPONENT"]');
      componentSets.forEach(componentSet => {
        // Find all COMPONENT children - these are the variants
        // Some may have explicit variant attributes, others are variants by hierarchy
        const variants = componentSet.querySelectorAll('[data-figma-type="COMPONENT"]');
        
        // Handle both single and multiple variants
        if (variants.length >= 1) {
          console.log('Initializing component set/instance with', variants.length, 'variants:', {
            componentSetId: componentSet.getAttribute('data-figma-id'),
            componentSetName: componentSet.getAttribute('data-figma-name'),
            componentSetType: componentSet.getAttribute('data-figma-type'),
            parentType: componentSet.parentElement?.getAttribute('data-figma-type'),
            parentId: componentSet.parentElement?.getAttribute('data-figma-id'),
            variantIds: Array.from(variants).map(v => v.getAttribute('data-figma-id'))
          });
          
          // Reset opacity for all variants to ensure clean initial state
          variants.forEach(variant => {
            variant.style.opacity = '1'; // Ensure all variants start with opacity 1
          });
          
          // For single components, just make them visible
          if (variants.length === 1) {
            const singleVariant = variants[0];
            singleVariant.classList.add('variant-active');
            singleVariant.classList.remove('variant-hidden');
            console.log('Set single variant as active:', singleVariant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
          } else {
            // For multiple variants, the FIRST variant should be active initially (where reactions are)
            // This ensures the animation starts from the variant with reactions
            variants.forEach((variant, index) => {
              if (index === 0) {
                variant.classList.add('variant-active');
                variant.classList.remove('variant-hidden');
                console.log('Set first variant as active (with reactions):', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
              } else {
                variant.classList.add('variant-hidden');
                variant.classList.remove('variant-active');
                console.log('Set variant as hidden:', variant.getAttribute('data-figma-id'), 'in component set:', componentSet.getAttribute('data-figma-id'));
              }
            });
          }
        }
      });
  
      console.log('DEBUG: All event handlers initialized (immediate)');
    }
  

// Debug logging and status updates
(function() {
  console.log('🔍 Debug: HTML loaded successfully');
  console.log('📊 Node data:', [
  {
    "id": "5533:4251",
    "name": "glydcar/info-bar/counter-sm",
    "type": "INSTANCE",
    "x": 17566,
    "y": 1271,
    "width": 144,
    "height": 144,
    "opacity": 1,
    "fills": [],
    "strokes": [],
    "strokeWeight": 1.600000262260437,
    "cornerRadius": 0,
    "layoutMode": "HORIZONTAL",
    "primaryAxisAlignItems": "CENTER",
    "counterAxisAlignItems": "CENTER",
    "itemSpacing": 16,
    "layoutSizingHorizontal": "FIXED",
    "layoutSizingVertical": "FIXED",
    "paddingLeft": 0,
    "paddingRight": 0,
    "paddingTop": 0,
    "paddingBottom": 0,
    "reactions": [
      {
        "action": {
          "type": "NODE",
          "destinationId": "5533:3911",
          "navigation": "CHANGE_TO",
          "transition": {
            "type": "SMART_ANIMATE",
            "easing": {
              "type": "GENTLE"
            },
            "duration": 1.0220937728881836
          },
          "resetVideoPosition": false
        },
        "actions": [
          {
            "type": "NODE",
            "destinationId": "5533:3911",
            "navigation": "CHANGE_TO",
            "transition": {
              "type": "SMART_ANIMATE",
              "easing": {
                "type": "GENTLE"
              },
              "duration": 1.0220937728881836
            },
            "resetVideoPosition": false
          }
        ],
        "trigger": {
          "type": "AFTER_TIMEOUT",
          "timeout": 0.8
        }
      }
    ],
    "children": [
      {
        "id": "5533:3901",
        "name": "glydcar/info-bar/counter-sm",
        "type": "COMPONENT_SET",
        "x": 18406,
        "y": 1251,
        "width": 472,
        "height": 144,
        "opacity": 1,
        "fills": [],
        "strokes": [
          {
            "type": "SOLID",
            "visible": true,
            "opacity": 1,
            "blendMode": "NORMAL",
            "color": {
              "r": 0.5411764979362488,
              "g": 0.21960784494876862,
              "b": 0.9607843160629272
            },
            "boundVariables": {}
          }
        ],
        "strokeWeight": 1,
        "cornerRadius": 5,
        "layoutMode": "HORIZONTAL",
        "primaryAxisAlignItems": "CENTER",
        "counterAxisAlignItems": "CENTER",
        "itemSpacing": 20,
        "layoutSizingHorizontal": "FILL",
        "layoutSizingVertical": "FILL",
        "paddingLeft": 0,
        "paddingRight": 0,
        "paddingTop": 0,
        "paddingBottom": 0,
        "children": [
          {
            "id": "5533:3902",
            "name": "Property 1=3",
            "type": "COMPONENT",
            "x": 0,
            "y": 0,
            "width": 144,
            "height": 144,
            "opacity": 1,
            "fills": [],
            "strokes": [],
            "strokeWeight": 1.600000262260437,
            "cornerRadius": 0,
            "layoutMode": "HORIZONTAL",
            "primaryAxisAlignItems": "CENTER",
            "counterAxisAlignItems": "CENTER",
            "itemSpacing": 16,
            "layoutSizingHorizontal": "FIXED",
            "layoutSizingVertical": "FIXED",
            "paddingLeft": 0,
            "paddingRight": 0,
            "paddingTop": 0,
            "paddingBottom": 0,
            "reactions": [
              {
                "action": {
                  "type": "NODE",
                  "destinationId": "5533:3911",
                  "navigation": "CHANGE_TO",
                  "transition": {
                    "type": "SMART_ANIMATE",
                    "easing": {
                      "type": "GENTLE"
                    },
                    "duration": 1.0220937728881836
                  },
                  "resetVideoPosition": false
                },
                "actions": [
                  {
                    "type": "NODE",
                    "destinationId": "5533:3911",
                    "navigation": "CHANGE_TO",
                    "transition": {
                      "type": "SMART_ANIMATE",
                      "easing": {
                        "type": "GENTLE"
                      },
                      "duration": 1.0220937728881836
                    },
                    "resetVideoPosition": false
                  }
                ],
                "trigger": {
                  "type": "AFTER_TIMEOUT",
                  "timeout": 0.8
                }
              }
            ],
            "children": [
              {
                "id": "5533:3903",
                "name": "Frame 1233",
                "type": "FRAME",
                "x": 0,
                "y": 0,
                "width": 144,
                "height": 144,
                "opacity": 1,
                "fills": [
                  {
                    "type": "SOLID",
                    "visible": true,
                    "opacity": 1,
                    "blendMode": "NORMAL",
                    "color": {
                      "r": 0.1730685830116272,
                      "g": 0.5052500367164612,
                      "b": 0.6483436226844788
                    },
                    "boundVariables": {}
                  }
                ],
                "strokes": [],
                "strokeWeight": 1.6000001430511475,
                "cornerRadius": 1000,
                "layoutMode": "HORIZONTAL",
                "primaryAxisAlignItems": "CENTER",
                "counterAxisAlignItems": "MIN",
                "itemSpacing": 10,
                "layoutSizingHorizontal": "HUG",
                "layoutSizingVertical": "FIXED",
                "paddingLeft": 0,
                "paddingRight": 0,
                "paddingTop": 0,
                "paddingBottom": 0,
                "reactions": [],
                "children": [
                  {
                    "id": "5533:3904",
                    "name": "Frame 1232",
                    "type": "FRAME",
                    "x": 0,
                    "y": 0,
                    "width": 144,
                    "height": 720,
                    "opacity": 1,
                    "fills": [],
                    "strokes": [],
                    "strokeWeight": 1.6000001430511475,
                    "cornerRadius": 0,
                    "layoutMode": "VERTICAL",
                    "primaryAxisAlignItems": "CENTER",
                    "counterAxisAlignItems": "CENTER",
                    "itemSpacing": 144.00001525878906,
                    "layoutSizingHorizontal": "FIXED",
                    "layoutSizingVertical": "FIXED",
                    "paddingLeft": 0,
                    "paddingRight": 0,
                    "paddingTop": 0,
                    "paddingBottom": 0,
                    "reactions": [],
                    "children": [
                      {
                        "id": "5533:3905",
                        "name": "Frame 1236",
                        "type": "FRAME",
                        "x": 0,
                        "y": 0,
                        "width": 144,
                        "height": 144,
                        "opacity": 1,
                        "fills": [],
                        "strokes": [],
                        "strokeWeight": 1.6000001430511475,
                        "cornerRadius": 0,
                        "layoutMode": "HORIZONTAL",
                        "primaryAxisAlignItems": "CENTER",
                        "counterAxisAlignItems": "CENTER",
                        "itemSpacing": 0,
                        "layoutSizingHorizontal": "FIXED",
                        "layoutSizingVertical": "FIXED",
                        "paddingLeft": 1.6000001430511475,
                        "paddingRight": 0,
                        "paddingTop": 3.200000286102295,
                        "paddingBottom": 0,
                        "reactions": [],
                        "children": [
                          {
                            "id": "5533:3906",
                            "name": "3",
                            "type": "VECTOR",
                            "x": 45.670166015625,
                            "y": 35.4686279296875,
                            "width": 54.25920104980469,
                            "height": 76.26240539550781,
                            "opacity": 1,
                            "fills": [
                              {
                                "type": "SOLID",
                                "visible": true,
                                "opacity": 1,
                                "blendMode": "NORMAL",
                                "color": {
                                  "r": 0,
                                  "g": 0,
                                  "b": 0
                                },
                                "boundVariables": {}
                              }
                            ],
                            "strokes": [],
                            "strokeWeight": 0.43928295373916626,
                            "cornerRadius": 0,
                            "layoutSizingHorizontal": "FIXED",
                            "layoutSizingVertical": "FIXED",
                            "reactions": [],
                            "layoutPositioning": "AUTO",
                            "vectorPaths": [
                              {
                                "windingRule": "NONZERO",
                                "data": "M 16.703999914991396 30.75839966834482 L 39.85919880796148 8.755197493907422 L 2.3039993897618625 8.755197493907422 L 2.3039993897618625 0 L 52.531198217307086 0 L 52.531198217307086 8.639998972451874 L 29.83679946931817 30.067197858458748 C 30.60480098251913 29.913597541032896 31.334398414628136 29.836799289668683 32.025596343281656 29.836799289668683 C 34.71359820625767 29.836799289668683 37.36320132871761 30.335999749098082 39.97439960714618 31.334400667956885 C 42.6624014701222 32.25600028369354 45.043198913120776 33.676799595920116 47.11679727671779 35.59680013051557 C 49.267196936044016 37.51680066511102 50.995197479723394 39.897601389044546 52.30079661893768 42.73920153937665 C 53.6063980469702 45.504001530995836 54.25920104980469 48.729598660195144 54.25920104980469 52.41599941196021 C 54.25920104980469 55.56479905273479 53.6447983133651 58.598399027644604 52.416000469880025 61.51679933668964 C 51.2639993444877 64.35839948702174 49.53600108962655 66.89280338940418 47.23200112766013 69.12000398664672 C 44.928001165693715 71.2704040437066 42.12479850353299 72.99840065292463 38.82239771881444 74.3040007761236 C 35.51999693409589 75.60960089932257 31.756799819093224 76.26240539550781 27.53280179616998 76.26240539550781 C 23.38560049133949 76.26240539550781 19.622399561639767 75.64800469800902 16.243199770010232 74.41920463815553 C 12.940800129700794 73.11360451495656 10.099200252902817 71.42400588701142 7.718400139616301 69.35040560719473 C 5.414400177649881 67.20000574086973 3.571199788460069 64.74240314160943 2.1887999257211286 61.97760257778564 C 0.8831996420977266 59.136002999658146 0.15359973043563444 56.14080119675609 0 52.99200041157228 L 9.446399920356264 50.80320027515594 C 9.52320007167636 53.41440109375849 10.060799986507917 55.795201817692025 11.059199664850935 57.94560168401703 C 12.057599343193953 60.01920196383372 13.36319924534765 61.78560218100333 14.976000134251436 63.24480233552584 C 16.588799878746105 64.70400249004835 18.47039996212626 65.8176040284463 20.620799621452488 66.58560447116632 C 22.771200425187832 67.35360434168173 25.036798976350237 67.73760036687459 27.417597945227637 67.73760036687459 C 30.02879851247444 67.73760036687459 32.40959900723066 67.35360434168173 34.559998666556886 66.58560447116632 C 36.71039832588311 65.8176040284463 38.5152001652917 64.7424000898515 39.97439960714618 63.36000009404191 C 41.43360133781889 61.977600098232315 42.54719914505868 60.36480248730702 43.315198369441404 58.5216026836291 C 44.15999888955334 56.678402307746566 44.58240105695784 54.68160314031715 44.58240105695784 52.53120327399215 C 44.58240105695784 49.99680261410251 44.12160014903726 47.80800018886772 43.20000062201434 45.96479981298519 C 42.27839880617319 44.04479927838974 41.04959791093047 42.50879991882865 39.51359946216501 41.356800971362446 C 37.97759872458132 40.12800072077409 36.21119867744646 39.206401105037436 34.21439932076043 38.591999835334036 C 32.29439897098537 37.977600854449086 30.297598088420514 37.670399456657904 28.223997436005266 37.670399456657904 C 25.766397171398655 37.670399456657904 23.500798620236253 38.01600036160094 21.42719911223012 38.70720064560804 L 16.703999914991396 30.75839966834482 Z"
                              }
                            ],
                            "effects": [],
                            "parentId": "5533:3905",
                            "children": []
                          }
                        ],
                        "clipsContent": false,
                        "layoutPositioning": "AUTO",
                        "effects": [],
                        "parentId": "5533:3904"
                      },
                      {
                        "id": "5533:3907",
                        "name": "Frame 1235",
                        "type": "FRAME",
                        "x": 0,
                        "y": 288,
                        "width": 144,
                        "height": 144,
                        "opacity": 1,
                        "fills": [],
                        "strokes": [],
                        "strokeWeight": 1.6000001430511475,
                        "cornerRadius": 0,
                        "layoutMode": "HORIZONTAL",
                        "primaryAxisAlignItems": "CENTER",
                        "counterAxisAlignItems": "CENTER",
                        "itemSpacing": 0,
                        "layoutSizingHorizontal": "FIXED",
                        "layoutSizingVertical": "FIXED",
                        "paddingLeft": 0,
                        "paddingRight": 0,
                        "paddingTop": 0,
                        "paddingBottom": 0,
                        "reactions": [],
                        "children": [
                          {
                            "id": "5533:3908",
                            "name": "2",
                            "type": "VECTOR",
                            "x": 46.310302734375,
                            "y": 33.86865234375,
                            "width": 51.37920379638672,
                            "height": 76.26240539550781,
                            "opacity": 1,
                            "fills": [
                              {
                                "type": "SOLID",
                                "visible": true,
                                "opacity": 1,
                                "blendMode": "NORMAL",
                                "color": {
                                  "r": 0,
                                  "g": 0,
                                  "b": 0
                                },
                                "boundVariables": {}
                              }
                            ],
                            "strokes": [],
                            "strokeWeight": 0.43928295373916626,
                            "cornerRadius": 0,
                            "layoutSizingHorizontal": "FIXED",
                            "layoutSizingVertical": "FIXED",
                            "reactions": [],
                            "layoutPositioning": "AUTO",
                            "vectorPaths": [
                              {
                                "windingRule": "NONZERO",
                                "data": "M 1.0367999722604826 27.187202891554318 C 0.8064000843886296 26.188804341418887 0.6912000927689886 25.075204227289905 0.6912000927689886 23.846404075046223 C 0.6912000927689886 20.62080453371341 1.2671999554997642 17.587204038652537 2.4191996809613157 14.74560182692418 C 3.5711996925251537 11.827202895856853 5.222399937981818 9.292803583212253 7.372800226596449 7.142403888990376 C 9.523199943006507 4.915205186611262 12.172799321104819 3.1872046148907307 15.321599886770244 1.9584021738287811 C 18.470399308026522 0.6528007246095937 22.041598237612245 0 26.035198201406274 0 C 29.875199002891833 0 33.33120094493192 0.6144012205309748 36.40320021282939 1.8432036615929241 C 39.47520176954515 2.9952025168611 42.04800061281494 4.6080022875275075 44.121599031457045 6.681602973592145 C 46.2719987478671 8.755203659656782 47.88480006105351 11.174404460065528 48.96000220807683 13.939205374818378 C 50.112001075231525 16.627202703777456 50.68800203468773 19.507202893705585 50.68800203468773 22.579204418723922 C 50.68800203468773 27.494405027698647 49.42080236529025 31.872002661360217 46.886403026495294 35.71200113440574 C 44.352001398882045 39.55200189626953 40.93439819837735 42.816002467559805 36.63359876555724 45.50400208533715 L 21.31200040466586 55.29600608802625 C 19.084800534896992 56.75520669796905 17.04960085779029 58.48320307352275 15.206400610406318 60.480002462611886 C 13.363200363022347 62.47680242390558 12.211199969988796 64.81920536056623 11.75040019424509 67.50720555054814 L 51.37920379638672 67.50720555054814 L 51.37920379638672 76.26240539550781 L 0 76.26240539550781 C 0.15360002061533082 70.50240539712127 1.4976001294739034 65.31840406342937 4.03200023120829 60.71040406472014 C 6.566400142207819 56.02560391344453 10.828799879818247 51.72480261765222 16.81919963477443 47.808002847631194 L 30.182399616327064 39.16800380372565 C 37.40160029914533 34.56000380501641 41.0112017849636 29.068802242528747 41.0112017849636 22.694402168020357 C 41.0112017849636 20.851203084063968 40.66560090411411 19.084803008264817 39.974400668293974 17.395201940622904 C 39.359999441423504 15.705600872980991 38.40000114840069 14.208001140429289 37.09440197452838 12.902404268846636 C 35.865601809605735 11.520003811470211 34.291200000894165 10.444804727298697 32.371199600151385 9.676805490453246 C 30.451199199408606 8.908806253607795 28.262399978523717 8.524806635185069 25.804799648678426 8.524806635185069 C 20.736000971088515 8.524806635185069 16.85760028365841 10.09920461295459 14.16959949373669 13.24800056849363 C 11.481599848224118 16.320002093511967 10.137600406937546 20.160002855375755 10.137600406937546 24.768002854084994 C 10.137600406937546 26.22720231961866 10.2528004462409 27.417602967783722 10.483199761908182 28.339204798580184 L 1.0367999722604826 27.187202891554318 Z"
                              }
                            ],
                            "effects": [],
                            "parentId": "5533:3907",
                            "children": []
                          }
                        ],
                        "clipsContent": false,
                        "layoutPositioning": "AUTO",
                        "effects": [],
                        "parentId": "5533:3904"
                      },
                      {
                        "id": "5533:3909",
                        "name": "Frame 1234",
                        "type": "FRAME",
                        "x": 0,
                        "y": 576,
                        "width": 144,
                        "height": 144,
                        "opacity": 1,
                        "fills": [],
                        "strokes": [],
                        "strokeWeight": 1.6000001430511475,
                        "cornerRadius": 0,
                        "layoutMode": "HORIZONTAL",
                        "primaryAxisAlignItems": "CENTER",
                        "counterAxisAlignItems": "CENTER",
                        "itemSpacing": 0,
                        "layoutSizingHorizontal": "FIXED",
                        "layoutSizingVertical": "FIXED",
                        "paddingLeft": 0,
                        "paddingRight": 11.200000762939453,
                        "paddingTop": 0,
                        "paddingBottom": 0,
                        "reactions": [],
                        "children": [
                          {
                            "id": "5533:3910",
                            "name": "1",
                            "type": "VECTOR",
                            "x": 52.518310546875,
                            "y": 34.675048828125,
                            "width": 27.763200759887695,
                            "height": 74.64959716796875,
                            "opacity": 1,
                            "fills": [
                              {
                                "type": "SOLID",
                                "visible": true,
                                "opacity": 1,
                                "blendMode": "NORMAL",
                                "color": {
                                  "r": 0,
                                  "g": 0,
                                  "b": 0
                                },
                                "boundVariables": {}
                              }
                            ],
                            "strokes": [],
                            "strokeWeight": 0.43928295373916626,
                            "cornerRadius": 0,
                            "layoutSizingHorizontal": "FIXED",
                            "layoutSizingVertical": "FIXED",
                            "reactions": [],
                            "layoutPositioning": "AUTO",
                            "vectorPaths": [
                              {
                                "windingRule": "NONZERO",
                                "data": "M 18.316799171732722 74.64959716796875 L 18.316799171732722 20.15999755859375 L 0 20.15999755859375 L 0 14.630397033691407 C 5.222400068544256 14.399995422363283 9.484799947778232 12.9407958984375 12.787200400641348 10.252798461914063 C 16.16640024303896 7.487997436523438 18.316799934672144 4.0703979492187505 19.2383994755409 0 L 27.763200759887695 0 L 27.763200759887695 74.64959716796875 L 18.316799171732722 74.64959716796875 Z"
                              }
                            ],
                            "effects": [],
                            "parentId": "5533:3909",
                            "children": []
                          }
                        ],
                        "clipsContent": false,
                        "layoutPositioning": "AUTO",
                        "effects": [],
                        "parentId": "5533:3904"
                      }
                    ],
                    "clipsContent": false,
                    "layoutPositioning": "AUTO",
                    "effects": [],
                    "parentId": "5533:3903"
                  }
                ],
                "clipsContent": false,
                "layoutPositioning": "AUTO",
                "effects": [],
                "parentId": "5533:3902"
              }
            ],
            "clipsContent": false,
            "layoutPositioning": "AUTO",
            "parentId": "5533:3901"
          },
          {
            "id": "5533:3911",
            "name": "Property 1=2",
            "type": "COMPONENT",
            "x": 164,
            "y": 0,
            "width": 144,
            "height": 144,
            "opacity": 1,
            "fills": [],
            "strokes": [],
            "strokeWeight": 1.600000262260437,
            "cornerRadius": 0,
            "layoutMode": "HORIZONTAL",
            "primaryAxisAlignItems": "CENTER",
            "counterAxisAlignItems": "CENTER",
            "itemSpacing": 16,
            "layoutSizingHorizontal": "FIXED",
            "layoutSizingVertical": "FIXED",
            "paddingLeft": 0,
            "paddingRight": 0,
            "paddingTop": 0,
            "paddingBottom": 0,
            "reactions": [
              {
                "action": {
                  "type": "NODE",
                  "destinationId": "7335:742",
                  "navigation": "CHANGE_TO",
                  "transition": {
                    "type": "SMART_ANIMATE",
                    "easing": {
                      "type": "GENTLE"
                    },
                    "duration": 1.0220937728881836
                  },
                  "resetVideoPosition": false
                },
                "actions": [
                  {
                    "type": "NODE",
                    "destinationId": "7335:742",
                    "navigation": "CHANGE_TO",
                    "transition": {
                      "type": "SMART_ANIMATE",
                      "easing": {
                        "type": "GENTLE"
                      },
                      "duration": 1.0220937728881836
                    },
                    "resetVideoPosition": false
                  }
                ],
                "trigger": {
                  "type": "AFTER_TIMEOUT",
                  "timeout": 0.8
                }
              }
            ],
            "children": [
              {
                "id": "7235:2051",
                "name": "Frame 1233",
                "type": "FRAME",
                "x": 0,
                "y": 0,
                "width": 144,
                "height": 144,
                "opacity": 1,
                "fills": [
                  {
                    "type": "SOLID",
                    "visible": true,
                    "opacity": 1,
                    "blendMode": "NORMAL",
                    "color": {
                      "r": 0.1730685830116272,
                      "g": 0.5052500367164612,
                      "b": 0.6483436226844788
                    },
                    "boundVariables": {}
                  }
                ],
                "strokes": [],
                "strokeWeight": 1.6000001430511475,
                "cornerRadius": 1000,
                "layoutMode": "HORIZONTAL",
                "primaryAxisAlignItems": "CENTER",
                "counterAxisAlignItems": "CENTER",
                "itemSpacing": 10,
                "layoutSizingHorizontal": "HUG",
                "layoutSizingVertical": "FIXED",
                "paddingLeft": 0,
                "paddingRight": 0,
                "paddingTop": 0,
                "paddingBottom": 0,
                "reactions": [],
                "children": [
                  {
                    "id": "7235:2052",
                    "name": "Frame 1232",
                    "type": "FRAME",
                    "x": 0,
                    "y": -288,
                    "width": 144,
                    "height": 720,
                    "opacity": 1,
                    "fills": [],
                    "strokes": [],
                    "strokeWeight": 1.6000001430511475,
                    "cornerRadius": 0,
                    "layoutMode": "VERTICAL",
                    "primaryAxisAlignItems": "CENTER",
                    "counterAxisAlignItems": "CENTER",
                    "itemSpacing": 144.00001525878906,
                    "layoutSizingHorizontal": "FIXED",
                    "layoutSizingVertical": "FIXED",
                    "paddingLeft": 0,
                    "paddingRight": 0,
                    "paddingTop": 0,
                    "paddingBottom": 0,
                    "reactions": [],
                    "children": [
                      {
                        "id": "7235:2053",
                        "name": "Frame 1236",
                        "type": "FRAME",
                        "x": 0,
                        "y": 0,
                        "width": 144,
                        "height": 144,
                        "opacity": 1,
                        "fills": [],
                        "strokes": [],
                        "strokeWeight": 1.6000001430511475,
                        "cornerRadius": 0,
                        "layoutMode": "HORIZONTAL",
                        "primaryAxisAlignItems": "CENTER",
                        "counterAxisAlignItems": "CENTER",
                        "itemSpacing": 0,
                        "layoutSizingHorizontal": "FIXED",
                        "layoutSizingVertical": "FIXED",
                        "paddingLeft": 1.6000001430511475,
                        "paddingRight": 0,
                        "paddingTop": 3.200000286102295,
                        "paddingBottom": 0,
                        "reactions": [],
                        "children": [
                          {
                            "id": "7235:2054",
                            "name": "3",
                            "type": "VECTOR",
                            "x": 45.670166015625,
                            "y": 35.4686279296875,
                            "width": 54.25920104980469,
                            "height": 76.26240539550781,
                            "opacity": 1,
                            "fills": [
                              {
                                "type": "SOLID",
                                "visible": true,
                                "opacity": 1,
                                "blendMode": "NORMAL",
                                "color": {
                                  "r": 0,
                                  "g": 0,
                                  "b": 0
                                },
                                "boundVariables": {}
                              }
                            ],
                            "strokes": [],
                            "strokeWeight": 0.43928295373916626,
                            "cornerRadius": 0,
                            "layoutSizingHorizontal": "FIXED",
                            "layoutSizingVertical": "FIXED",
                            "reactions": [],
                            "layoutPositioning": "AUTO",
                            "vectorPaths": [
                              {
                                "windingRule": "NONZERO",
                                "data": "M 16.703999914991396 30.75839966834482 L 39.85919880796148 8.755197493907422 L 2.3039993897618625 8.755197493907422 L 2.3039993897618625 0 L 52.531198217307086 0 L 52.531198217307086 8.639998972451874 L 29.83679946931817 30.067197858458748 C 30.60480098251913 29.913597541032896 31.334398414628136 29.836799289668683 32.025596343281656 29.836799289668683 C 34.71359820625767 29.836799289668683 37.36320132871761 30.335999749098082 39.97439960714618 31.334400667956885 C 42.6624014701222 32.25600028369354 45.043198913120776 33.676799595920116 47.11679727671779 35.59680013051557 C 49.267196936044016 37.51680066511102 50.995197479723394 39.897601389044546 52.30079661893768 42.73920153937665 C 53.6063980469702 45.504001530995836 54.25920104980469 48.729598660195144 54.25920104980469 52.41599941196021 C 54.25920104980469 55.56479905273479 53.6447983133651 58.598399027644604 52.416000469880025 61.51679933668964 C 51.2639993444877 64.35839948702174 49.53600108962655 66.89280338940418 47.23200112766013 69.12000398664672 C 44.928001165693715 71.2704040437066 42.12479850353299 72.99840065292463 38.82239771881444 74.3040007761236 C 35.51999693409589 75.60960089932257 31.756799819093224 76.26240539550781 27.53280179616998 76.26240539550781 C 23.38560049133949 76.26240539550781 19.622399561639767 75.64800469800902 16.243199770010232 74.41920463815553 C 12.940800129700794 73.11360451495656 10.099200252902817 71.42400588701142 7.718400139616301 69.35040560719473 C 5.414400177649881 67.20000574086973 3.571199788460069 64.74240314160943 2.1887999257211286 61.97760257778564 C 0.8831996420977266 59.136002999658146 0.15359973043563444 56.14080119675609 0 52.99200041157228 L 9.446399920356264 50.80320027515594 C 9.52320007167636 53.41440109375849 10.060799986507917 55.795201817692025 11.059199664850935 57.94560168401703 C 12.057599343193953 60.01920196383372 13.36319924534765 61.78560218100333 14.976000134251436 63.24480233552584 C 16.588799878746105 64.70400249004835 18.47039996212626 65.8176040284463 20.620799621452488 66.58560447116632 C 22.771200425187832 67.35360434168173 25.036798976350237 67.73760036687459 27.417597945227637 67.73760036687459 C 30.02879851247444 67.73760036687459 32.40959900723066 67.35360434168173 34.559998666556886 66.58560447116632 C 36.71039832588311 65.8176040284463 38.5152001652917 64.7424000898515 39.97439960714618 63.36000009404191 C 41.43360133781889 61.977600098232315 42.54719914505868 60.36480248730702 43.315198369441404 58.5216026836291 C 44.15999888955334 56.678402307746566 44.58240105695784 54.68160314031715 44.58240105695784 52.53120327399215 C 44.58240105695784 49.99680261410251 44.12160014903726 47.80800018886772 43.20000062201434 45.96479981298519 C 42.27839880617319 44.04479927838974 41.04959791093047 42.50879991882865 39.51359946216501 41.356800971362446 C 37.97759872458132 40.12800072077409 36.21119867744646 39.206401105037436 34.21439932076043 38.591999835334036 C 32.29439897098537 37.977600854449086 30.297598088420514 37.670399456657904 28.223997436005266 37.670399456657904 C 25.766397171398655 37.670399456657904 23.500798620236253 38.01600036160094 21.42719911223012 38.70720064560804 L 16.703999914991396 30.75839966834482 Z"
                              }
                            ],
                            "effects": [],
                            "parentId": "7235:2053",
                            "children": []
                          }
                        ],
                        "clipsContent": false,
                        "layoutPositioning": "AUTO",
                        "effects": [],
                        "parentId": "7235:2052"
                      },
                      {
                        "id": "7235:2055",
                        "name": "Frame 1235",
                        "type": "FRAME",
                        "x": 0,
                        "y": 288,
                        "width": 144,
                        "height": 144,
                        "opacity": 1,
                        "fills": [],
                        "strokes": [],
                        "strokeWeight": 1.6000001430511475,
                        "cornerRadius": 0,
                        "layoutMode": "HORIZONTAL",
                        "primaryAxisAlignItems": "CENTER",
                        "counterAxisAlignItems": "CENTER",
                        "itemSpacing": 0,
                        "layoutSizingHorizontal": "FIXED",
                        "layoutSizingVertical": "FIXED",
                        "paddingLeft": 0,
                        "paddingRight": 0,
                        "paddingTop": 0,
                        "paddingBottom": 0,
                        "reactions": [],
                        "children": [
                          {
                            "id": "7235:2056",
                            "name": "2",
                            "type": "VECTOR",
                            "x": 46.310302734375,
                            "y": 33.86865234375,
                            "width": 51.37920379638672,
                            "height": 76.26240539550781,
                            "opacity": 1,
                            "fills": [
                              {
                                "type": "SOLID",
                                "visible": true,
                                "opacity": 1,
                                "blendMode": "NORMAL",
                                "color": {
                                  "r": 0,
                                  "g": 0,
                                  "b": 0
                                },
                                "boundVariables": {}
                              }
                            ],
                            "strokes": [],
                            "strokeWeight": 0.43928295373916626,
                            "cornerRadius": 0,
                            "layoutSizingHorizontal": "FIXED",
                            "layoutSizingVertical": "FIXED",
                            "reactions": [],
                            "layoutPositioning": "AUTO",
                            "vectorPaths": [
                              {
                                "windingRule": "NONZERO",
                                "data": "M 1.0367999722604826 27.187202891554318 C 0.8064000843886296 26.188804341418887 0.6912000927689886 25.075204227289905 0.6912000927689886 23.846404075046223 C 0.6912000927689886 20.62080453371341 1.2671999554997642 17.587204038652537 2.4191996809613157 14.74560182692418 C 3.5711996925251537 11.827202895856853 5.222399937981818 9.292803583212253 7.372800226596449 7.142403888990376 C 9.523199943006507 4.915205186611262 12.172799321104819 3.1872046148907307 15.321599886770244 1.9584021738287811 C 18.470399308026522 0.6528007246095937 22.041598237612245 0 26.035198201406274 0 C 29.875199002891833 0 33.33120094493192 0.6144012205309748 36.40320021282939 1.8432036615929241 C 39.47520176954515 2.9952025168611 42.04800061281494 4.6080022875275075 44.121599031457045 6.681602973592145 C 46.2719987478671 8.755203659656782 47.88480006105351 11.174404460065528 48.96000220807683 13.939205374818378 C 50.112001075231525 16.627202703777456 50.68800203468773 19.507202893705585 50.68800203468773 22.579204418723922 C 50.68800203468773 27.494405027698647 49.42080236529025 31.872002661360217 46.886403026495294 35.71200113440574 C 44.352001398882045 39.55200189626953 40.93439819837735 42.816002467559805 36.63359876555724 45.50400208533715 L 21.31200040466586 55.29600608802625 C 19.084800534896992 56.75520669796905 17.04960085779029 58.48320307352275 15.206400610406318 60.480002462611886 C 13.363200363022347 62.47680242390558 12.211199969988796 64.81920536056623 11.75040019424509 67.50720555054814 L 51.37920379638672 67.50720555054814 L 51.37920379638672 76.26240539550781 L 0 76.26240539550781 C 0.15360002061533082 70.50240539712127 1.4976001294739034 65.31840406342937 4.03200023120829 60.71040406472014 C 6.566400142207819 56.02560391344453 10.828799879818247 51.72480261765222 16.81919963477443 47.808002847631194 L 30.182399616327064 39.16800380372565 C 37.40160029914533 34.56000380501641 41.0112017849636 29.068802242528747 41.0112017849636 22.694402168020357 C 41.0112017849636 20.851203084063968 40.66560090411411 19.084803008264817 39.974400668293974 17.395201940622904 C 39.359999441423504 15.705600872980991 38.40000114840069 14.208001140429289 37.09440197452838 12.902404268846636 C 35.865601809605735 11.520003811470211 34.291200000894165 10.444804727298697 32.371199600151385 9.676805490453246 C 30.451199199408606 8.908806253607795 28.262399978523717 8.524806635185069 25.804799648678426 8.524806635185069 C 20.736000971088515 8.524806635185069 16.85760028365841 10.09920461295459 14.16959949373669 13.24800056849363 C 11.481599848224118 16.320002093511967 10.137600406937546 20.160002855375755 10.137600406937546 24.768002854084994 C 10.137600406937546 26.22720231961866 10.2528004462409 27.417602967783722 10.483199761908182 28.339204798580184 L 1.0367999722604826 27.187202891554318 Z"
                              }
                            ],
                            "effects": [],
                            "parentId": "7235:2055",
                            "children": []
                          }
                        ],
                        "clipsContent": false,
                        "layoutPositioning": "AUTO",
                        "effects": [],
                        "parentId": "7235:2052"
                      },
                      {
                        "id": "7235:2057",
                        "name": "Frame 1234",
                        "type": "FRAME",
                        "x": 0,
                        "y": 576,
                        "width": 144,
                        "height": 144,
                        "opacity": 1,
                        "fills": [],
                        "strokes": [],
                        "strokeWeight": 1.6000001430511475,
                        "cornerRadius": 0,
                        "layoutMode": "HORIZONTAL",
                        "primaryAxisAlignItems": "CENTER",
                        "counterAxisAlignItems": "CENTER",
                        "itemSpacing": 0,
                        "layoutSizingHorizontal": "FIXED",
                        "layoutSizingVertical": "FIXED",
                        "paddingLeft": 0,
                        "paddingRight": 11.200000762939453,
                        "paddingTop": 0,
                        "paddingBottom": 0,
                        "reactions": [],
                        "children": [
                          {
                            "id": "7235:2058",
                            "name": "1",
                            "type": "VECTOR",
                            "x": 52.518310546875,
                            "y": 34.675048828125,
                            "width": 27.763200759887695,
                            "height": 74.64959716796875,
                            "opacity": 1,
                            "fills": [
                              {
                                "type": "SOLID",
                                "visible": true,
                                "opacity": 1,
                                "blendMode": "NORMAL",
                                "color": {
                                  "r": 0,
                                  "g": 0,
                                  "b": 0
                                },
                                "boundVariables": {}
                              }
                            ],
                            "strokes": [],
                            "strokeWeight": 0.43928295373916626,
                            "cornerRadius": 0,
                            "layoutSizingHorizontal": "FIXED",
                            "layoutSizingVertical": "FIXED",
                            "reactions": [],
                            "layoutPositioning": "AUTO",
                            "vectorPaths": [
                              {
                                "windingRule": "NONZERO",
                                "data": "M 18.316799171732722 74.64959716796875 L 18.316799171732722 20.15999755859375 L 0 20.15999755859375 L 0 14.630397033691407 C 5.222400068544256 14.399995422363283 9.484799947778232 12.9407958984375 12.787200400641348 10.252798461914063 C 16.16640024303896 7.487997436523438 18.316799934672144 4.0703979492187505 19.2383994755409 0 L 27.763200759887695 0 L 27.763200759887695 74.64959716796875 L 18.316799171732722 74.64959716796875 Z"
                              }
                            ],
                            "effects": [],
                            "parentId": "7235:2057",
                            "children": []
                          }
                        ],
                        "clipsContent": false,
                        "layoutPositioning": "AUTO",
                        "effects": [],
                        "parentId": "7235:2052"
                      }
                    ],
                    "clipsContent": false,
                    "layoutPositioning": "AUTO",
                    "effects": [],
                    "parentId": "7235:2051"
                  }
                ],
                "clipsContent": false,
                "layoutPositioning": "AUTO",
                "effects": [],
                "parentId": "5533:3911"
              }
            ],
            "clipsContent": false,
            "layoutPositioning": "AUTO",
            "parentId": "5533:3901"
          },
          {
            "id": "7335:742",
            "name": "Property 1=1",
            "type": "COMPONENT",
            "x": 328,
            "y": 0,
            "width": 144,
            "height": 144,
            "opacity": 1,
            "fills": [],
            "strokes": [],
            "strokeWeight": 1.600000262260437,
            "cornerRadius": 0,
            "layoutMode": "HORIZONTAL",
            "primaryAxisAlignItems": "CENTER",
            "counterAxisAlignItems": "CENTER",
            "itemSpacing": 16,
            "layoutSizingHorizontal": "FIXED",
            "layoutSizingVertical": "FIXED",
            "paddingLeft": 0,
            "paddingRight": 0,
            "paddingTop": 0,
            "paddingBottom": 0,
            "reactions": [
              {
                "action": {
                  "type": "NODE",
                  "destinationId": null,
                  "navigation": "CHANGE_TO",
                  "transition": {
                    "type": "SMART_ANIMATE",
                    "easing": {
                      "type": "GENTLE"
                    },
                    "duration": 1.0220937728881836
                  },
                  "resetVideoPosition": false
                },
                "actions": [
                  {
                    "type": "NODE",
                    "destinationId": null,
                    "navigation": "CHANGE_TO",
                    "transition": {
                      "type": "SMART_ANIMATE",
                      "easing": {
                        "type": "GENTLE"
                      },
                      "duration": 1.0220937728881836
                    },
                    "resetVideoPosition": false
                  }
                ],
                "trigger": {
                  "type": "AFTER_TIMEOUT",
                  "timeout": 0.8
                }
              }
            ],
            "children": [
              {
                "id": "7335:743",
                "name": "Frame 1233",
                "type": "FRAME",
                "x": 0,
                "y": 0,
                "width": 144,
                "height": 144,
                "opacity": 1,
                "fills": [
                  {
                    "type": "SOLID",
                    "visible": true,
                    "opacity": 1,
                    "blendMode": "NORMAL",
                    "color": {
                      "r": 0.1730685830116272,
                      "g": 0.5052500367164612,
                      "b": 0.6483436226844788
                    },
                    "boundVariables": {}
                  }
                ],
                "strokes": [],
                "strokeWeight": 1.6000001430511475,
                "cornerRadius": 1000,
                "layoutMode": "HORIZONTAL",
                "primaryAxisAlignItems": "CENTER",
                "counterAxisAlignItems": "MAX",
                "itemSpacing": 10,
                "layoutSizingHorizontal": "HUG",
                "layoutSizingVertical": "FIXED",
                "paddingLeft": 0,
                "paddingRight": 0,
                "paddingTop": 0,
                "paddingBottom": 0,
                "reactions": [],
                "children": [
                  {
                    "id": "7335:744",
                    "name": "Frame 1232",
                    "type": "FRAME",
                    "x": 0,
                    "y": -576,
                    "width": 144,
                    "height": 720,
                    "opacity": 1,
                    "fills": [],
                    "strokes": [],
                    "strokeWeight": 1.6000001430511475,
                    "cornerRadius": 0,
                    "layoutMode": "VERTICAL",
                    "primaryAxisAlignItems": "CENTER",
                    "counterAxisAlignItems": "CENTER",
                    "itemSpacing": 144.00001525878906,
                    "layoutSizingHorizontal": "FIXED",
                    "layoutSizingVertical": "FIXED",
                    "paddingLeft": 0,
                    "paddingRight": 0,
                    "paddingTop": 0,
                    "paddingBottom": 0,
                    "reactions": [],
                    "children": [
                      {
                        "id": "7335:745",
                        "name": "Frame 1236",
                        "type": "FRAME",
                        "x": 0,
                        "y": 0,
                        "width": 144,
                        "height": 144,
                        "opacity": 1,
                        "fills": [],
                        "strokes": [],
                        "strokeWeight": 1.6000001430511475,
                        "cornerRadius": 0,
                        "layoutMode": "HORIZONTAL",
                        "primaryAxisAlignItems": "CENTER",
                        "counterAxisAlignItems": "CENTER",
                        "itemSpacing": 0,
                        "layoutSizingHorizontal": "FIXED",
                        "layoutSizingVertical": "FIXED",
                        "paddingLeft": 1.6000001430511475,
                        "paddingRight": 0,
                        "paddingTop": 3.200000286102295,
                        "paddingBottom": 0,
                        "reactions": [],
                        "children": [
                          {
                            "id": "7335:746",
                            "name": "3",
                            "type": "VECTOR",
                            "x": 45.670166015625,
                            "y": 35.4686279296875,
                            "width": 54.25920104980469,
                            "height": 76.26240539550781,
                            "opacity": 1,
                            "fills": [
                              {
                                "type": "SOLID",
                                "visible": true,
                                "opacity": 1,
                                "blendMode": "NORMAL",
                                "color": {
                                  "r": 0,
                                  "g": 0,
                                  "b": 0
                                },
                                "boundVariables": {}
                              }
                            ],
                            "strokes": [],
                            "strokeWeight": 0.43928295373916626,
                            "cornerRadius": 0,
                            "layoutSizingHorizontal": "FIXED",
                            "layoutSizingVertical": "FIXED",
                            "reactions": [],
                            "layoutPositioning": "AUTO",
                            "vectorPaths": [
                              {
                                "windingRule": "NONZERO",
                                "data": "M 16.703999914991396 30.75839966834482 L 39.85919880796148 8.755197493907422 L 2.3039993897618625 8.755197493907422 L 2.3039993897618625 0 L 52.531198217307086 0 L 52.531198217307086 8.639998972451874 L 29.83679946931817 30.067197858458748 C 30.60480098251913 29.913597541032896 31.334398414628136 29.836799289668683 32.025596343281656 29.836799289668683 C 34.71359820625767 29.836799289668683 37.36320132871761 30.335999749098082 39.97439960714618 31.334400667956885 C 42.6624014701222 32.25600028369354 45.043198913120776 33.676799595920116 47.11679727671779 35.59680013051557 C 49.267196936044016 37.51680066511102 50.995197479723394 39.897601389044546 52.30079661893768 42.73920153937665 C 53.6063980469702 45.504001530995836 54.25920104980469 48.729598660195144 54.25920104980469 52.41599941196021 C 54.25920104980469 55.56479905273479 53.6447983133651 58.598399027644604 52.416000469880025 61.51679933668964 C 51.2639993444877 64.35839948702174 49.53600108962655 66.89280338940418 47.23200112766013 69.12000398664672 C 44.928001165693715 71.2704040437066 42.12479850353299 72.99840065292463 38.82239771881444 74.3040007761236 C 35.51999693409589 75.60960089932257 31.756799819093224 76.26240539550781 27.53280179616998 76.26240539550781 C 23.38560049133949 76.26240539550781 19.622399561639767 75.64800469800902 16.243199770010232 74.41920463815553 C 12.940800129700794 73.11360451495656 10.099200252902817 71.42400588701142 7.718400139616301 69.35040560719473 C 5.414400177649881 67.20000574086973 3.571199788460069 64.74240314160943 2.1887999257211286 61.97760257778564 C 0.8831996420977266 59.136002999658146 0.15359973043563444 56.14080119675609 0 52.99200041157228 L 9.446399920356264 50.80320027515594 C 9.52320007167636 53.41440109375849 10.060799986507917 55.795201817692025 11.059199664850935 57.94560168401703 C 12.057599343193953 60.01920196383372 13.36319924534765 61.78560218100333 14.976000134251436 63.24480233552584 C 16.588799878746105 64.70400249004835 18.47039996212626 65.8176040284463 20.620799621452488 66.58560447116632 C 22.771200425187832 67.35360434168173 25.036798976350237 67.73760036687459 27.417597945227637 67.73760036687459 C 30.02879851247444 67.73760036687459 32.40959900723066 67.35360434168173 34.559998666556886 66.58560447116632 C 36.71039832588311 65.8176040284463 38.5152001652917 64.7424000898515 39.97439960714618 63.36000009404191 C 41.43360133781889 61.977600098232315 42.54719914505868 60.36480248730702 43.315198369441404 58.5216026836291 C 44.15999888955334 56.678402307746566 44.58240105695784 54.68160314031715 44.58240105695784 52.53120327399215 C 44.58240105695784 49.99680261410251 44.12160014903726 47.80800018886772 43.20000062201434 45.96479981298519 C 42.27839880617319 44.04479927838974 41.04959791093047 42.50879991882865 39.51359946216501 41.356800971362446 C 37.97759872458132 40.12800072077409 36.21119867744646 39.206401105037436 34.21439932076043 38.591999835334036 C 32.29439897098537 37.977600854449086 30.297598088420514 37.670399456657904 28.223997436005266 37.670399456657904 C 25.766397171398655 37.670399456657904 23.500798620236253 38.01600036160094 21.42719911223012 38.70720064560804 L 16.703999914991396 30.75839966834482 Z"
                              }
                            ],
                            "effects": [],
                            "parentId": "7335:745",
                            "children": []
                          }
                        ],
                        "clipsContent": false,
                        "layoutPositioning": "AUTO",
                        "effects": [],
                        "parentId": "7335:744"
                      },
                      {
                        "id": "7335:747",
                        "name": "Frame 1235",
                        "type": "FRAME",
                        "x": 0,
                        "y": 288,
                        "width": 144,
                        "height": 144,
                        "opacity": 1,
                        "fills": [],
                        "strokes": [],
                        "strokeWeight": 1.6000001430511475,
                        "cornerRadius": 0,
                        "layoutMode": "HORIZONTAL",
                        "primaryAxisAlignItems": "CENTER",
                        "counterAxisAlignItems": "CENTER",
                        "itemSpacing": 0,
                        "layoutSizingHorizontal": "FIXED",
                        "layoutSizingVertical": "FIXED",
                        "paddingLeft": 0,
                        "paddingRight": 0,
                        "paddingTop": 0,
                        "paddingBottom": 0,
                        "reactions": [],
                        "children": [
                          {
                            "id": "7335:748",
                            "name": "2",
                            "type": "VECTOR",
                            "x": 46.310302734375,
                            "y": 33.86865234375,
                            "width": 51.37920379638672,
                            "height": 76.26240539550781,
                            "opacity": 1,
                            "fills": [
                              {
                                "type": "SOLID",
                                "visible": true,
                                "opacity": 1,
                                "blendMode": "NORMAL",
                                "color": {
                                  "r": 0,
                                  "g": 0,
                                  "b": 0
                                },
                                "boundVariables": {}
                              }
                            ],
                            "strokes": [],
                            "strokeWeight": 0.43928295373916626,
                            "cornerRadius": 0,
                            "layoutSizingHorizontal": "FIXED",
                            "layoutSizingVertical": "FIXED",
                            "reactions": [],
                            "layoutPositioning": "AUTO",
                            "vectorPaths": [
                              {
                                "windingRule": "NONZERO",
                                "data": "M 1.0367999722604826 27.187202891554318 C 0.8064000843886296 26.188804341418887 0.6912000927689886 25.075204227289905 0.6912000927689886 23.846404075046223 C 0.6912000927689886 20.62080453371341 1.2671999554997642 17.587204038652537 2.4191996809613157 14.74560182692418 C 3.5711996925251537 11.827202895856853 5.222399937981818 9.292803583212253 7.372800226596449 7.142403888990376 C 9.523199943006507 4.915205186611262 12.172799321104819 3.1872046148907307 15.321599886770244 1.9584021738287811 C 18.470399308026522 0.6528007246095937 22.041598237612245 0 26.035198201406274 0 C 29.875199002891833 0 33.33120094493192 0.6144012205309748 36.40320021282939 1.8432036615929241 C 39.47520176954515 2.9952025168611 42.04800061281494 4.6080022875275075 44.121599031457045 6.681602973592145 C 46.2719987478671 8.755203659656782 47.88480006105351 11.174404460065528 48.96000220807683 13.939205374818378 C 50.112001075231525 16.627202703777456 50.68800203468773 19.507202893705585 50.68800203468773 22.579204418723922 C 50.68800203468773 27.494405027698647 49.42080236529025 31.872002661360217 46.886403026495294 35.71200113440574 C 44.352001398882045 39.55200189626953 40.93439819837735 42.816002467559805 36.63359876555724 45.50400208533715 L 21.31200040466586 55.29600608802625 C 19.084800534896992 56.75520669796905 17.04960085779029 58.48320307352275 15.206400610406318 60.480002462611886 C 13.363200363022347 62.47680242390558 12.211199969988796 64.81920536056623 11.75040019424509 67.50720555054814 L 51.37920379638672 67.50720555054814 L 51.37920379638672 76.26240539550781 L 0 76.26240539550781 C 0.15360002061533082 70.50240539712127 1.4976001294739034 65.31840406342937 4.03200023120829 60.71040406472014 C 6.566400142207819 56.02560391344453 10.828799879818247 51.72480261765222 16.81919963477443 47.808002847631194 L 30.182399616327064 39.16800380372565 C 37.40160029914533 34.56000380501641 41.0112017849636 29.068802242528747 41.0112017849636 22.694402168020357 C 41.0112017849636 20.851203084063968 40.66560090411411 19.084803008264817 39.974400668293974 17.395201940622904 C 39.359999441423504 15.705600872980991 38.40000114840069 14.208001140429289 37.09440197452838 12.902404268846636 C 35.865601809605735 11.520003811470211 34.291200000894165 10.444804727298697 32.371199600151385 9.676805490453246 C 30.451199199408606 8.908806253607795 28.262399978523717 8.524806635185069 25.804799648678426 8.524806635185069 C 20.736000971088515 8.524806635185069 16.85760028365841 10.09920461295459 14.16959949373669 13.24800056849363 C 11.481599848224118 16.320002093511967 10.137600406937546 20.160002855375755 10.137600406937546 24.768002854084994 C 10.137600406937546 26.22720231961866 10.2528004462409 27.417602967783722 10.483199761908182 28.339204798580184 L 1.0367999722604826 27.187202891554318 Z"
                              }
                            ],
                            "effects": [],
                            "parentId": "7335:747",
                            "children": []
                          }
                        ],
                        "clipsContent": false,
                        "layoutPositioning": "AUTO",
                        "effects": [],
                        "parentId": "7335:744"
                      },
                      {
                        "id": "7335:749",
                        "name": "Frame 1234",
                        "type": "FRAME",
                        "x": 0,
                        "y": 576,
                        "width": 144,
                        "height": 144,
                        "opacity": 1,
                        "fills": [],
                        "strokes": [],
                        "strokeWeight": 1.6000001430511475,
                        "cornerRadius": 0,
                        "layoutMode": "HORIZONTAL",
                        "primaryAxisAlignItems": "CENTER",
                        "counterAxisAlignItems": "CENTER",
                        "itemSpacing": 0,
                        "layoutSizingHorizontal": "FIXED",
                        "layoutSizingVertical": "FIXED",
                        "paddingLeft": 0,
                        "paddingRight": 11.200000762939453,
                        "paddingTop": 0,
                        "paddingBottom": 0,
                        "reactions": [],
                        "children": [
                          {
                            "id": "7335:750",
                            "name": "1",
                            "type": "VECTOR",
                            "x": 52.518310546875,
                            "y": 34.675048828125,
                            "width": 27.763200759887695,
                            "height": 74.64959716796875,
                            "opacity": 1,
                            "fills": [
                              {
                                "type": "SOLID",
                                "visible": true,
                                "opacity": 1,
                                "blendMode": "NORMAL",
                                "color": {
                                  "r": 0,
                                  "g": 0,
                                  "b": 0
                                },
                                "boundVariables": {}
                              }
                            ],
                            "strokes": [],
                            "strokeWeight": 0.43928295373916626,
                            "cornerRadius": 0,
                            "layoutSizingHorizontal": "FIXED",
                            "layoutSizingVertical": "FIXED",
                            "reactions": [],
                            "layoutPositioning": "AUTO",
                            "vectorPaths": [
                              {
                                "windingRule": "NONZERO",
                                "data": "M 18.316799171732722 74.64959716796875 L 18.316799171732722 20.15999755859375 L 0 20.15999755859375 L 0 14.630397033691407 C 5.222400068544256 14.399995422363283 9.484799947778232 12.9407958984375 12.787200400641348 10.252798461914063 C 16.16640024303896 7.487997436523438 18.316799934672144 4.0703979492187505 19.2383994755409 0 L 27.763200759887695 0 L 27.763200759887695 74.64959716796875 L 18.316799171732722 74.64959716796875 Z"
                              }
                            ],
                            "effects": [],
                            "parentId": "7335:749",
                            "children": []
                          }
                        ],
                        "clipsContent": false,
                        "layoutPositioning": "AUTO",
                        "effects": [],
                        "parentId": "7335:744"
                      }
                    ],
                    "clipsContent": false,
                    "layoutPositioning": "AUTO",
                    "effects": [],
                    "parentId": "7335:743"
                  }
                ],
                "clipsContent": false,
                "layoutPositioning": "AUTO",
                "effects": [],
                "parentId": "7335:742"
              }
            ],
            "clipsContent": false,
            "layoutPositioning": "AUTO",
            "parentId": "5533:3901"
          }
        ],
        "clipsContent": false,
        "layoutPositioning": "AUTO",
        "parentId": "5533:4251"
      }
    ],
    "clipsContent": false,
    "layoutPositioning": "AUTO",
    "componentProperties": {
      "Property 1": {
        "value": "3",
        "type": "VARIANT",
        "boundVariables": {}
      }
    },
    "overrides": [],
    "parentId": "5533:3016"
  }
]);
  
  // Update debug panel
  function updateDebugPanel() {
    const nodeCount = document.querySelectorAll('[data-figma-id]').length;
    document.getElementById('node-count').textContent = nodeCount;
    
    // Check for event handlers - look for both global function and actual event listeners
    const hasGlobalHandler = typeof window.handleFigmaEvent === 'function';
    const hasEventElements = document.querySelectorAll('[data-has-reactions="true"], [data-variant], [data-variant-property-1]').length > 0;
    const hasEventHandlers = hasGlobalHandler && hasEventElements;
    document.getElementById('event-status').textContent = hasEventHandlers ? '✅ Loaded' : '❌ Missing';
    document.getElementById('event-status').className = hasEventHandlers ? 'success' : 'error';
    
    // Check for animation data
    const hasAnimations = document.querySelectorAll('[data-reaction-destination]').length > 0;
    document.getElementById('animation-status').textContent = hasAnimations ? '✅ Found' : '❌ None';
    document.getElementById('animation-status').className = hasAnimations ? 'success' : 'error';
    
    console.log('🔍 Debug: Found', nodeCount, 'Figma nodes');
    console.log('🔍 Debug: Event handlers', hasEventHandlers ? 'loaded' : 'missing');
    console.log('🔍 Debug: Animation data', hasAnimations ? 'found' : 'none');
    
    // Log all nodes with their properties
    document.querySelectorAll('[data-figma-id]').forEach((node, index) => {
      const figmaId = node.getAttribute('data-figma-id');
      const reactionDestination = node.getAttribute('data-reaction-destination');
      const reactionActionType = node.getAttribute('data-reaction-action-type');
      const reactionTriggerType = node.getAttribute('data-reaction-trigger-type');
      const computedStyle = window.getComputedStyle(node);
      
      console.log(`🔍 Node ${index + 1}:`, {
        id: figmaId,
        tagName: node.tagName,
        className: node.className,
        hasReactions: !!reactionDestination,
        reactionDestination: reactionDestination,
        reactionActionType: reactionActionType,
        reactionTriggerType: reactionTriggerType,
        computedStyle: {
          width: computedStyle.width,
          height: computedStyle.height,
          display: computedStyle.display,
          position: computedStyle.position
        }
      });
    });
  }
  
  // Run after DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', updateDebugPanel);
  } else {
    updateDebugPanel();
  }
  
  // Also run after a short delay to catch any dynamic content
  setTimeout(updateDebugPanel, 100);
})();
</script>
</body>
</html>